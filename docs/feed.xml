<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://travisdowns.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://travisdowns.github.io/" rel="alternate" type="text/html" /><updated>2021-08-31T23:53:36+00:00</updated><id>https://travisdowns.github.io/feed.xml</id><title type="html">Performance Matters</title><subtitle>A blog about low-level software and hardware performance.</subtitle><author><name>Travis Downs</name><email>travis.downs@gmail.com</email></author><entry><title type="html">Your CPU May Have Slowed Down on Wednesday</title><link href="https://travisdowns.github.io/blog/2021/06/17/rip-zero-opt.html" rel="alternate" type="text/html" title="Your CPU May Have Slowed Down on Wednesday" /><published>2021-06-17T00:00:00+00:00</published><updated>2021-06-17T00:00:00+00:00</updated><id>https://travisdowns.github.io/blog/2021/06/17/rip-zero-opt</id><content type="html" xml:base="https://travisdowns.github.io/blog/2021/06/17/rip-zero-opt.html">&lt;!-- boilerplate 
page.assets: /assets/rip-zero-opt
assetpath: /assets/rip-zero-opt
tablepath: /misc/tables/rip-zero-opt
--&gt;

&lt;h2 id=&quot;a-strange-performance-effect&quot;&gt;A Strange Performance Effect&lt;/h2&gt;

&lt;p&gt;The plot below shows the throughput of filling a region of the given size (varying on the x-axis) with zeros&lt;sup id=&quot;fnref:stdfill&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:stdfill&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; on Skylake (and Ice Lake in the second tab).&lt;/p&gt;

&lt;p&gt;The two series were generated under apparently identical conditions: the same binary on the same machine. Only the date the benchmark was run varies. That is, on Monday, June 7th, filling with zeros is substantially faster than the same benchmark on Wednesday, at least when the region no longer fits in the L2 cache&lt;sup id=&quot;fnref:whitelie&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:whitelie&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;div class=&quot;tabs&quot;&gt;
    &lt;!-- Courtesy of https://codepen.io/Merri/pen/bytea --&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-fig1-1&quot; name=&quot;tab-group-fig1&quot; checked=&quot;&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-fig1-1&quot;&gt;Skylake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/rip-zero-opt/skl/fig1.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/post3/skl-combined/l2-focus.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/rip-zero-opt/skl/fig1.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/rip-zero-opt/skl/fig1.svg&quot; alt=&quot;Figure 13: A chart of region size (x-axis) versus fill throughput (y-axis) with two series, Monday and Wednesday, with the Wednesday series showing worse performance in L3 and RAM&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-fig1-2&quot; name=&quot;tab-group-fig1&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-fig1-2&quot;&gt;Ice Lake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/rip-zero-opt/icl/fig1.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/post3/icl-combined/l2-focus.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/rip-zero-opt/icl/fig1.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/rip-zero-opt/icl/fig1.svg&quot; alt=&quot;Figure 13: A chart of region size (x-axis) versus fill throughput (y-axis) with two series, Monday and Wednesday, with the Wednesday series showing worse performance in L3 and RAM&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;h3 id=&quot;hump-day-strikes-back&quot;&gt;Hump Day Strikes Back&lt;/h3&gt;

&lt;p&gt;What’s going on here? Are my Skylake and Ice Lake hosts simply work-weary by Wednesday and don’t put in as much effort? Is there a new crypto-coin based on who can store the most zeros and this is a countermeasure to avoid ballooning CPU prices in the face of this new workload?&lt;/p&gt;

&lt;p&gt;Believe it or not, it is none of the above!&lt;/p&gt;

&lt;p&gt;These hosts run Ubuntu 20.04 and on Wednesday June 9th an update to the &lt;a href=&quot;https://launchpad.net/ubuntu/+source/intel-microcode&quot;&gt;intel-&lt;abbr title=&quot;Internal instructions and other logic forming part of a CPU which may be used to implement user-visible instructions and control other aspects of CPU behavior and which may be modified dynamically by vendor-provided updates.&quot;&gt;microcode&lt;/abbr&gt;&lt;/a&gt; OS package was released. After a reboot&lt;sup id=&quot;fnref:reboot&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:reboot&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, this loads the CPU with new &lt;em&gt;&lt;abbr title=&quot;Internal instructions and other logic forming part of a CPU which may be used to implement user-visible instructions and control other aspects of CPU behavior and which may be modified dynamically by vendor-provided updates.&quot;&gt;microcode&lt;/abbr&gt;&lt;/em&gt; (released a day earlier by Intel) that causes the behavior shown above. Specifically, this &lt;abbr title=&quot;Internal instructions and other logic forming part of a CPU which may be used to implement user-visible instructions and control other aspects of CPU behavior and which may be modified dynamically by vendor-provided updates.&quot;&gt;microcode&lt;/abbr&gt;&lt;sup id=&quot;fnref:versions&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:versions&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; disables the &lt;a href=&quot;/blog/2020/05/13/intel-zero-opt.html&quot;&gt;hardware zero store&lt;/a&gt; optimization we discussed in a previous post. It was disabled to mitigate &lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-24512&quot;&gt;CVE-2020-24512&lt;/a&gt; further described&lt;sup id=&quot;fnref:barely&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:barely&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; in Intel security advisory &lt;a href=&quot;https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00464.html&quot;&gt;INTEL-SA-00464&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To be clear, I don’t know &lt;em&gt;for sure&lt;/em&gt; that the &lt;abbr title=&quot;Internal instructions and other logic forming part of a CPU which may be used to implement user-visible instructions and control other aspects of CPU behavior and which may be modified dynamically by vendor-provided updates.&quot;&gt;microcode&lt;/abbr&gt; disables the zero store optimization – but the evidence is rather overwhelming. After the update, performance is the same when filling zeros as for any other value, and the performance counters tracking L2 evictions suggestion that substantially all evictions are now non-silent (recall from the previous posts that silent evictions were a hallmark of the optimization).&lt;/p&gt;

&lt;p&gt;Although I suspect the performance impact will be minuscule on average&lt;sup id=&quot;fnref:impact&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:impact&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;, this surprise still serves as a reminder that raw CPU performance can &lt;em&gt;silently&lt;/em&gt; change due to &lt;abbr title=&quot;Internal instructions and other logic forming part of a CPU which may be used to implement user-visible instructions and control other aspects of CPU behavior and which may be modified dynamically by vendor-provided updates.&quot;&gt;microcode&lt;/abbr&gt; updates and most Linux distributions and modern Windows have these updates enabled by default. We’ve &lt;a href=&quot;/blog/2019/03/19/random-writes-and-microcode-oh-my.html&quot;&gt;seen this before&lt;/a&gt;. If you are trying to run reproducible benchmarks, you should always re-run your &lt;em&gt;entire&lt;/em&gt; suite in order to make accurate comparisons, even on the same hardware, rather than just running the stuff you think has changed.&lt;/p&gt;

&lt;h3 id=&quot;reproduction&quot;&gt;Reproduction&lt;/h3&gt;

&lt;p&gt;The code to collect this performance data and reproduce my results is available in &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/post3&quot;&gt;zero-fill-bench&lt;/a&gt;, with some &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench#third-post-rip-zero-store-optimization&quot;&gt;instructions&lt;/a&gt; in the README.&lt;/p&gt;

&lt;h3 id=&quot;mea-culpa-and-an-unsustainable-path&quot;&gt;Mea Culpa and an Unsustainable Path&lt;/h3&gt;

&lt;p&gt;In writing the earlier blog entries on this topic, I was interested in the &lt;em&gt;performance&lt;/em&gt; aspects of this optimization, not its potential as an attack vector. However, merely by observing (and publishing) the results, the optimization was affected: &lt;a href=&quot;https://en.wikipedia.org/wiki/Measurement_problem&quot;&gt;the system under measurement changed as a result of the observation&lt;/a&gt;. Now I can’t be sure that the optimization wouldn’t have eventually been disabled anyway, but it does seem that the reason for this behavior change to occur now was my earlier post.&lt;/p&gt;

&lt;p&gt;I am not convinced that removing any optimization which can be used in a timing-based side channel is sustainable. I am not sure this is a thread you want to keep pulling on: practically &lt;em&gt;every&lt;/em&gt; aspect of a modern CPU can vary in performance and timing based on internal state&lt;sup id=&quot;fnref:power&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:power&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;. Trying to draw the security boundaries tightly around co-located entities (e.g., processes on the same CPU, especially on the same core), without allowing any leaks seems destined to fail without a complete overhaul of CPU design, likely at the cost of a large amount of performance. There are just too many holes to plug.&lt;/p&gt;

&lt;p&gt;I hope that once the wave of vulnerabilities and disclosures that started with Meltdown and Spectre begins to recede, we can start to work on a measured approach to classifying and mitigating timing and other side-channel attacks. This could start by enumerating which performance characteristics are reasonable guaranteed to hold, and which aren’t. For example, it could be specified whether memory access timing may vary based on the &lt;em&gt;value&lt;/em&gt; accessed. If it is allowed to vary, the zero store optimization would be allowed.&lt;/p&gt;

&lt;p&gt;In any case, I still plan to write about performance-related microarchitectural details. I just hope this outcome does not repeat itself.&lt;/p&gt;

&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;Thanks to JN, Chris Martin, Jonathan and m_ueberall for reporting or fixing typos in the text.&lt;/p&gt;

&lt;p&gt;Stone photo by &lt;a href=&quot;https://unsplash.com/@imagefactory&quot;&gt;Colin Watts&lt;/a&gt; on Unsplash.&lt;/p&gt;

&lt;h3 id=&quot;discussion-and-feedback&quot;&gt;Discussion and Feedback&lt;/h3&gt;

&lt;p&gt;You can join the discussion on &lt;a href=&quot;https://twitter.com/trav_downs/status/1407110595761950720&quot;&gt;Twitter&lt;/a&gt;, &lt;a href=&quot;https://news.ycombinator.com/item?id=27588258&quot;&gt;Hacker News&lt;/a&gt; or &lt;a href=&quot;https://www.reddit.com/r/intel/comments/o5b9gg/your_intel_cpu_may_have_slowed_down_on_wednesday/&quot;&gt;r/Intel&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you have a question or any type of feedback, you can leave a &lt;a href=&quot;#comment-section&quot;&gt;comment below&lt;/a&gt;.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;If you liked this post, check out the &lt;a href=&quot;/&quot;&gt;homepage&lt;/a&gt; for others you might enjoy.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:stdfill&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;Specifically, it uses &lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/fill&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt;&lt;/a&gt; with a zero argument, with some inlining prevention, which ultimately results in a fill which uses a series of 32-byte vector loads and stores to store 256 bytes per unrolled iteration, with a loop body like this:&lt;/p&gt;
      &lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xa0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xc0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xe0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/div&gt;
      &lt;p&gt;So the compiler does a good job: you can’t ask for much better than that. &lt;a href=&quot;#fnref:stdfill&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:whitelie&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I’m doing a bit of a retcon here. The effect is present as described on the gates given, and I observed and benchmarked it on Wednesday myself, but the specific data series used for the plots were generated a week later when I had time to collect the data properly in a relatively noise free environment. So the two series were collected back-to-back on the same day, varying only the hidden parameter you’ll learn about two paragraphs from now. &lt;a href=&quot;#fnref:whitelie&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:reboot&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;To be clear, the &lt;abbr title=&quot;Internal instructions and other logic forming part of a CPU which may be used to implement user-visible instructions and control other aspects of CPU behavior and which may be modified dynamically by vendor-provided updates.&quot;&gt;microcode&lt;/abbr&gt; is not persistent, so it needs to be loaded on &lt;em&gt;every&lt;/em&gt; boot. If you remove or downgrade the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;intel-microcode&lt;/code&gt; package, you’ll be back to an older &lt;abbr title=&quot;Internal instructions and other logic forming part of a CPU which may be used to implement user-visible instructions and control other aspects of CPU behavior and which may be modified dynamically by vendor-provided updates.&quot;&gt;microcode&lt;/abbr&gt; after the next boot. That is, unless you also update your BIOS which can &lt;em&gt;also&lt;/em&gt; come with a &lt;abbr title=&quot;Internal instructions and other logic forming part of a CPU which may be used to implement user-visible instructions and control other aspects of CPU behavior and which may be modified dynamically by vendor-provided updates.&quot;&gt;microcode&lt;/abbr&gt; update: this will be persistent unless you downgrade your BIOS. &lt;a href=&quot;#fnref:reboot&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:versions&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The new June 8th &lt;abbr title=&quot;Internal instructions and other logic forming part of a CPU which may be used to implement user-visible instructions and control other aspects of CPU behavior and which may be modified dynamically by vendor-provided updates.&quot;&gt;microcode&lt;/abbr&gt; versions are &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xea&lt;/code&gt; for Skylake (versus &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xe2&lt;/code&gt; previously) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xa6&lt;/code&gt; for Ice Lake (versus &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xa0&lt;/code&gt; previously). &lt;a href=&quot;#fnref:versions&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:barely&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;em&gt;barely&lt;/em&gt; &lt;a href=&quot;#fnref:barely&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:impact&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The performance regression shown in the plots is close to a worst case: the benchmark only fills zeros and nothing else. Real code doesn’t spend &lt;em&gt;that much&lt;/em&gt; time filling zeros, although zero &lt;em&gt;is&lt;/em&gt; no doubt the dominant value in large block fills, at least because the OS must zero pages before returning them to user processes and memory-safe languages like Java will zero some objects and array types in bulk. &lt;a href=&quot;#fnref:impact&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:power&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This observation becomes almost universal once you consider that the &lt;em&gt;values&lt;/em&gt; involved in any operation affect power use (see e.g. &lt;a href=&quot;https://arxiv.org/pdf/1905.12468.pdf&quot;&gt;Schöne et al&lt;/a&gt; or &lt;a href=&quot;https://hal.inria.fr/hal-02401760/document&quot;&gt;Cornebize and Legrand&lt;/a&gt;). Since power use can be directly (e.g., RAPL or external measurements) or indirectly (e.g., because of heat-dependent frequency changes) observed, it means that in theory &lt;em&gt;any&lt;/em&gt; operation, even those widely considered to be constant-time, may leak information. &lt;a href=&quot;#fnref:power&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Travis Downs</name><email>travis.downs@gmail.com</email></author><category term="blog" /><category term="Intel" /><category term="x86" /><category term="uarch" /><summary type="html">The death of hardware store optimization.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://travisdowns.github.io/assets/rip-zero-opt/og-image.jpg" /><media:content medium="image" url="https://travisdowns.github.io/assets/rip-zero-opt/og-image.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Ice Lake AVX-512 Downclocking</title><link href="https://travisdowns.github.io/blog/2020/08/19/icl-avx512-freq.html" rel="alternate" type="text/html" title="Ice Lake AVX-512 Downclocking" /><published>2020-08-19T00:00:00+00:00</published><updated>2020-08-19T00:00:00+00:00</updated><id>https://travisdowns.github.io/blog/2020/08/19/icl-avx512-freq</id><content type="html" xml:base="https://travisdowns.github.io/blog/2020/08/19/icl-avx512-freq.html">&lt;!-- boilerplate 
page.assets: /assets/icl-avx512-freq
assetpath: /assets/icl-avx512-freq
tablepath: /misc/tables/icl-avx512-freq
--&gt;

&lt;p&gt;This is a short post investigating the behavior of AVX2 and AVX-512 related &lt;em&gt;license-based downclocking&lt;/em&gt; on Intel’s newest Ice Lake and Rocket Lake chips.&lt;/p&gt;

&lt;p&gt;license-based downclocking&lt;sup id=&quot;fnref:tiring&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:tiring&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; refers to the &lt;a href=&quot;https://blog.cloudflare.com/on-the-dangers-of-intels-frequency-scaling/&quot;&gt;semi-famous&lt;/a&gt; effect where lower than nominal frequency limits are imposed when certain &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instructions are executed, especially heavy floating point instructions or 512-bit wide instructions.&lt;/p&gt;

&lt;p&gt;More details about this type of downclocking are available at &lt;a href=&quot;https://stackoverflow.com/a/56861355&quot;&gt;this StackOverflow answer&lt;/a&gt; and we’ve already &lt;a href=&quot;/blog/2020/01/17/avxfreq1.html&quot;&gt;covered in somewhat exhaustive detail&lt;/a&gt; the low level mechanics of these transitions. You can also find &lt;a href=&quot;https://lemire.me/blog/2018/09/07/avx-512-when-and-how-to-use-these-new-instructions/&quot;&gt;some guidelines&lt;/a&gt; on to how make use of wide &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; given this issue&lt;sup id=&quot;fnref:dmore&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:dmore&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;All of those were written in the context of Skylake-SP (&lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt;) which were the first generation of chips to support AVX-512.&lt;/p&gt;

&lt;p&gt;So what about Ice Lake, the newest chips which support both the &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt; flavor of AVX-512 and also have a &lt;a href=&quot;https://branchfree.org/2019/05/29/why-ice-lake-is-important-a-bit-bashers-perspective/&quot;&gt;whole host of new AVX-512 instructions&lt;/a&gt;? Will we be stuck gazing longly at these new instructions from afar while never being allowed to actually use them due to downclocking?&lt;/p&gt;

&lt;p&gt;Read on to find out, or just skip to the &lt;a href=&quot;#summary&quot;&gt;end&lt;/a&gt;. The original version of this post included only Ice Lake is the primary focus. On March 28th, 2020 I updated it with a &lt;a href=&quot;#rocket-lake&quot;&gt;Rocket Lake section&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;ice-lake-frequency-behavior&quot;&gt;Ice Lake Frequency Behavior&lt;/h2&gt;

&lt;h3 id=&quot;avx-turbo&quot;&gt;AVX-Turbo&lt;/h3&gt;

&lt;p&gt;We will use the &lt;a href=&quot;https://github.com/travisdowns/avx-turbo&quot;&gt;avx-turbo&lt;/a&gt; utility to measure the core count and instruction mix dependent frequencies for a CPU. This tools works in a straightforward way: run a given mix of instructions on the given number of cores, while measuring the frequency achieved during the test.&lt;/p&gt;

&lt;p&gt;For example, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;avx256_fma_t&lt;/code&gt; test – which measures the cost of &lt;em&gt;heavy&lt;/em&gt; 256-bit instructions with high &lt;abbr title=&quot;Instruction level parallelism: a measure of inter-instruction parallelism on a superscalar CPU&quot;&gt;ILP&lt;/abbr&gt; – runs the following sequence of FMAs:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;nf&quot;&gt;vfmadd132pd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm11&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;vfmadd132pd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm11&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;vfmadd132pd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm11&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;vfmadd132pd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm11&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;vfmadd132pd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm11&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;vfmadd132pd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm11&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;vfmadd132pd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm11&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;vfmadd132pd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm11&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;vfmadd132pd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm11&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;vfmadd132pd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm11&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;; repeat 10x for a total of 100 FMAs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In total, we’ll use five tests to test every combination of light and heavy 256-bit and 512-bit instructions, as well as scalar instructions (128-bit &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; behaves the same as scalar), using this command line:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./avx-turbo --test=scalar_iadd,avx256_iadd,avx512_iadd,avx256_fma_t,avx512_fma_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;ice-lake-results&quot;&gt;Ice Lake Results&lt;/h3&gt;

&lt;p&gt;I ran avx-turbo as described above on an Ice Lake i5-1035G4, which is the middle-of-the-range Ice Lake client CPU running at up to 3.7 GHz. The full output is &lt;a href=&quot;https://gist.github.com/travisdowns/c53f40fc4dbbd944f5613eaab78f3189#file-icl-turbo-results-txt&quot;&gt;hidden away in a gist&lt;/a&gt;, but here are the all-important frequency results (all values in GHz):&lt;/p&gt;

&lt;table class=&quot;td-right&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;th rowspan=&quot;2&quot;&gt;Instruction Mix&lt;/th&gt;
			&lt;th colspan=&quot;4&quot;&gt;Active Cores&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;1&lt;/th&gt;
			&lt;th&gt;2&lt;/th&gt;
			&lt;th&gt;3&lt;/th&gt;
			&lt;th&gt;4&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;Scalar/128-bit&lt;/th&gt;
			&lt;td&gt;3.7&lt;/td&gt;
			&lt;td&gt;3.6&lt;/td&gt;
			&lt;td&gt;3.3&lt;/td&gt;
			&lt;td&gt;3.3&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;Light 256-bit&lt;/th&gt;
			&lt;td&gt;3.7&lt;/td&gt;
			&lt;td&gt;3.6&lt;/td&gt;
			&lt;td&gt;3.3&lt;/td&gt;
			&lt;td&gt;3.3&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;Heavy 256-bit&lt;/th&gt;
			&lt;td&gt;3.7&lt;/td&gt;
			&lt;td&gt;3.6&lt;/td&gt;
			&lt;td&gt;3.3&lt;/td&gt;
			&lt;td&gt;3.3&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;Light 512-bit&lt;/th&gt;
			&lt;td&gt;3.6&lt;/td&gt;
			&lt;td&gt;3.6&lt;/td&gt;
			&lt;td&gt;3.3&lt;/td&gt;
			&lt;td&gt;3.3&lt;/td&gt;
		&lt;/tr&gt;
    	&lt;tr&gt;
			&lt;th&gt;Heavy 512-bit&lt;/th&gt;
			&lt;td&gt;3.6&lt;/td&gt;
			&lt;td&gt;3.6&lt;/td&gt;
			&lt;td&gt;3.3&lt;/td&gt;
			&lt;td&gt;3.3&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As expected, maximum frequency decreases with active core count, but scan down each column to see the effect of instruction category. Along this axis, there is almost no downclocking at all! Only for a single active core count is there any decrease with wider instructions, and it is a paltry only 100 MHz: from 3,700 MHz to 3,600 MHz when any 512-bit instructions are used.&lt;/p&gt;

&lt;p&gt;In any other scenario, including any time more than one core is active, or for heavy 256-bit instructions, there is &lt;em&gt;zero&lt;/em&gt; license-based downclocking: everything runs as fast as scalar.&lt;/p&gt;

&lt;h4 id=&quot;license-mapping&quot;&gt;license Mapping&lt;/h4&gt;

&lt;p&gt;There another change here too. In &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt;, there are three licenses, or categories of instructions with respect to downclocking: L0, L1 and L2. Here, in client ICL, there are only two&lt;sup id=&quot;fnref:visible&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:visible&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; and those don’t line up exactly with the three in &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt;.&lt;/p&gt;

&lt;p&gt;To be clearer, in &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt; the licenses mapped to instruction width and weight as follows:&lt;/p&gt;

&lt;style&gt;
.l0 {
    background-color: #79fc74;
}
.l1 {
    background-color: #f8ff7a;
}
.l2 {
    background-color: #fa8884;
}
&lt;/style&gt;

&lt;table&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;th&gt;Width&lt;/th&gt;
			&lt;th&gt;Light&lt;/th&gt;
			&lt;th&gt;Heavy&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Scalar/128&lt;/td&gt;
			&lt;td class=&quot;l0&quot;&gt;L0&lt;/td&gt;
			&lt;td class=&quot;l0&quot;&gt;L0&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;256&lt;/td&gt;
			&lt;td class=&quot;l0&quot;&gt;L0&lt;/td&gt;
			&lt;td class=&quot;l1&quot;&gt;L1&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;512&lt;/td&gt;
			&lt;td class=&quot;l1&quot;&gt;L1&lt;/td&gt;
			&lt;td class=&quot;l2&quot;&gt;L2&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In particular, note that 256-bit heavy instructions have the same license as 512-bit light.&lt;/p&gt;

&lt;p&gt;In ICL client, the mapping is:&lt;/p&gt;

&lt;table&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;th&gt;Width&lt;/th&gt;
			&lt;th&gt;Light&lt;/th&gt;
			&lt;th&gt;Heavy&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Scalar/128&lt;/td&gt;
			&lt;td class=&quot;l0&quot;&gt;L0&lt;/td&gt;
			&lt;td class=&quot;l0&quot;&gt;L0&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;256&lt;/td&gt;
			&lt;td class=&quot;l0&quot;&gt;L0&lt;/td&gt;
			&lt;td class=&quot;l0&quot;&gt;L0&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;512&lt;/td&gt;
			&lt;td class=&quot;l1&quot;&gt;L1&lt;/td&gt;
			&lt;td class=&quot;l1&quot;&gt;L1&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Now, 256 heavy and 512 light are in different categories! In fact, the whole concept of light vs heavy doesn’t seem to apply here: the categorization is purely based on the width&lt;sup id=&quot;fnref:onefma&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:onefma&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&quot;rocket-lake&quot;&gt;Rocket Lake&lt;/h2&gt;

&lt;p&gt;Rocket Lake (shortened as &lt;abbr title=&quot;Intel's Rocket Lake architecture, aka 11th Generation Intel Core i3,i5,i7 and i9&quot;&gt;RKL&lt;/abbr&gt;, see &lt;a href=&quot;https://en.wikipedia.org/wiki/Rocket_Lake&quot;&gt;wikipedia&lt;/a&gt; or &lt;a href=&quot;https://en.wikichip.org/wiki/intel/microarchitectures/rocket_lake&quot;&gt;wikichip&lt;/a&gt; for more) is more-or-less a backport of the 10nm &lt;abbr title=&quot;The new 7nm microarchitecture used in Ice Lake CPUs.&quot;&gt;Sunny Cove&lt;/abbr&gt; microarchitecture to Intel’s highly-tuned workhorse&lt;sup id=&quot;fnref:some&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:some&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; 14nm process.&lt;/p&gt;

&lt;p&gt;Edison Chan has graciously provided the output of running avx-turbo on his Rocket Lake i9-11900K, the top of the line Rocket Lake chip. The &lt;a href=&quot;/assets/icl-avx512-freq/11900k-avx-freq-results.txt&quot;&gt;full results&lt;/a&gt; are available, but I’ve summarized the achieved frequencies in the following table.&lt;/p&gt;

&lt;p style=&quot;text-align: center&quot;&gt;&lt;strong&gt;Rocket Lake i9-11900K Frequency Matrix&lt;/strong&gt;&lt;/p&gt;

&lt;table class=&quot;td-right&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;th rowspan=&quot;2&quot;&gt;Active Cores&lt;/th&gt;
			&lt;th colspan=&quot;5&quot; style=&quot;text-align:center&quot;&gt;Instruction Mix&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;Scalar and 128&lt;/th&gt;
			&lt;th&gt;Light 256&lt;/th&gt;
			&lt;th&gt;Heavy 256&lt;/th&gt;
			&lt;th&gt;Light 512&lt;/th&gt;
			&lt;th&gt;Heavy 512&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;1 Core&lt;/th&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;2 Cores&lt;/th&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;3 Cores&lt;/th&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;4 Cores&lt;/th&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
			&lt;td&gt;5.1&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;5 Cores&lt;/th&gt;
			&lt;td&gt;4.9&lt;/td&gt;
			&lt;td&gt;4.9&lt;/td&gt;
			&lt;td&gt;4.9&lt;/td&gt;
			&lt;td&gt;4.9&lt;/td&gt;
			&lt;td&gt;4.9&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;6 Cores&lt;/th&gt;
			&lt;td&gt;4.9&lt;/td&gt;
			&lt;td&gt;4.9&lt;/td&gt;
			&lt;td&gt;4.9&lt;/td&gt;
			&lt;td&gt;4.9&lt;/td&gt;
			&lt;td&gt;4.9&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;7 Cores&lt;/th&gt;
			&lt;td&gt;4.8&lt;/td&gt;
			&lt;td&gt;4.8&lt;/td&gt;
			&lt;td&gt;4.8&lt;/td&gt;
			&lt;td&gt;4.8&lt;/td&gt;
			&lt;td&gt;4.8&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;th&gt;8 Cores&lt;/th&gt;
			&lt;td&gt;4.8&lt;/td&gt;
			&lt;td&gt;4.8&lt;/td&gt;
			&lt;td&gt;4.8&lt;/td&gt;
			&lt;td&gt;4.8&lt;/td&gt;
			&lt;td&gt;4.8&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The results paint a very promising picture of Rocket Lake’s AVX-512 frequency behavior: there is &lt;em&gt;no&lt;/em&gt; license-based downclocking evident at any combination of core count and frequency&lt;sup id=&quot;fnref:rklcaveats&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:rklcaveats&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;. Even heavy AVX-512 instructions can execute at the same frequency as lightweight scalar code.&lt;/p&gt;

&lt;p&gt;In fact, the frequency behavior of this chip appears very simple: the full Turbo Boost 2.0 frequency&lt;sup id=&quot;fnref:tb2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:tb2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt; of 5.1 GHz is available for any instruction mix up and up to 4 active cores, then the speed drops to 4.9 for 5 and 6 active cores, and finally to 4.8 GHz for 7 or 8 active cores. This means that at 8 active cores and AVX-512, you are still achieving 94% of the frequency observed for 1 active core running light instructions.&lt;/p&gt;

&lt;h3 id=&quot;so-what&quot;&gt;So What?&lt;/h3&gt;

&lt;p&gt;Well, so what?&lt;/p&gt;

&lt;p&gt;At least, it means we need to adjust our mental model of the frequency related cost of AVX-512 instructions. Rather than the prior-generation verdict of “AVX-512 generally causes significant downclocking”, on these Ice Lake and Rocket Lake client chips we can say that AVX-512 causes insignificant (usually, none at all) license-based downclocking and I expect this to be true on other ICL and &lt;abbr title=&quot;Intel's Rocket Lake architecture, aka 11th Generation Intel Core i3,i5,i7 and i9&quot;&gt;RKL&lt;/abbr&gt; client chips as well.&lt;/p&gt;

&lt;p&gt;Now, this adjustment of expectations comes with an important caveat: license-based downclocking is only &lt;em&gt;one&lt;/em&gt; source of downclocking. It is also possible to hit power, thermal or current limits. Some configurations may only be able to run wide &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instructions on all cores for a short period of time before exceeding running power limits. In my case, the $250 laptop I’m testing this on has extremely poor cooling and rather than power limits I hit thermal limits (100°C limit) within a few seconds running anything heavy on all cores.&lt;/p&gt;

&lt;p&gt;However, these other limits are qualitatively different than license based limits. They apply mostly&lt;sup id=&quot;fnref:voltage&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:voltage&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt; in a &lt;em&gt;pay for what you use&lt;/em&gt; way: if you use a wide or heavy instruction or two you incur only a microscopic amount of additional power or heat cost associated with only those instructions. This is unlike some license-based transitions where a core or chip-wide transition occurs that affects unrelated subsequent execution for a significant period of time.&lt;/p&gt;

&lt;p&gt;Since wider operations are generally &lt;em&gt;cheaper&lt;/em&gt; in power than an equivalent number of narrower operations&lt;sup id=&quot;fnref:widenarrow&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:widenarrow&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;, you can determine up-front that a wide operation is &lt;em&gt;worth it&lt;/em&gt; – at least for cases that scale well with width. In any case, the problem is most local: not depending on the behavior of the surrounding code.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;Here’s what we’ve learned.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The Ice Lake i5-1035 CPU exhibits only 100 MHz of license-based downclock with 1 active core when running 512-bit instructions, and &lt;em&gt;no&lt;/em&gt; license downclock in any other scenario.&lt;/li&gt;
  &lt;li&gt;The Rocket Lake i9-11900K CPU doesn’t exhibit any license-based downclock in the tested scenarios.&lt;/li&gt;
  &lt;li&gt;The Ice Lake CPU has an all-core 512-bit turbo frequency of 3.3 GHz is 89% of the maximum single-core scalar frequency of 3.7 GHz, so within power and thermal limits this chip has a very “flat” frequency profile. The Rocket Lake 11900K is even flatter with an all-eight-cores frequency of 4.8 GHz clocking in at 94% of the 5.1 GHz single-core speed.&lt;/li&gt;
  &lt;li&gt;Unlike &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt;, this Ice Lake chip does not distinguish between “light” and “heavy” instructions for frequency scaling purposes: FMA operations behave the same as lighter operations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So on ICL and &lt;abbr title=&quot;Intel's Rocket Lake architecture, aka 11th Generation Intel Core i3,i5,i7 and i9&quot;&gt;RKL&lt;/abbr&gt; client, you don’t have to fear the downclock. Only time will tell if this applies also to the Ice Lake Xeon server chips.&lt;/p&gt;

&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;Thanks to Edison Chan for the Rocket Lake i9-11900K results.&lt;/p&gt;

&lt;p&gt;Stopwatch photo by &lt;a href=&quot;https://unsplash.com/@kevinandrephotography&quot;&gt;Kevin Andre&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/stopwatch&quot;&gt;Unsplash&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;discussion-and-feedback&quot;&gt;Discussion and Feedback&lt;/h3&gt;

&lt;p&gt;This post was discussed &lt;a href=&quot;https://news.ycombinator.com/item?id=24215022&quot;&gt;on Hacker News&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you have a question or any type of feedback, you can leave a &lt;a href=&quot;#comment-section&quot;&gt;comment below&lt;/a&gt;. I’m also interested in results on &lt;em&gt;other&lt;/em&gt; new Intel or AMD chips, like the i3 and i7 variants: let me know if you have one of those and we can collect results.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;If you liked this post, check out the &lt;a href=&quot;/&quot;&gt;homepage&lt;/a&gt; for others you might enjoy.&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:tiring&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;It gets tiring to constantly repeat &lt;em&gt;license-based downclock&lt;/em&gt; so I’ll often use simply “downclock” instead, but this should still be understood to refer to the license-based variety rather than other types of frequency throttling. &lt;a href=&quot;#fnref:tiring&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:dmore&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Note that Daniel has &lt;a href=&quot;https://lemire.me/blog/2018/08/25/avx-512-throttling-heavy-instructions-are-maybe-not-so-dangerous/&quot;&gt;written&lt;/a&gt; &lt;a href=&quot;https://lemire.me/blog/2018/08/15/the-dangers-of-avx-512-throttling-a-3-impact/&quot;&gt;much more&lt;/a&gt; &lt;a href=&quot;https://lemire.me/blog/2018/08/24/trying-harder-to-make-avx-512-look-bad-my-quantified-and-reproducible-results/&quot;&gt;than&lt;/a&gt; &lt;a href=&quot;https://lemire.me/blog/2018/09/04/per-core-frequency-scaling-and-avx-512-an-experiment/&quot;&gt;just that&lt;/a&gt; one. &lt;a href=&quot;#fnref:dmore&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:visible&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Only two &lt;em&gt;visible:&lt;/em&gt; it is possible that the three (or more) categories still exist, but they cause voltage transitions only, not any frequency transitions. &lt;a href=&quot;#fnref:visible&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:onefma&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;One might imagine this is a consequence of ICL client having only one FMA unit on all SKUs: very heavy FP 512-bit operations aren’t possible. However, this doesn’t align with 256-bit heavy still being fast: you can still do 2x256-bit FMAs per cycle and this is the same FP intensity as 1x512-bit FMA per cycle. It’s more like, on this chip, FP operation don’t need more license based protection from other operations of the same width, and the main cost is 512-bit width. &lt;a href=&quot;#fnref:onefma&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:some&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Those of a more critical bent might prefer &lt;em&gt;long suffering&lt;/em&gt; or &lt;em&gt;very long in the tooth&lt;/em&gt; as adjectives for this process. &lt;a href=&quot;#fnref:some&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:rklcaveats&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;em&gt;Some&lt;/em&gt; tests did show lower speeds, although these outlier results didn’t correlate well with heavy or light instructions, and the difference was generally 100 MHz or less. These likely represent &lt;em&gt;other&lt;/em&gt; sources of reduced frequency, such as thermal throttling or switching to a higher active core count when a process not related to the test process has active threads. In any case, for &lt;em&gt;each&lt;/em&gt; core count, we can find a test in each of the instruction categories that runs at full speed, allowing me to fill out the matrix even in the presence of these outliers. &lt;a href=&quot;#fnref:rklcaveats&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:tb2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I mention Turbo Boost 2.0 specifically because &lt;a href=&quot;https://ark.intel.com/content/www/us/en/ark/products/212325/intel-core-i9-11900k-processor-16m-cache-up-to-5-30-ghz.html&quot;&gt;this chip&lt;/a&gt; also has a higher Turbo Boost 3.0 maximum frequency of 5.2 GHz, and beyond that a high &lt;em&gt;Thermal Velocity Boost&lt;/em&gt; frequency of 5.3 GHz. These higher frequencies apply only to specific &lt;em&gt;chosen cores&lt;/em&gt; within the CPU selected at manufacturing based on their ability to reach these higher frequencies. We don’t see any of these higher speeds during the test, possibly because the cores the test pins itself to are not the &lt;em&gt;chosen cores&lt;/em&gt; on this CPU. So the frequency behavior of this chip can be characterized as “very simple” only if you ignore these additional turbo levels and other complicating factors. &lt;a href=&quot;#fnref:tb2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:voltage&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I have to weasel-word with &lt;em&gt;mostly&lt;/em&gt; here because even if there is no frequency transition, there may be a voltage transition which both incurs a halted period where nothing executes, and increases power for subsequent execution that may not require the elevated voltage. Also, there is the not-yet-discussed concept of &lt;em&gt;implicit widening&lt;/em&gt; which may extend later narrow operations to maximum width if the upper parts of the registers are not zeroed with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vzeroupper&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vzeroall&lt;/code&gt;. &lt;a href=&quot;#fnref:voltage&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:widenarrow&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;For example, one 512-bit integer addition would generally be cheaper in energy use than the two 256-bit operations required to calculate the same result, because of execution overheads that don’t scale linearly with width (that’s almost everything outside of execution itself). &lt;a href=&quot;#fnref:widenarrow&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Travis Downs</name><email>travis.downs@gmail.com</email></author><category term="blog" /><category term="performance" /><category term="x86" /><category term="icelake" /><category term="avx512" /><summary type="html">Examining the extent of AVX related downclocking on Intel's Ice Lake CPU</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://travisdowns.github.io/assets/icl-avx512-freq/og-image.jpg" /><media:content medium="image" url="https://travisdowns.github.io/assets/icl-avx512-freq/og-image.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">A Concurrency Cost Hierarchy</title><link href="https://travisdowns.github.io/blog/2020/07/06/concurrency-costs.html" rel="alternate" type="text/html" title="A Concurrency Cost Hierarchy" /><published>2020-07-06T00:00:00+00:00</published><updated>2020-07-06T00:00:00+00:00</updated><id>https://travisdowns.github.io/blog/2020/07/06/concurrency-costs</id><content type="html" xml:base="https://travisdowns.github.io/blog/2020/07/06/concurrency-costs.html">&lt;!-- boilerplate 
page.assets: /assets/concurrency-costs
assetpath: /assets/concurrency-costs
tablepath: /misc/tables/concurrency-costs
--&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Concurrency is hard to get &lt;em&gt;correct&lt;/em&gt;, at least for those of us unlucky enough to be writing in languages which expose directly the guts of concurrent hardware: threads and shared memory. Getting concurrency correct &lt;em&gt;and&lt;/em&gt; fast is hard, too. Your knowledge about single-threaded optimization often won’t help you: at a micro (instruction) level we can’t simply apply the usual rules of μops, dependency chains, throughput limits, and so on. The rules are different.&lt;/p&gt;

&lt;p&gt;If that first paragraph got your hopes up, this second one is here to dash them: I’m not actually going to do a deep dive into the very low level aspects of concurrent performance. There are a lot of things we just don’t know about how atomic instructions and fences execute, and we’ll save that for another day.&lt;/p&gt;

&lt;p&gt;Instead, I’m going to describe a higher level taxonomy that I use to think about concurrent performance. We’ll group the performance of concurrent operations into six broad &lt;em&gt;levels&lt;/em&gt; running from fast to slow, with each level differing from its neighbors by roughly an order of magnitude in performance.&lt;/p&gt;

&lt;p&gt;I often find myself thinking in terms of these categories when I need high performance concurrency: what is the best level I can practically achieve for the given problem? Keeping the levels in mind is useful both during initial design (sometimes a small change in requirements or high level design can allow you to achieve a better level), and also while evaluating existing systems (to better understand existing performance and evaluate the path of least resistance to improvements).&lt;/p&gt;

&lt;h3 id=&quot;a-real-world-example&quot;&gt;A “Real World” Example&lt;/h3&gt;

&lt;p&gt;I don’t want this to be totally abstract, so we will use a real-world-if-you-squint&lt;sup id=&quot;fnref:realworld&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:realworld&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; running example throughout: safely incrementing an integer counter across threads. By &lt;em&gt;safely&lt;/em&gt; I mean without losing increments, producing out-of-thin air values, frying your RAM or making more than a minor rip in space-time.&lt;/p&gt;

&lt;h3 id=&quot;source-and-results&quot;&gt;Source and Results&lt;/h3&gt;

&lt;p&gt;The source for every benchmark here is &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench&quot;&gt;available&lt;/a&gt;, so you can follow along and even reproduce the results or run the benchmarks on your own hardware. All of the results discussed here (and more) are available in the same repository, and each plot includes a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[data table]&lt;/code&gt; link to the specific subset used to generate the plot.&lt;/p&gt;

&lt;h3 id=&quot;hardware&quot;&gt;Hardware&lt;/h3&gt;

&lt;p&gt;All of the performance results are provided for several different hardware platforms: Intel Skylake, Ice Lake, Amazon Graviton and Graviton 2. However except when I explicitly mention other hardware, the prose refers to the results on Skylake. Although the specific numbers vary, most of the qualitative relationships hold for the hardware too, but &lt;em&gt;not always&lt;/em&gt;. Not only does the hardware vary, but the OS and library implementations will vary as well.&lt;/p&gt;

&lt;p&gt;It’s almost inevitable that this will be used to compare across hardware (“wow, Graviton 2 sure kicks Graviton 1’s ass”), but that’s not my goal here. The benchmarks are written primarily to tease apart the characteristics of the different levels, and &lt;em&gt;not&lt;/em&gt; as a hardware shootout.&lt;/p&gt;

&lt;p&gt;Find below the details of the hardware used:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Micro-architecture&lt;/th&gt;
      &lt;th&gt;ISA&lt;/th&gt;
      &lt;th&gt;Model&lt;/th&gt;
      &lt;th&gt;Tested Frequency&lt;/th&gt;
      &lt;th&gt;Cores&lt;/th&gt;
      &lt;th&gt;OS&lt;/th&gt;
      &lt;th&gt;Instance Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Skylake&lt;/td&gt;
      &lt;td&gt;x86&lt;/td&gt;
      &lt;td&gt;i7-6700HQ&lt;/td&gt;
      &lt;td&gt;2.6 GHz&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Ubuntu 20.04&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ice Lake&lt;/td&gt;
      &lt;td&gt;x86&lt;/td&gt;
      &lt;td&gt;i5-1035G4&lt;/td&gt;
      &lt;td&gt;3.3 GHz&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Ubuntu 19.10&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Graviton&lt;/td&gt;
      &lt;td&gt;AArch64&lt;/td&gt;
      &lt;td&gt;Cortex-A72&lt;/td&gt;
      &lt;td&gt;2.3 GHz&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;Ubuntu 20.04&lt;/td&gt;
      &lt;td&gt;a1.4xlarge&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Graviton 2&lt;/td&gt;
      &lt;td&gt;AArch64&lt;/td&gt;
      &lt;td&gt;Neoverse N1&lt;/td&gt;
      &lt;td&gt;2.5 GHz&lt;/td&gt;
      &lt;td&gt;16&lt;sup id=&quot;fnref:g2cores&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:g2cores&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
      &lt;td&gt;Ubuntu 20.04&lt;/td&gt;
      &lt;td&gt;c6g.4xlarge&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;level-2-contended-atomics&quot;&gt;Level 2: Contended Atomics&lt;/h2&gt;

&lt;p&gt;You’d probably expect this hierarchy to be introduced from fast to slow, or vice-versa, but we’re all about defying expectations here and we are going to start in the &lt;em&gt;middle&lt;/em&gt; and work our way outwards. The middle (rounding down) turns out to be &lt;em&gt;level 2&lt;/em&gt; and that’s where we will jump in.&lt;/p&gt;

&lt;p&gt;The most elementary way to safely modify any shared object is to use a lock. It mostly &lt;em&gt;just works&lt;/em&gt; for any type of object, no matter its structure or the nature of the modifications. Almost any mainstream CPU from the last thirty years has some type of locking&lt;sup id=&quot;fnref:parisc&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:parisc&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; instruction accessible to userspace.&lt;/p&gt;

&lt;p&gt;So our baseline increment implementation will use a simple mutex of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; to protect a plain integer variable:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bench&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_guard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;holder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We’ll call this implementation &lt;em&gt;&lt;abbr title=&quot;Uses a std::mutex and std::lock_guard to protect a plain integer counter.&quot;&gt;mutex add&lt;/abbr&gt;&lt;/em&gt;, and on my 4 CPU Skylake-S i7-6700HQ machine, when I use the vanilla &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; I get the following results for 2 to 4 threads:&lt;/p&gt;

&lt;div class=&quot;tabs&quot;&gt;
    &lt;!-- Courtesy of https://codepen.io/Merri/pen/bytea --&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-mutex-1&quot; name=&quot;tab-group-mutex&quot; checked=&quot;&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-mutex-1&quot;&gt;Skylake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/mutex.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/skl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/mutex.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/skl/mutex.svg&quot; alt=&quot;Mutex&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-mutex-2&quot; name=&quot;tab-group-mutex&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-mutex-2&quot;&gt;Ice Lake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/mutex.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/icl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/mutex.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/icl/mutex.svg&quot; alt=&quot;Mutex&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-mutex-3&quot; name=&quot;tab-group-mutex&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-mutex-3&quot;&gt;Graviton&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/mutex.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g1-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/mutex.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g1-16/mutex.svg&quot; alt=&quot;Mutex&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-mutex-4&quot; name=&quot;tab-group-mutex&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-mutex-4&quot;&gt;Graviton 2&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/mutex.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g2-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/mutex.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g2-16/mutex.svg&quot; alt=&quot;Mutex&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;The reported value is the median of all trials, and the vertical black error lines at the top of each bar indicate the &lt;em&gt;interdecile range&lt;/em&gt;, i.e., the values at the 10th and 90th percentile. Where the error bars don’t show up, it means there is no difference between the p10 and p90 values at all, at least within the limits of the reporting resolution (100 picoseconds).&lt;/p&gt;

&lt;p&gt;This shows that the baseline contended cost to modify an integer protected by a lock starts at about 125 nanoseconds for two threads, and grows somewhat with increasing thread count.&lt;/p&gt;

&lt;p&gt;I can already hear someone saying: &lt;em&gt;If you are just modifying a single 64-bit integer, skip the lock and just directly use the atomic operations that most ISAs support!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Sure, let’s add a couple of variants that do that. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; template makes this easy: we can wrap any type meeting some basic requirements and then manipulate it atomically. The easiest of all is to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::atomic&amp;lt;uint64&amp;gt;::operator++()&lt;/code&gt;&lt;sup id=&quot;fnref:post&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:post&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; and this gives us &lt;em&gt;&lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt;&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atomic_counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;atomic_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;atomic_counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The other common approach would be to use &lt;a href=&quot;https://en.wikipedia.org/wiki/Compare-and-swap&quot;&gt;compare and swap (&lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt;)&lt;/a&gt; to load the existing value, add one and then &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt; it back if it hasn’t changed. If it &lt;em&gt;has&lt;/em&gt; changed, the increment raced with another thread and we try again.&lt;/p&gt;

&lt;p&gt;Note that even if you use increment at the source level, the assembly might actually end up using &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt; if your hardware doesn’t support atomic increment&lt;sup id=&quot;fnref:atomicsup&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:atomicsup&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;, or if your compiler or runtime just don’t take advantage of atomic operations even though they are available (e.g., see what even the newest version of &lt;a href=&quot;https://godbolt.org/z/5h4K7y&quot;&gt;icc does&lt;/a&gt; for atomic increment, and what Java did for years&lt;sup id=&quot;fnref:java&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:java&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;). This caveat doesn’t apply to any of our tested platforms, however.&lt;/p&gt;

&lt;p&gt;Let’s add a counter implementation that uses &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt; as described above, and we’ll call it &lt;em&gt;&lt;abbr title=&quot;Uses a CAS loop to increment a single shared counter.&quot;&gt;cas add&lt;/abbr&gt;&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cas_counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cas_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cas_counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cas_counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here’s what these look like alongside our existing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; benchmark:&lt;/p&gt;

&lt;div class=&quot;tabs&quot;&gt;
    &lt;!-- Courtesy of https://codepen.io/Merri/pen/bytea --&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-atomic-inc-1&quot; name=&quot;tab-group-atomic-inc&quot; checked=&quot;&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-atomic-inc-1&quot;&gt;Skylake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/atomic-inc.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/skl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/atomic-inc.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/skl/atomic-inc.svg&quot; alt=&quot;Atomic increment&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-atomic-inc-2&quot; name=&quot;tab-group-atomic-inc&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-atomic-inc-2&quot;&gt;Ice Lake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/atomic-inc.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/icl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/atomic-inc.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/icl/atomic-inc.svg&quot; alt=&quot;Atomic increment&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-atomic-inc-3&quot; name=&quot;tab-group-atomic-inc&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-atomic-inc-3&quot;&gt;Graviton&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/atomic-inc.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g1-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/atomic-inc.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g1-16/atomic-inc.svg&quot; alt=&quot;Atomic increment&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-atomic-inc-4&quot; name=&quot;tab-group-atomic-inc&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-atomic-inc-4&quot;&gt;Graviton 2&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/atomic-inc.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g2-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/atomic-inc.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g2-16/atomic-inc.svg&quot; alt=&quot;Atomic increment&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;p&gt;The first takeaway is that, at least in this &lt;em&gt;unrealistic maximum contention&lt;/em&gt; benchmark, using &lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt; (&lt;a href=&quot;https://www.felixcloutier.com/x86/xadd&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock xadd&lt;/code&gt;&lt;/a&gt; at the hardware level) is significantly better than &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt;. The second would be that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; doesn’t come out looking all that bad on Skylake. It is only slightly worse than the &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt; approach at 2 cores and beats it at 3 and 4 cores. It is slower than the atomic increment approach, but less than three times as slow and seems to be scaling in a reasonable way.&lt;/p&gt;

&lt;p&gt;All of these operations are belong to &lt;em&gt;level 2&lt;/em&gt; in the hierarchy. The primary characteristic of level 2 is that they make a &lt;em&gt;contended access&lt;/em&gt; to a shared variable. This means that at a minimum, the line containing the data needs to move out to the caching agent that manages coherency&lt;sup id=&quot;fnref:l3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:l3&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;, and then back up to the core that will receive ownership next. That’s about 70 cycles minimum just for that operation&lt;sup id=&quot;fnref:inter&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:inter&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Can it get slower? You bet it can. &lt;em&gt;Way&lt;/em&gt; slower.&lt;/p&gt;

&lt;h3 id=&quot;level-3-system-calls&quot;&gt;Level 3: System Calls&lt;/h3&gt;

&lt;p&gt;The next level up (“up” is not good here…) is level 3. The key characteristic of implementations at this level is that they make a &lt;em&gt;system call on almost every operation&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It is easy to write concurrency primitives that make a system call &lt;em&gt;unconditionally&lt;/em&gt; (e.g., a lock which always tries to wake waiters via a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;futex(2)&lt;/code&gt; call, even if there aren’t any), but we won’t look at those here. Rather we’ll take a look at a case where the fast path is written to avoid a system call, but the design or way it is used implies that such a call usually happens anyway.&lt;/p&gt;

&lt;p&gt;Specifically, we are going to look at some &lt;em&gt;fair locks&lt;/em&gt;. Fair locks allow threads into the critical section in the same order they began waiting. That is, when the critical section becomes available, the thread that has been waiting the longest is given the chance to take it.&lt;/p&gt;

&lt;p&gt;Sounds like a good idea, right? Sometimes yes, but as we will see it can have significant performance implications.&lt;/p&gt;

&lt;p&gt;On the menu are three different fair locks.&lt;/p&gt;

&lt;p&gt;The first is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Ticket_lock&quot;&gt;ticket lock&lt;/a&gt; with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_yield&lt;/code&gt; in the spin loop. The idea of the yield is to give other threads which may hold the lock time to run. This &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield()&lt;/code&gt; approach is publicly frowned upon by concurrency experts&lt;sup id=&quot;fnref:notwhat&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:notwhat&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;, who then sometimes go right ahead and use it anyway.&lt;/p&gt;

&lt;p&gt;We will call it &lt;abbr title=&quot;A ticket lock that calls sched_yield in a spin loop while waiting for its turn.&quot;&gt;ticket yield&lt;/abbr&gt; and it looks like this:&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;ys-lock&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * A ticket lock which uses sched_yield() while waiting
 * for the ticket to be served.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ticket_yield&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispenser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ticket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispenser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ticket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;sched_yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;serving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s plot the performance results for this lock alongside the existing approaches:&lt;/p&gt;

&lt;div class=&quot;tabs&quot;&gt;
    &lt;!-- Courtesy of https://codepen.io/Merri/pen/bytea --&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-fair-yield-1&quot; name=&quot;tab-group-fair-yield&quot; checked=&quot;&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-fair-yield-1&quot;&gt;Skylake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/fair-yield.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/skl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/fair-yield.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/skl/fair-yield.svg&quot; alt=&quot;Increment Cost: Fair Yield&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-fair-yield-2&quot; name=&quot;tab-group-fair-yield&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-fair-yield-2&quot;&gt;Ice Lake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/fair-yield.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/icl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/fair-yield.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/icl/fair-yield.svg&quot; alt=&quot;Increment Cost: Fair Yield&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-fair-yield-3&quot; name=&quot;tab-group-fair-yield&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-fair-yield-3&quot;&gt;Graviton&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/fair-yield.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g1-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/fair-yield.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g1-16/fair-yield.svg&quot; alt=&quot;Increment Cost: Fair Yield&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-fair-yield-4&quot; name=&quot;tab-group-fair-yield&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-fair-yield-4&quot;&gt;Graviton 2&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/fair-yield.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g2-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/fair-yield.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g2-16/fair-yield.svg&quot; alt=&quot;Increment Cost: Fair Yield&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;p&gt;This is level 3 visualized: it is an order of magnitude slower than the level 2 approaches. The slowdown comes from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_yield&lt;/code&gt; call: this is a system call and these are generally on the order of 100s of nanoseconds&lt;sup id=&quot;fnref:spectre&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:spectre&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;, and it shows in the results.&lt;/p&gt;

&lt;p&gt;This lock &lt;em&gt;does&lt;/em&gt; have a fast path where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_yield&lt;/code&gt; isn’t called: if the lock is available, no spinning occurs and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_yield&lt;/code&gt; is never called. However, the combination of being a &lt;em&gt;fair&lt;/em&gt; lock and the high contention in this test means that a lock convoy quickly forms (we’ll describe this in more detail later) and so the spin loop is entered basically every time &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock()&lt;/code&gt; is called.&lt;/p&gt;

&lt;p&gt;So have we &lt;em&gt;now&lt;/em&gt; fully plumbed the depths of slow concurrency constructs? Not even close. We are only now just about to cross the River Styx.&lt;/p&gt;

&lt;h4 id=&quot;revisiting-stdmutex&quot;&gt;Revisiting std::mutex&lt;/h4&gt;

&lt;p&gt;Before we proceed, let’s quickly revisit the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; implementation discussed in level 2 in light of our definition of level 3 as requiring a system call. Doesn’t &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; &lt;em&gt;also&lt;/em&gt; make system calls? If a thread tries to lock a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; object which is already locked, we expect that thread to block using OS-provided primitives. So why isn’t it level 3 and slow like &lt;abbr title=&quot;A ticket lock that calls sched_yield in a spin loop while waiting for its turn.&quot;&gt;ticket yield&lt;/abbr&gt;?&lt;/p&gt;

&lt;p&gt;The primary reason is that it makes &lt;em&gt;few&lt;/em&gt; system calls in practice. Through a combination of spinning and unfairness I measure only about 0.18 system calls per increment, with three threads on my Skylake box. So &lt;em&gt;most&lt;/em&gt; increments happen without a system call. On the other hand, &lt;abbr title=&quot;A ticket lock that calls sched_yield in a spin loop while waiting for its turn.&quot;&gt;ticket yield&lt;/abbr&gt; makes about 2.4 system calls per increment, more than an order of magnitude more, and so it suffers a corresponding decrease in performance.&lt;/p&gt;

&lt;p&gt;That out of way, let’s get even slower.&lt;/p&gt;

&lt;h3 id=&quot;level-4-implied-context-switch&quot;&gt;Level 4: Implied Context Switch&lt;/h3&gt;

&lt;p&gt;The next level is when the implementation forces a significant number of concurrent operations to cause a &lt;em&gt;context switch&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The yielding lock wasn’t resulting in many context switches, since we are not running more threads than there are cores, and so there usually is no other runnable process (except for the occasional background process). Therefore, the current thread stays on the CPU when we call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_yield&lt;/code&gt;. Of course, this burns a lot of CPU.&lt;/p&gt;

&lt;p&gt;As the experts recommend whenever one suggests &lt;em&gt;yielding&lt;/em&gt; in a spin loop, let us try a &lt;em&gt;blocking lock&lt;/em&gt; instead.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;&lt;strong&gt;Blocking Locks&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
A more resource friendly design, and one that will often perform better is a &lt;em&gt;blocking&lt;/em&gt; lock.&lt;br /&gt;&lt;br /&gt;Rather than busy waiting, these locks ask the OS to put the current thread to sleep until the lock becomes available. On Linux, the &lt;a href=&quot;http://man7.org/linux/man-pages/man2/futex.2.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;futex(3)&lt;/code&gt;&lt;/a&gt; system call is the preferred way to accomplish this, while on Windows you have the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WaitFor*Object&lt;/code&gt;&lt;/a&gt; API family. Above the OS interfaces, things like C++’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::condition_variable&lt;/code&gt; provide a general purpose mechanism to wait until an arbitrary condition is true.&lt;/p&gt;

&lt;p&gt;Our first blocking lock is again a ticket-based design, except this time it uses a condition variable to block when it detects that it isn’t first in line to be served (i.e., that the lock was held by another thread). We’ll name it &lt;abbr title=&quot;A ticket lock which blocks if it cannot immediately acquire the lock.&quot;&gt;ticket blocking&lt;/abbr&gt; and it looks like this:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blocking_ticket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ticket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispenser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ticket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// uncontended case&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ticket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cvar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blocking_ticket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;serving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispenser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// wake all waiters&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cvar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notify_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The main difference with the earlier implementation occurs in the case where we don’t acquire the lock immediately (we don’t return at the location marked &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;// uncontended case&lt;/code&gt;). Instead of yielding in a loop, we take the mutex associated with the condition variable and wait until notified. Every time we are notified we check if it is our turn.&lt;/p&gt;

&lt;p&gt;Even without &lt;abbr title=&quot;When a waiter on a condition variable is woken up even though no other thread notified it.&quot;&gt;spurious wakeups&lt;/abbr&gt; we might get woken many times, because this lock suffers from the &lt;em&gt;thundering herd&lt;/em&gt; problem where every waiter is woken on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unlock()&lt;/code&gt; even though only one will ultimately be able to get the lock.&lt;/p&gt;

&lt;p&gt;We’ll try a second design too, that doesn’t suffer from thundering herd. This is a queued lock, where each lock waits on its own private node in a queue of waiters, so only a single waiter (the new lock owner) is woken up on unlock. We will call it &lt;abbr title=&quot;A blocking ticket lock where each waiter waits on a unique condition variable.&quot;&gt;queued fifo&lt;/abbr&gt; and if you’re interested in the implementation you can find it &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/blob/9b8e0e0dfec7d38036d114038c6a9ed020b5b775/fairlocks.cpp#L61&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here’s how our new locks perform against the existing crowd:&lt;/p&gt;

&lt;div class=&quot;tabs&quot;&gt;
    &lt;!-- Courtesy of https://codepen.io/Merri/pen/bytea --&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-more-fair-1&quot; name=&quot;tab-group-more-fair&quot; checked=&quot;&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-more-fair-1&quot;&gt;Skylake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/more-fair.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/skl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/more-fair.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/skl/more-fair.svg&quot; alt=&quot;Increment Cost: Fair Blocking&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-more-fair-2&quot; name=&quot;tab-group-more-fair&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-more-fair-2&quot;&gt;Ice Lake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/more-fair.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/icl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/more-fair.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/icl/more-fair.svg&quot; alt=&quot;Increment Cost: Fair Blocking&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-more-fair-3&quot; name=&quot;tab-group-more-fair&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-more-fair-3&quot;&gt;Graviton&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/more-fair.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g1-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/more-fair.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g1-16/more-fair.svg&quot; alt=&quot;Increment Cost: Fair Blocking&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-more-fair-4&quot; name=&quot;tab-group-more-fair&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-more-fair-4&quot;&gt;Graviton 2&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/more-fair.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g2-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/more-fair.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g2-16/more-fair.svg&quot; alt=&quot;Increment Cost: Fair Blocking&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;p&gt;You’re probably seeing the pattern now: performance is again a new level of terrible compared to the previous contenders. About an order of magnitude slower than the yielding approach, which was already slower than the earlier approaches, which are now just slivers a few pixels high on the plots. The queued version of the lock does slightly better at increasing thread counts (&lt;em&gt;especially&lt;/em&gt; on Graviton 2), as might be expected from the lack of the thundering herd effect, but is still very slow because the primary problem isn’t thundering herd, but rather a &lt;a href=&quot;https://en.wikipedia.org/wiki/Lock_convoy&quot;&gt;&lt;em&gt;lock convoy&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;&lt;strong&gt;Lock Convoy&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
Unlike unfair locks, fair locks can result in sustained convoys involving only a single lock, once the contention reaches a certain point&lt;sup id=&quot;fnref:hyst&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:hyst&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;.&lt;br /&gt;
&lt;br /&gt;
Consider what happens when two threads, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;, try to acquire the lock repeatedly. Let’s say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; gets ticket 1 and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; ticket 2. So &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; gets to go first and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; has to wait, and for these implementations that means blocking (we can say the thread is &lt;em&gt;parked&lt;/em&gt; by the OS). Now, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; unlocks the lock and sees &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; waiting and wakes it. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; is still running and soon tries to get the lock again, receiving ticket 3, but it cannot acquire the lock immediately because the lock is &lt;em&gt;fair&lt;/em&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; can’t jump the queue and acquire the lock with ticket 3 before &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;, holding ticket 2, gets its chance to enter the lock.&lt;br /&gt;
&lt;br /&gt;
Of course, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; is going to be a while: it needs to be woken by the scheduler and this takes a microsecond or two, at least. Now &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; wakes and gets the lock, and the same scenario repeats itself with the roles reversed. The upshot is that there is a full context switch for each acquisition of the lock.&lt;br /&gt;
&lt;br /&gt;
Unfair locks avoid this problem because they allow queue jumping: in the scenario above, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; (or any other thread) could re-acquire the lock after unlocking it, before &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; got its chance. So the use of the shared resource doesn’t grind to a halt while &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; wakes up.&lt;/p&gt;

&lt;p&gt;So, are you tired of seeing mostly-white plots where the newly introduced algorithm relegates the rest of the pack to little chunks of color near the x-axis, yet?&lt;/p&gt;

&lt;p&gt;I’ve just got one more left on the slow end of the scale. Unlike the other examples, I haven’t actually diagnosed something &lt;em&gt;this&lt;/em&gt; bad in real life, but examples are out there.&lt;/p&gt;

&lt;h3 id=&quot;level-5-catastrophe&quot;&gt;Level 5: Catastrophe&lt;/h3&gt;

&lt;p&gt;Here’s a ticket lock which is identical to the &lt;a href=&quot;#ys-lock&quot;&gt;first ticket lock we saw&lt;/a&gt;, except that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_yield();&lt;/code&gt; is replaced by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;;&lt;/code&gt;. That is, it busy waits instead of yielding (look &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/blob/9b8e0e0dfec7d38036d114038c6a9ed020b5b775/fairlocks.cpp#L31&quot;&gt;here&lt;/a&gt; for the spin flavors which specialize on a shared ticket lock template). You could also replace this by a CPU-specific “relax” instruction like &lt;a href=&quot;https://www.felixcloutier.com/x86/pause&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pause&lt;/code&gt;&lt;/a&gt;, but it won’t change the outcome (see &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/blob/9b8e0e0dfec7d38036d114038c6a9ed020b5b775/fairlocks.hpp#L26&quot;&gt;here&lt;/a&gt;). We call it &lt;abbr title=&quot;A traditional spin-based ticket lock that does a hot spin while waiting for its ticket to be next.&quot;&gt;ticket spin&lt;/abbr&gt;, and here’s how it performs compared to the existing candidates:&lt;/p&gt;

&lt;div class=&quot;tabs&quot;&gt;
    &lt;!-- Courtesy of https://codepen.io/Merri/pen/bytea --&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-ts-4-1&quot; name=&quot;tab-group-ts-4&quot; checked=&quot;&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-ts-4-1&quot;&gt;Skylake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/ts-4.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/skl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/ts-4.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/skl/ts-4.svg&quot; alt=&quot;Increment Cost: Ticket Spin&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-ts-4-2&quot; name=&quot;tab-group-ts-4&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-ts-4-2&quot;&gt;Ice Lake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/ts-4.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/icl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/ts-4.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/icl/ts-4.svg&quot; alt=&quot;Increment Cost: Ticket Spin&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-ts-4-3&quot; name=&quot;tab-group-ts-4&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-ts-4-3&quot;&gt;Graviton&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/ts-4.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g1-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/ts-4.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g1-16/ts-4.svg&quot; alt=&quot;Increment Cost: Ticket Spin&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-ts-4-4&quot; name=&quot;tab-group-ts-4&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-ts-4-4&quot;&gt;Graviton 2&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/ts-4.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g2-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/ts-4.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g2-16/ts-4.svg&quot; alt=&quot;Increment Cost: Ticket Spin&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;p&gt;What? That doesn’t look too bad at all. In fact, it is only slightly worse than the level 2 crew, the fastest we’ve seen so far&lt;sup id=&quot;fnref:huh&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:huh&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;The picture changes if we show the results for up to 6 threads, rather than just 4. Since I have 4 available cores&lt;sup id=&quot;fnref:noht&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:noht&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;13&lt;/a&gt;&lt;/sup&gt;, this means that not all the test threads will be able to run at once:&lt;/p&gt;

&lt;div class=&quot;tabs&quot;&gt;
    &lt;!-- Courtesy of https://codepen.io/Merri/pen/bytea --&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-ts-6-1&quot; name=&quot;tab-group-ts-6&quot; checked=&quot;&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-ts-6-1&quot;&gt;Skylake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/ts-6.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/skl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/ts-6.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/skl/ts-6.svg&quot; alt=&quot;Increment Cost: Ticket Spin (Oversubscribed)&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-ts-6-2&quot; name=&quot;tab-group-ts-6&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-ts-6-2&quot;&gt;Ice Lake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/ts-6.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/icl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/ts-6.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/icl/ts-6.svg&quot; alt=&quot;Increment Cost: Ticket Spin (Oversubscribed)&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-ts-6-3&quot; name=&quot;tab-group-ts-6&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-ts-6-3&quot;&gt;Graviton&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/ts-6.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g1-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/ts-6.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g1-16/ts-6.svg&quot; alt=&quot;Increment Cost: Ticket Spin (Oversubscribed)&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-ts-6-4&quot; name=&quot;tab-group-ts-6&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-ts-6-4&quot;&gt;Graviton 2&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/ts-6.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g2-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/ts-6.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g2-16/ts-6.svg&quot; alt=&quot;Increment Cost: Ticket Spin (Oversubscribed)&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;p&gt;Now it becomes clear why this level is called &lt;em&gt;catastrophic&lt;/em&gt;. As soon as we oversubscribe the number of available cores, performance gets about &lt;em&gt;five hundred times worse&lt;/em&gt;. We go from 100s of nanoseconds to 100s of microseconds. I don’t show more threads, but it only gets worse as you add more.&lt;/p&gt;

&lt;p&gt;We are also about an order of magnitude slower than the best solution (&lt;abbr title=&quot;A blocking ticket lock where each waiter waits on a unique condition variable.&quot;&gt;queued fifo&lt;/abbr&gt;) of the previous level, although it varies a lot by hardware: on Ice Lake the difference is more like &lt;em&gt;forty&lt;/em&gt; times, while on Graviton this solution is actually slightly faster than &lt;abbr title=&quot;A ticket lock which blocks if it cannot immediately acquire the lock.&quot;&gt;ticket blocking&lt;/abbr&gt; (also level 4) at 17 threads. Note also the huge error bars. This is the least consistent benchmark of the bunch and exhibits a lot of variance and the slowest and fastest runs might vary by a factor of 100.&lt;/p&gt;

&lt;h4 id=&quot;lock-convoy-on-steroids&quot;&gt;Lock Convoy on Steroids&lt;/h4&gt;

&lt;p&gt;So what happens here?&lt;/p&gt;

&lt;p&gt;It’s similar to the lock convoy described above: all the threads queue on the lock and acquire it in a round-robin order due to the fair design. The difference is that threads don’t block when they can’t acquire the lock. This works out great when the cores are not oversubscribed, but falls off a cliff otherwise.&lt;/p&gt;

&lt;p&gt;Imagine 5 threads, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T2&lt;/code&gt;, …, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T5&lt;/code&gt;, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T5&lt;/code&gt; is the one not currently running. As soon as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T5&lt;/code&gt; is the thread that needs the acquire the lock next (i.e., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T5&lt;/code&gt;’s saved ticket value is equal to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispensing&lt;/code&gt;), nothing will happen because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T1&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T4&lt;/code&gt; are busily spinning away waiting for their turn. The OS scheduler sees no reason to interrupt them until their time slice expires. Time slices are usually measured in milliseconds. Once one thread is preempted, say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T5&lt;/code&gt; will get the chance to run, but at most 4 total acquisitions can happen (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T5&lt;/code&gt;, plus any of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T3&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T4&lt;/code&gt;), before it’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T1&lt;/code&gt;’s turn. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T1&lt;/code&gt; is waiting for their chance to run again, but since everyone is spinning this won’t occur until another time slice expires.&lt;/p&gt;

&lt;p&gt;So the lock can only be acquired a few times (at most &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$(nproc)&lt;/code&gt; times), or as little as once&lt;sup id=&quot;fnref:once&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:once&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;14&lt;/a&gt;&lt;/sup&gt;, every time slice. Modern Linux using &lt;a href=&quot;https://en.wikipedia.org/wiki/Completely_Fair_Scheduler&quot;&gt;CFS&lt;/a&gt; doesn’t have a fixed timeslice, but on my system, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_latency_ns&lt;/code&gt; is 18,000,000 which means that we expect two threads competing for one core to get a typical timeslice of 9 ms. The measured numbers are roughly consistent with a timeslice of single-digit milliseconds.&lt;/p&gt;

&lt;p&gt;If I was good at diagrams, there would be a diagram here.&lt;/p&gt;

&lt;p&gt;Another way of thinking about this is that in this over-subscription scenario, the &lt;abbr title=&quot;A traditional spin-based ticket lock that does a hot spin while waiting for its ticket to be next.&quot;&gt;ticket spin&lt;/abbr&gt; lock implies roughly the same number of context switches as the blocking ticket lock&lt;sup id=&quot;fnref:perf&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:perf&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;15&lt;/a&gt;&lt;/sup&gt;, but in the former case each context switch comes with a giant delay caused by the need to exhaust the timeslice, while in the blocking case we are only limited by how fast a context switch can occur.&lt;/p&gt;

&lt;p&gt;Interestingly, although this benchmark uses 100% CPU on every core, the performance of the benchmark in the oversubscribed case almost doesn’t depend on your CPU speed! Performance is approximately the same if I throttle my CPU to 1 GHz, or enable turbo up to 3.5 GHz. All of other implementations scale almost proportionally with CPU frequency. The benchmark does scale strongly with adjustment to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_latency_ns&lt;/code&gt; (and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_min_granularity_ns&lt;/code&gt; if the former is set low enough): lower scheduling latency values gives proportionally better performance as the time slices shrink, helping to confirm our theory of how this works.&lt;/p&gt;

&lt;p&gt;This behavior also explains the large amount of variance once the available cores are oversubscribed: by definition, not all threads will be running at once, so the test becomes very sensitive to exactly where the not-running threads took their context switch. At the beginning of the test, only 4 of 6 threads will be running, and the two will be switched out, still waiting on the the &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/blob/master/cyclic-barrier.hpp&quot;&gt;barrier&lt;/a&gt; that synchronizes the test start. Since the two switched out threads haven’t tried to get the lock yet, the four running threads will be able to quickly share the lock between themselves, since the six-thread convoy hasn’t been set up.&lt;/p&gt;

&lt;p&gt;This runs up the “iteration count” (work done) during an initial period which varies randomly, until the first context switch lets the fifth thread join the competition and then the convoy gets set up&lt;sup id=&quot;fnref:csdepend&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:csdepend&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;16&lt;/a&gt;&lt;/sup&gt;. That’s when the catastrophe starts. This makes the results very noisy: for example, if you set a too-short time period for a trial, the &lt;em&gt;entire test&lt;/em&gt; is composed of this initial phase and the results are artificially “good”.&lt;/p&gt;

&lt;p&gt;We can probably invent something even worse, but that’s enough for now. Let’s move on to scenarios that are &lt;em&gt;faster&lt;/em&gt; than the use of vanilla &lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt;.&lt;/p&gt;

&lt;h3 id=&quot;level-1-uncontended-atomics&quot;&gt;Level 1: Uncontended Atomics&lt;/h3&gt;

&lt;p&gt;Recall that we started at level 2: contended atomics. The name gives it away: the next faster level is when atomic operations are used but there is no contention, either by design or by luck. You might have noticed that so far we’ve only shown results for at least two threads. That’s because the single threaded case involves no contention, and so every implementation so far is level 1 if run on a single thread&lt;sup id=&quot;fnref:notexx&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:notexx&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;17&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Here are the results for all the implementations we’ve looked at so far, for a single thread:&lt;/p&gt;

&lt;div class=&quot;tabs&quot;&gt;
    &lt;!-- Courtesy of https://codepen.io/Merri/pen/bytea --&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-single-1&quot; name=&quot;tab-group-single&quot; checked=&quot;&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-single-1&quot;&gt;Skylake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/single.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/skl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/single.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/skl/single.svg&quot; alt=&quot;Increment Cost: Single Threaded&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-single-2&quot; name=&quot;tab-group-single&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-single-2&quot;&gt;Ice Lake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/single.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/icl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/single.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/icl/single.svg&quot; alt=&quot;Increment Cost: Single Threaded&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-single-3&quot; name=&quot;tab-group-single&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-single-3&quot;&gt;Graviton&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/single.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g1-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/single.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g1-16/single.svg&quot; alt=&quot;Increment Cost: Single Threaded&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-single-4&quot; name=&quot;tab-group-single&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-single-4&quot;&gt;Graviton 2&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/single.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g2-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/single.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g2-16/single.svg&quot; alt=&quot;Increment Cost: Single Threaded&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;p&gt;The fastest implementations run in about 10 nanoseconds, which is 5x faster than the fastest solution for 2 or more threads. The &lt;em&gt;slowest&lt;/em&gt; implementation (&lt;abbr title=&quot;A blocking ticket lock where each waiter waits on a unique condition variable.&quot;&gt;queued fifo&lt;/abbr&gt;) for one thread ties the &lt;em&gt;fastest&lt;/em&gt; implementation (&lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt;) at two threads, and beats it handily at three or four.&lt;/p&gt;

&lt;p&gt;The number overlaid on each bar is the number of atomic operations&lt;sup id=&quot;fnref:atomhow&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:atomhow&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;18&lt;/a&gt;&lt;/sup&gt; each implementation makes per increment. It is obvious that the performance is almost directly proportional to the number of atomic instructions. On the other hand, performance does &lt;em&gt;not&lt;/em&gt; have much of a relationship with the total number of instructions of any type, which vary a lot even between algorithms with the same performance as the following table shows:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Algorithm&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Atomics&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Instructions&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Performance&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;abbr title=&quot;Uses a std::mutex and std::lock_guard to protect a plain integer counter.&quot;&gt;mutex add&lt;/abbr&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;~21 ns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;~7 ns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;abbr title=&quot;Uses a CAS loop to increment a single shared counter.&quot;&gt;cas add&lt;/abbr&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;~12 ns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;abbr title=&quot;A ticket lock that calls sched_yield in a spin loop while waiting for its turn.&quot;&gt;ticket yield&lt;/abbr&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;13&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;~10 ns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;abbr title=&quot;A ticket lock which blocks if it cannot immediately acquire the lock.&quot;&gt;ticket blocking&lt;/abbr&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;107&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;~32 ns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;abbr title=&quot;A blocking ticket lock where each waiter waits on a unique condition variable.&quot;&gt;queued fifo&lt;/abbr&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;167&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;~45 ns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;abbr title=&quot;A traditional spin-based ticket lock that does a hot spin while waiting for its ticket to be next.&quot;&gt;ticket spin&lt;/abbr&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;13&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;~10 ns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;abbr title=&quot;A simple mutex from &amp;quot;Futexes Are Tricky&amp;quot;.&quot;&gt;mutex3&lt;/abbr&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;17&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;~20 ns&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In particular, note that &lt;abbr title=&quot;Uses a std::mutex and std::lock_guard to protect a plain integer counter.&quot;&gt;mutex add&lt;/abbr&gt; has more than 9x the number of instructions compared to &lt;abbr title=&quot;Uses a CAS loop to increment a single shared counter.&quot;&gt;cas add&lt;/abbr&gt; yet still runs at half the speed, in line with the 2:1 ratio of atomics. Similarly, &lt;abbr title=&quot;A ticket lock that calls sched_yield in a spin loop while waiting for its turn.&quot;&gt;ticket yield&lt;/abbr&gt; and &lt;abbr title=&quot;A traditional spin-based ticket lock that does a hot spin while waiting for its ticket to be next.&quot;&gt;ticket spin&lt;/abbr&gt; have slightly &lt;em&gt;better&lt;/em&gt; performance than &lt;abbr title=&quot;Uses a CAS loop to increment a single shared counter.&quot;&gt;cas add&lt;/abbr&gt; despite having about twice the number of instructions, in line with them all having a single atomic operation&lt;sup id=&quot;fnref:casworse&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:casworse&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;19&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;The last row in the table shows the performance of &lt;abbr title=&quot;A simple mutex from &amp;quot;Futexes Are Tricky&amp;quot;.&quot;&gt;mutex3&lt;/abbr&gt;, an implementation we haven’t discussed. It is a basic mutex offering similar functionality to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; and whose implementation is described in &lt;a href=&quot;https://akkadia.org/drepper/futex.pdf&quot;&gt;Futexes Are Tricky&lt;/a&gt;. Because it doesn’t need to pass through two layers of abstraction&lt;sup id=&quot;fnref:twolayer&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:twolayer&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;20&lt;/a&gt;&lt;/sup&gt;, it has only about one third the instruction count of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt;, yet performance is almost exactly the same, differing by less than 10%.&lt;/p&gt;

&lt;p&gt;So the idea that you can almost ignore things that are in a lower cost tier seems to hold here. Don’t take this too far: if you design a lock with a single atomic operation but 1,000 other instructions, it is not going to be fast. There are also reasons to keep your instruction count low other than microbenchmark performance: smaller instruction cache footprint, less space occupied in various &lt;abbr title=&quot;Out-of-order execution allows CPUs to execute instructions out of order with respect to the source.&quot;&gt;out-of-order&lt;/abbr&gt; execution buffers, more favorable inlining tradeoffs, etc.&lt;/p&gt;

&lt;p&gt;Here it is important to note that the change in level of our various functions didn’t require a change in implementation. These are exactly the same few implementations we discussed in the slower levels. Instead, we simply changed (by fiat, i.e., adjusting the benchmark parameters) the contention level from “very high” to “zero”. So in this case the  level doesn’t depend only on the code, but also this external factor. Of course, just saying that we are going to get to level 1 by only running one thread is not very useful in real life: we often can’t simply ban multi-threaded operation.&lt;/p&gt;

&lt;p&gt;So can we get to level 1 even under concurrent calls from multiple threads? For this particular problem, we can.&lt;/p&gt;

&lt;h4 id=&quot;adaptive-multi-counter&quot;&gt;Adaptive Multi-Counter&lt;/h4&gt;

&lt;p&gt;One option is to use multiple counters to represent the counter value. We try to organize it so that that threads running concurrently on different CPUs will increment different counters. Thus the &lt;em&gt;logical&lt;/em&gt; counter value is split across all of these internal &lt;em&gt;physical&lt;/em&gt; counters, and so a read of the logical counter value now needs to add together all the physical counter values.&lt;/p&gt;

&lt;p&gt;Here’s an implementation:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;cas_multi_counter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_COUNTERS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;thread_local&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;multi_holder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NUM_COUNTERS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** increment the logical counter value */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// CAS failure indicates contention,&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// so try again at a different index&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_COUNTERS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We’ll call this &lt;abbr title=&quot;Uses a CAS on an adatively per-CPU counter.&quot;&gt;cas multi&lt;/abbr&gt;, and the approach is relatively straightforward.&lt;/p&gt;

&lt;p&gt;There are 64 padded&lt;sup id=&quot;fnref:padded&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:padded&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;21&lt;/a&gt;&lt;/sup&gt; physical counters whose sum makes up the logical counter value. There is a thread-local &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idx&lt;/code&gt; value, initially zero for every thread, that points to the physical counter that each thread should increment. When &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;operator++&lt;/code&gt; is called, we attempt to increment the counter pointed to by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idx&lt;/code&gt; using &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt;.&lt;/p&gt;

&lt;p&gt;If this fails, however, we don’t simply retry. Failure indicates contention&lt;sup id=&quot;fnref:notallfailure&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:notallfailure&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;22&lt;/a&gt;&lt;/sup&gt; (this is the only way the &lt;em&gt;strong&lt;/em&gt; variant of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compare_exchange&lt;/code&gt; can fail), so we add one to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idx&lt;/code&gt; to try another counter on the next attempt.&lt;/p&gt;

&lt;p&gt;In a high-contention scenario like our benchmark, every CPU quickly ends up pointing to a different index value. If there is low contention, it is possible that only the first physical counter will be used.&lt;/p&gt;

&lt;p&gt;Let’s compare this to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic add&lt;/code&gt; version we looked at above, which was the fastest of the level 2 approaches. Recall that it uses an &lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt; on a single counter.&lt;/p&gt;

&lt;div class=&quot;tabs&quot;&gt;
    &lt;!-- Courtesy of https://codepen.io/Merri/pen/bytea --&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-cas-multi-1&quot; name=&quot;tab-group-cas-multi&quot; checked=&quot;&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-cas-multi-1&quot;&gt;Skylake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/cas-multi.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/skl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/cas-multi.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/skl/cas-multi.svg&quot; alt=&quot;Increment Cost: Contention Adaptive Multi-Counter&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-cas-multi-2&quot; name=&quot;tab-group-cas-multi&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-cas-multi-2&quot;&gt;Ice Lake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/cas-multi.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/icl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/cas-multi.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/icl/cas-multi.svg&quot; alt=&quot;Increment Cost: Contention Adaptive Multi-Counter&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-cas-multi-3&quot; name=&quot;tab-group-cas-multi&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-cas-multi-3&quot;&gt;Graviton&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/cas-multi.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g1-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/cas-multi.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g1-16/cas-multi.svg&quot; alt=&quot;Increment Cost: Contention Adaptive Multi-Counter&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-cas-multi-4&quot; name=&quot;tab-group-cas-multi&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-cas-multi-4&quot;&gt;Graviton 2&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/cas-multi.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g2-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/cas-multi.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g2-16/cas-multi.svg&quot; alt=&quot;Increment Cost: Contention Adaptive Multi-Counter&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;p&gt;For 1 active core, the results are the same as we saw earlier: the &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt; approach performs the same as the &lt;abbr title=&quot;Uses a CAS loop to increment a single shared counter.&quot;&gt;cas add&lt;/abbr&gt; algorithm&lt;sup id=&quot;fnref:perfsame&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:perfsame&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;23&lt;/a&gt;&lt;/sup&gt;, which is somewhat slower than &lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt;, due to the need for an additional load (i.e., the line with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter.load()&lt;/code&gt;) to set up the &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt;.&lt;/p&gt;

&lt;p&gt;For 2 to 4 cores, the situation changes dramatically. The multiple counter approach performs the &lt;em&gt;same&lt;/em&gt; regardless of the number of active cores. That is, it exhibits perfect scaling with multiple cores – in contrast to the single-counter approach which scales poorly. At four cores, the relative speedup of the multi-counter approach is about 9x. On Amazon’s Graviton ARM processor the speedup approaches &lt;em&gt;eighty&lt;/em&gt; times at 16 threads.&lt;/p&gt;

&lt;p&gt;This improvement in increment performance comes at a cost, however:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;64 counters ought to be enough for anyone, but they take 4096 (!!) bytes of memory to store what takes only 8 bytes in the &lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt; approach&lt;sup id=&quot;fnref:eightbyte&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:eightbyte&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;24&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; method is much slower: it needs to iterate over and add all 64 values, versus a single load for the earlier approaches.&lt;/li&gt;
  &lt;li&gt;The implementation compiles to much larger code: 113 bytes versus 15 bytes for the single counter &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt; approach or 7 bytes for the &lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt; approach.&lt;/li&gt;
  &lt;li&gt;The concurrent behavior is considerably harder to reason about and document. For example, it is harder to explain the consistency condition provided by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; since it is no longer a single atomic read&lt;sup id=&quot;fnref:read&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:read&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;25&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
  &lt;li&gt;There is a single thread-local &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idx&lt;/code&gt; variable. So while different &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cas_multi_counter&lt;/code&gt; instances are logically independent, the shared &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idx&lt;/code&gt; variable means that things that happen in one counter can affect the non-functional behavior of the others&lt;sup id=&quot;fnref:sharedidx&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:sharedidx&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;26&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some of these downsides can be partly mitigated:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A much smaller number of counters would probably be better for most practical uses. We could also set the array size dynamically based on the detected number of logical CPUs since a larger array should not provide much of a performance increase. Better yet, we might make the size even more dynamic, based on contention: start with a single element and grow it only when contention is detected. This means that even on systems with many CPUs, the size will remain small if contention is never seen in practice. This has a runtime cost&lt;sup id=&quot;fnref:rtcost&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:rtcost&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;27&lt;/a&gt;&lt;/sup&gt;, however.&lt;/li&gt;
  &lt;li&gt;We could optimize the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; method by stopping when we see a zero counter. I believe a careful analysis shows that the non-zero counter values for any instance of this class are all in a contiguous region starting from the beginning of the counter array&lt;sup id=&quot;fnref:subtle&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:subtle&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;28&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
  &lt;li&gt;We could mitigate some of the code footprint by carefully carving the “less hot”&lt;sup id=&quot;fnref:lesshot&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:lesshot&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;29&lt;/a&gt;&lt;/sup&gt; slow path out into a another function, and use our &lt;a href=&quot;https://xania.org/201209/forcing-code-out-of-line-in-gcc&quot;&gt;magic powers&lt;/a&gt; to encourage the small fast path (the first &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt;) to be inlined while the fallback remains not inlined.&lt;/li&gt;
  &lt;li&gt;We could make the thread-local &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idx&lt;/code&gt; per instance specific to solve the “shared &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idx&lt;/code&gt; across all instances” problem. This does require some non-negligible amount of work to implement a dynamic TLS system which can create as many thread local keys as you want&lt;sup id=&quot;fnref:dynamictls&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:dynamictls&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;30&lt;/a&gt;&lt;/sup&gt;, and it is slower.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So while we got a good looking chart, this solution doesn’t exactly dominate the simpler ones. You pay a price along several axes for the lack of contention and you shouldn’t blindly replace the simpler solutions with this one – it needs to be a carefully considered and use-case dependent decision.&lt;/p&gt;

&lt;p&gt;Is it over yet? Can I close this browser tab and reclaim all that memory? Almost. Just one level to go.&lt;/p&gt;

&lt;h3 id=&quot;level-0-vanilla&quot;&gt;Level 0: Vanilla&lt;/h3&gt;

&lt;p&gt;The last and fastest level is achieved when only vanilla instructions are used (and without contention). By &lt;em&gt;vanilla instructions&lt;/em&gt; I mean things like regular loads and stores which don’t imply additional synchronization above what the hardware memory model offers by default&lt;sup id=&quot;fnref:noatomic&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:noatomic&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;31&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;How can we increment a counter atomically while allowing it to be read from any thread? By ensuring there is only one writer for any given physical counter. If we keep a counter &lt;em&gt;per thread&lt;/em&gt; and only allow the owning thread to write to it, there is no need for an atomic increment.&lt;/p&gt;

&lt;p&gt;The obvious way to keep a per-thread counter is use thread-local storage. Something like this:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Keeps a counter per thread, readers need to sum
 * the counters from all active threads and add the
 * accumulated value from dead threads.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;tls_counter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* protects all_counters and accumulator */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* list of all active counters */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tls_counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all_counters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* accumulated value of counters from dead threads */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accumulator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* per-thread tls_counter object */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;thread_local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tls_counter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** add ourselves to the counter list */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tls_counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_guard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;all_counters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * destruction means the thread is going away, so
     * we stash the current value in the accumulator and
     * remove ourselves from the array
     */&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tls_counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_guard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;accumulator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;all_counters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;erase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all_counters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all_counters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all_counters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;incr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_guard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all_counters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accumulator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;incr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The approach is the similar to the per-CPU counter, except that we keep one counter per thread, using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_local&lt;/code&gt;. Unlike earlier implementations, you don’t create instances of this class: there is only one counter and you increment it by calling the static method &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tls_counter::increment()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let’s focus a moment on the actual increment inside the thread-local counter instance:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;incr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is just a verbose way of saying “add 1 to this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::atomic&amp;lt;uint64_t&amp;gt;&lt;/code&gt; but it doesn’t have to be atomic”. We don’t need an atomic increment as there is only one writer&lt;sup id=&quot;fnref:whyatomic&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:whyatomic&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;32&lt;/a&gt;&lt;/sup&gt;. Using the &lt;em&gt;relaxed&lt;/em&gt; memory order means that no barriers are inserted&lt;sup id=&quot;fnref:barrier&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:barrier&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;33&lt;/a&gt;&lt;/sup&gt;. We still need a way to read all the thread-local counters, and the rest of the code deals with that: there is a global vector of pointers to all the active &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tls_counter&lt;/code&gt; objects, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; iterates over this. All access to this vector is protected by a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt;, since it will be accessed concurrently. When threads die, we remove their entry from the array, and add their final value to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tls_counter::accumulator&lt;/code&gt; which is added to the sum of active counters in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Whew.&lt;/p&gt;

&lt;p&gt;So how does this &lt;abbr title=&quot;Uses thread-local storage for a counter per thread.&quot;&gt;tls add&lt;/abbr&gt; implementation benchmark?&lt;/p&gt;

&lt;div class=&quot;tabs&quot;&gt;
    &lt;!-- Courtesy of https://codepen.io/Merri/pen/bytea --&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-tls-1&quot; name=&quot;tab-group-tls&quot; checked=&quot;&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-tls-1&quot;&gt;Skylake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/tls.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/skl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/skl/tls.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/skl/tls.svg&quot; alt=&quot;Increment Cost: Thread Local Storage&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-tls-2&quot; name=&quot;tab-group-tls&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-tls-2&quot;&gt;Ice Lake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/tls.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/icl/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/icl/tls.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/icl/tls.svg&quot; alt=&quot;Increment Cost: Thread Local Storage&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-tls-3&quot; name=&quot;tab-group-tls&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-tls-3&quot;&gt;Graviton&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/tls.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g1-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g1-16/tls.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g1-16/tls.svg&quot; alt=&quot;Increment Cost: Thread Local Storage&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-tls-4&quot; name=&quot;tab-group-tls&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-tls-4&quot;&gt;Graviton 2&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/tls.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/tree/master/results/g2-16/combined.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/concurrency-costs/g2-16/tls.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/concurrency-costs/g2-16/tls.svg&quot; alt=&quot;Increment Cost: Thread Local Storage&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;p&gt;That’s two nanoseconds per increment, regardless of the number of active cores. This turns out to be exactly as fast as just incrementing a variable in memory with a single instruction like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inc [eax]&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add [eax], 1&lt;/code&gt;, so it’s somehow as fast as possible for any solution which ends up incrementing something in memory&lt;sup id=&quot;fnref:whitelie&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:whitelie&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;34&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Let’s take a look at the number of atomics, total instructions and performance for the three implementations in the last plot, for four threads:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Algorithm&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Atomics&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Instructions&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Performance&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;~ 110 ns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;abbr title=&quot;Uses a CAS on an adatively per-CPU counter.&quot;&gt;cas multi&lt;/abbr&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;~ 12 ns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;abbr title=&quot;Uses thread-local storage for a counter per thread.&quot;&gt;tls add&lt;/abbr&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;~ 2 ns&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This is a clear indication that the difference in performance has very little to do with the number of instructions: the ranking by instruction count is exactly the reverse of the ranking by performance! &lt;abbr title=&quot;Uses thread-local storage for a counter per thread.&quot;&gt;tls add&lt;/abbr&gt; has three times the number of instructions, yet is more than &lt;em&gt;fifty times&lt;/em&gt; faster (so the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; varies by a factor of more than 150x).&lt;/p&gt;

&lt;p&gt;As we saw at the last 1, this improvement in performance doesn’t come for free:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The total code size is considerably larger than the per-CPU approach, although most of it is related to creation of the initial object on each thread, and not on the hot path.&lt;/li&gt;
  &lt;li&gt;We have one object per thread, instead of per CPU. For an application with many threads using the counter, this may mean the creation of many individual counters which use both more memory&lt;sup id=&quot;fnref:tlsmem&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:tlsmem&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;35&lt;/a&gt;&lt;/sup&gt; and result in a slower &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; function.&lt;/li&gt;
  &lt;li&gt;This implementation only supports &lt;em&gt;one&lt;/em&gt; counter: the key methods in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tls_counter&lt;/code&gt; are static. This boils down to the need for a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_local&lt;/code&gt; object for the physical counter, which must be static by the rules of C++. A template parameter could be added to allow multiple counters based on dummy types used as tags, but this is still more awkward to use than instances of a class (and some platforms &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/procthread/thread-local-storage&quot;&gt;have limits&lt;/a&gt; on the number of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_local&lt;/code&gt; variables). This limitation could be removed in the same way as discussed earlier for the &lt;abbr title=&quot;Uses a CAS on an adatively per-CPU counter.&quot;&gt;cas multi&lt;/abbr&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idx&lt;/code&gt; variable, but at a cost in performance and complexity.&lt;/li&gt;
  &lt;li&gt;A lock was introduced to protect the array of all counters. Although the important increment operation is still lock-free, things like the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; call, the first counter access on a given thread and thread destruction all compete for the same lock. This could be eased with a read-write lock or a concurrent data structure, but at a cost as always.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-table&quot;&gt;The Table&lt;/h2&gt;

&lt;style&gt;
.yesno {
    display: inline-block;
    border-radius: 3px;
    min-width: 25px;
    text-align: center;
}
.yes {
    background-color: limegreen;
    padding: 3px;
}
.no {
    background-color: orangered;
    padding: 3px 5px;
}
&lt;/style&gt;

&lt;p&gt;Let’s summarize all the levels in this table.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;~Cost&lt;/em&gt; column is a &lt;em&gt;very&lt;/em&gt; approximate estimate of the cost of each “occurrence” of the expensive operation associated with the level. It should be taken as a very rough ballpark for current Intel and AMD hardware, but especially the later levels can vary a lot.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Perf Event&lt;/em&gt; column lists a Linux &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;perf&lt;/code&gt; event that you can use to count the number of times the operation associated with this level occurs, i.e., the thing that is slow. For example, in level 1, you count atomic operations using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_inst_retired.lock_loads&lt;/code&gt; counter, and if you get three counts per high level operation, you can expect roughly 3 x 10 ns = 30 ns cost. Of course, you don’t necessarily need perf in this case: you can inspect the assembly too.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Local&lt;/em&gt; column records whether the behavior of this level is &lt;em&gt;core local&lt;/em&gt;. If yes, it means that operations on different cores complete independently and don’t compete and so the performance scales with the number of cores. If not, there is contention or serialization, so the throughput of the entire system is often limited, regardless of how many cores are involved. For example, only one core at a time performs an atomic operation on a cache line, so the throughput of the whole system is fixed and the throughput per core decreases as more cores become involved.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Key Characteristic&lt;/em&gt; tries to get across the idea of the level in one bit-sized chunk.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Level&lt;/th&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;~Cost (ns)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Perf Event&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Local&lt;/th&gt;
      &lt;th&gt;Key Characteristic&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Vanilla&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;low&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;depends&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong class=&quot;yes yesno&quot;&gt;Yes&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;No atomic instructions or contended accesses at all&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Uncontended Atomic&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_inst_retired.&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_loads&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong class=&quot;yes yesno&quot;&gt;Yes&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Atomic instructions without contention&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;True Sharing&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;40 - 400&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_load_l3_hit_retired.&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xsnp_hitm&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong class=&quot;no yesno&quot;&gt;No&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Contended atomics or locks&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Syscall&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,000&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;raw_syscalls:sys_enter&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong class=&quot;no yesno&quot;&gt;No&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;System call&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Context Switch&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;10,000&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context-switches&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong class=&quot;no yesno&quot;&gt;No&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Forced context switch&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Catastrophe&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;huge&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;depends&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong class=&quot;no yesno&quot;&gt;No&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Stalls until quantum exhausted, or other sadness&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;so-what&quot;&gt;So What?&lt;/h2&gt;

&lt;p&gt;What’s the point of all this?&lt;/p&gt;

&lt;p&gt;Primarily, I use the hierarchy as a simplification mechanism when thinking about concurrency and performance. As a first order approximation &lt;em&gt;you mostly only need to care about the operations related to the current level&lt;/em&gt;. That is, if you are focusing on something which has contended atomic operations (level 2), you don’t need to worry too much about uncontended atomics or instruction counts: just focus on reducing contention. Similarly, if you are at level 1 (uncontended atomics) it is often worth using &lt;em&gt;more&lt;/em&gt; instructions to reduce the number of atomics.&lt;/p&gt;

&lt;p&gt;This guideline only goes so far: if you have to add 100 instructions to remove one atomic, it is probably not worth it.&lt;/p&gt;

&lt;p&gt;Second, when optimizing a concurrent system I always try to consider how I can get to a (numerically) lower level. Can I remove the last atomic? Can I avoid contention? Successfully moving to a lower level can often provide an order-of-magnitude boost to performance, so it should be attempted first, before finer-grained optimizations within the current level. Don’t spend forever optimizing your contended lock, if there’s some way to get rid of the contention entirely.&lt;/p&gt;

&lt;p&gt;Of course, this is not always possible, or not possible without tradeoffs you are unwilling to make.&lt;/p&gt;

&lt;h3 id=&quot;getting-there&quot;&gt;Getting There&lt;/h3&gt;

&lt;p&gt;Here’s a quick look at some usual and unusual ways of achieving levels lower on the hierarchy.&lt;/p&gt;

&lt;h4 id=&quot;level-4&quot;&gt;Level 4&lt;/h4&gt;

&lt;p&gt;You probably don’t want to really be in level 4 but it’s certainly better than level 5. So, if you still have your job and your users haven’t all abandoned you, it’s usually pretty easy to get out of level 5. More than half the battle is just recognizing what’s going on and from there the solution is often clear. Many times, you’ve simply violated some rule like “don’t use pure spinlocks in userspace” or “you built a spinlock by accident” or “so-and-so accidentally held that core lock during IO”. There’s almost never any inherent reason you’d need to stay in level 5 and you can usually find an almost tradeoff-free fix.&lt;/p&gt;

&lt;p&gt;A better approach than targeting level 4 is just to skip to level 2, since that’s usually not too difficult.&lt;/p&gt;

&lt;h4 id=&quot;level-3&quot;&gt;Level 3&lt;/h4&gt;

&lt;p&gt;Getting to level 3 just means solving the underlying reason for so many context switches. In the example used in this post, it means giving up fairness. Other approaches include not using threads for small work units, using smarter thread pools, not oversubscribing cores, and keeping locked regions short.&lt;/p&gt;

&lt;p&gt;You don’t usually really want to be in level 3 though: just skip right to level 2.&lt;/p&gt;

&lt;h4 id=&quot;level-2&quot;&gt;Level 2&lt;/h4&gt;

&lt;p&gt;Level 3 isn’t a &lt;em&gt;terrible&lt;/em&gt; place to be, but you’ll always have that gnawing in your stomach that you’re leaving a 10x speedup on the table. You just need to get rid of that system call or context switch, bringing you to level 2.&lt;/p&gt;

&lt;p&gt;Most library provided concurrency primitives already avoid system calls on the happy path. E.g., pthreads mutex, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt;, Windows &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CRITICAL_SECTION&lt;/code&gt; will avoid a system call while acquiring and releasing an uncontended lock. There are, however, some notable exceptions: if you are using a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/sync/mutex-objects&quot;&gt;Win32 mutex object&lt;/a&gt; or &lt;a href=&quot;https://man7.org/linux/man-pages/man2/semop.2.html&quot;&gt;System V semaphore&lt;/a&gt; object, you are paying a system call on every operation. Double check if you can use an in-process alternative in this case.&lt;/p&gt;

&lt;p&gt;For more general synchronization purposes which don’t fit the lock-unlock pattern, a condition variable often fits the bill and a quality implementation generally avoids system calls on the fast path. A relatively unknown and higher performance alternative to condition variables, especially suitable for coordinating blocking for otherwise lock-free structures, is an &lt;a href=&quot;http://pvk.ca/Blog/2019/01/09/preemption-is-gc-for-memory-reordering/#event-counts-with-x86-tso-and-futexes&quot;&gt;&lt;em&gt;event count&lt;/em&gt;&lt;/a&gt;. Paul’s implementation is &lt;a href=&quot;https://github.com/concurrencykit/ck/blob/master/include/ck_ec.h&quot;&gt;available in concurrency kit&lt;/a&gt; and we’ll mention it again at Level 0.&lt;/p&gt;

&lt;p&gt;System calls often creep in when home-grown synchronization solutions are used, e.g., using Windows events to build your own read-write lock or striped lock or whatever the flavor of the day is. You can often remove the call in the fast path by making a check in user-space to see if a system call is necessary. For example, rather than unconditionally unblocking any waiters when releasing some exclusive object, &lt;em&gt;check&lt;/em&gt; to see if there are waiters&lt;sup id=&quot;fnref:tricky&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:tricky&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;36&lt;/a&gt;&lt;/sup&gt; in userspace and skip the system call if there are none.&lt;/p&gt;

&lt;p&gt;If a lock is generally held for a short period, you can avoid unnecessary system calls and context switches with a hybrid lock that spins for an appropriate&lt;sup id=&quot;fnref:spin&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:spin&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;37&lt;/a&gt;&lt;/sup&gt; amount of time before blocking. This can trade tens of nanoseconds of spinning for hundreds or thousands of nanoseconds of system calls.&lt;/p&gt;

&lt;p&gt;Ensure your use of threads is “right sized” as much as possible. A lot of unnecessary context switches occur when many more threads are running than there are CPUs, and this increases the chance of a lock being held during a context switch (and makes it worse when it does happen: it takes longer for the holding thread to run again as the scheduler probably cycles through all the other runnable threads first).&lt;/p&gt;

&lt;h4 id=&quot;level-1&quot;&gt;Level 1&lt;/h4&gt;

&lt;p&gt;A lot of code that does the work to get to level 2 actually ends up in level 1. Recall that the primary difference between level 1 and 2 is the lack of contention in level 1. So if your process naturally or by design has low contention, simply using existing off-the-shelf synchronization like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; can get you to level 1.&lt;/p&gt;

&lt;p&gt;I can’t give a step-by-step recipe for reducing contention, but here’s a laundry list of things to consider:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Keep your critical sections as short as possible. Ensure you do any heavy work that doesn’t directly involve a shared resource outside of the critical section. Sometimes this means making a copy of the shared data to work on it “outside” of the lock, which might increase the total amount of work done, but reduce contention.&lt;/li&gt;
  &lt;li&gt;For things like atomic counters, try to batch your updates: e.g., if you update the counter multiple times during some operation, update a local on the stack rather than the global counter and only “upload” the entire value once at the end.&lt;/li&gt;
  &lt;li&gt;Consider using structures that use fine-grained locks, striped locks or similar mechanisms that reduce contention by locking only portions of a container.&lt;/li&gt;
  &lt;li&gt;Consider per-CPU structures, as in the examples above, or some approximation of them (e.g., hashing the current thread ID into an array of structures). This post used an atomic counter as a simple example, but it applies more generally to any case where the mutations can be done independently and aggregated later.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For all of the advice above, when I say &lt;em&gt;consider doing X&lt;/em&gt; I really mean &lt;em&gt;consider finding and using an existing off-the shelf component that does X&lt;/em&gt;. Writing concurrent structures yourself should be considered a last resort – despite what you think, your use case is probably not all that unique.&lt;/p&gt;

&lt;p&gt;Level 1 is where a lot of well written, straightforward and high-performing concurrent code lives. There is nothing wrong with this level – it is a happy place.&lt;/p&gt;

&lt;h4 id=&quot;level-0&quot;&gt;Level 0&lt;/h4&gt;

&lt;p&gt;It is not always easy or possible to remove the last atomic access from your fast paths, but if you just can’t live with the extra ~10 ns, here are some options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The general approach of using thread local storage, as discussed above, can also be extended to structures more complicated than counters.&lt;/li&gt;
  &lt;li&gt;You may be able to achieve fewer than one expensive atomic instruction per logical operation by &lt;em&gt;batching:&lt;/em&gt; saving up multiple operations and then committing them at all once with a small fixed number of atomic operations. Some containers or concurrent structures may have a batched API which does this for you, but even if not you can sometimes add batching yourself, e.g., by inserting collections of elements rather than a single element&lt;sup id=&quot;fnref:hiddenbatch&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:hiddenbatch&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;38&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
  &lt;li&gt;Many lock-free structures offer atomic-free &lt;em&gt;read&lt;/em&gt; paths, notably concurrent containers in garbage collected languages, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt; in Java. Languages without garbage collection have fewer straightforward options, mostly because safe memory reclamation is a &lt;a href=&quot;http://concurrencyfreaks.blogspot.com/2017/08/why-is-memory-reclamation-so-important.html&quot;&gt;hard problem&lt;/a&gt;, but there are still &lt;a href=&quot;http://concurrencykit.org/&quot;&gt;some&lt;/a&gt; &lt;a href=&quot;https://software.intel.com/content/www/us/en/develop/documentation/tbb-documentation/top/intel-threading-building-blocks-developer-guide/containers.html&quot;&gt;good&lt;/a&gt; &lt;a href=&quot;https://github.com/facebook/folly/tree/master/folly/concurrency&quot;&gt;options&lt;/a&gt; out there.&lt;/li&gt;
  &lt;li&gt;I find that &lt;a href=&quot;https://liburcu.org/&quot;&gt;RCU&lt;/a&gt; is especially powerful and fairly general if you are using a garbage collected language, or can satisfy the requirements for an efficient reclamation method in a non-GC language.&lt;/li&gt;
  &lt;li&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Seqlock&quot;&gt;seqlock&lt;/a&gt;&lt;sup id=&quot;fnref:despite&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:despite&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;39&lt;/a&gt;&lt;/sup&gt; is an underrated and little known alternative to RCU without reclaim problems, although not as general. Concurrencykit has &lt;a href=&quot;http://concurrencykit.org/doc/ck_sequence.html&quot;&gt;an implementation&lt;/a&gt;. It has an atomic-free read path for readers. Unfortunately, seqlocks don’t integrate cleanly with either the Java&lt;sup id=&quot;fnref:stampedlock&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:stampedlock&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;40&lt;/a&gt;&lt;/sup&gt; or &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1478r1.html&quot;&gt;C++&lt;/a&gt; memory models.&lt;/li&gt;
  &lt;li&gt;It is also possible in some cases to do a per-CPU rather than a per-thread approach using only vanilla instructions, although the possibility of interruption at any point makes this tricky. &lt;a href=&quot;https://www.efficios.com/blog/2019/02/08/linux-restartable-sequences/&quot;&gt;Restartable sequences (rseq)&lt;/a&gt; can help, and there are other tricks lurking out there.&lt;/li&gt;
  &lt;li&gt;Event counts, mentioned earlier, &lt;a href=&quot;https://pvk.ca/Blog/2019/01/09/preemption-is-gc-for-memory-reordering/#event-counts-with-x86-tso-and-futexes:~:text=However%2C%20if%20we%20go&quot;&gt;can even be level 0&lt;/a&gt; in a single writer scenario, as Paul shows.&lt;/li&gt;
  &lt;li&gt;This is the last point, but it should be the first: you can probably often redesign your algorithm or application to avoid sharing data in the first place, or to share much less. For example, rather than constantly updating a shared collection with intermediate results, do as much private computation as possible before only merging the final results.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;We looked at the six different levels that make up this concurrency cost hierarchy. The slow half (3, 4 and 5) are all basically performance bugs. You should be able to achieve level 2 or level 1 (if you naturally have low contention) for most designs fairly easily and those are probably what you should target by default. Level 1 in a contended scenario and level 0 are harder to achieve and often come with difficult tradeoffs, but the performance boost can be significant: often one or more orders of magnitude.&lt;/p&gt;

&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;Thanks to Paul Khuong who &lt;a href=&quot;https://pvk.ca/Blog/2020/07/07/flatter-wait-free-hazard-pointers&quot;&gt;showed me something&lt;/a&gt; that made me reconsider in what scenarios level 0 is achievable and typo fixes.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://twitter.com/never_released&quot;&gt;@never_released&lt;/a&gt; for help on a problem I had bringing up an EC2 bare-metal instance (tip: just wait).&lt;/p&gt;

&lt;p&gt;Special thanks to &lt;a href=&quot;https://twitter.com/matt_dz&quot;&gt;matt_dz&lt;/a&gt; and Zach Wenger for helping fix about &lt;em&gt;sixty&lt;/em&gt; typos between them.&lt;/p&gt;

&lt;p&gt;Thanks to Alexander Monakov, Dave Andersen, Laurent and Kriau for reporting typos, and Aaron Jacobs for suggesting clarifications to the level 0 definition.&lt;/p&gt;

&lt;p&gt;Traffic light photo by &lt;a href=&quot;https://unsplash.com/@harshaldesai&quot;&gt;Harshal Desai&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/traffic-light&quot;&gt;Unsplash&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;discussion-and-feedback&quot;&gt;Discussion and Feedback&lt;/h3&gt;

&lt;p&gt;You can leave a &lt;a href=&quot;#comment-section&quot;&gt;comment below&lt;/a&gt; or discuss on &lt;a href=&quot;https://news.ycombinator.com/item?id=23749172&quot;&gt;Hacker News&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/programming/comments/hma5y1/a_concurrency_cost_hierarchy/&quot;&gt;r/programming&lt;/a&gt; or &lt;a href=&quot;https://www.reddit.com/r/cpp/comments/hmaocb/a_concurrency_cost_hierarchy/&quot;&gt;r/cpp&lt;/a&gt;.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;If you liked this post, check out the &lt;a href=&quot;/&quot;&gt;homepage&lt;/a&gt; for others you might enjoy.&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:realworld&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Well, this is quite real world: such atomic counters are used widely for a variety of purposes. I throw the &lt;em&gt;if you squint&lt;/em&gt; in there because, after all, we are using microbenchmarks which simulate a probably-unrealistic density of increments to this counter, and it is a &lt;em&gt;bit&lt;/em&gt; of a stretch to make this one example span all five levels – but I tried! &lt;a href=&quot;#fnref:realworld&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:g2cores&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The Graviton 2 bare metal hardware has 64 cores, but this instance size makes 16 of them available. This means that in principle the results can be affected by the coherency traffic of other tenants on the same hardware, but the relatively stable results seem to indicate it doesn’t affect the results much. &lt;a href=&quot;#fnref:g2cores&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:parisc&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Some hardware supports very limited atomic operations, which may be mostly useful &lt;em&gt;only&lt;/em&gt; for locking, although you can &lt;a href=&quot;https://parisc.wiki.kernel.org/index.php/FutexImplementation&quot;&gt;get tricky&lt;/a&gt;. &lt;a href=&quot;#fnref:parisc&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:post&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;We could actually use either the pre or post-increment version of the operator here. The usual advice is to prefer the pre-increment form &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++c&lt;/code&gt; as it can be faster as it can return the mutated value, rather than making a copy to return after the mutation. Now this advice rarely applies to primitive values, but atomic increment is actually an interesting case which turns it on its head: the post-increment version is probably better (at least, never slower) since the underlying hardware operation returns the previous value. So it’s &lt;a href=&quot;https://godbolt.org/z/p4TDjX&quot;&gt;at least one extra operation&lt;/a&gt; to calculate the pre-increment value (or much worse, apparently, if icc gets involved). &lt;a href=&quot;#fnref:post&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:atomicsup&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Many ISAs, including POWER and ARM, traditionally only included support for a &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt;-like or &lt;a href=&quot;https://en.wikipedia.org/wiki/Load-link/store-conditional&quot;&gt;LL/SC&lt;/a&gt; operation, without specific support for more specific atomic arithmetic operations. The idea, I think, was that you could build any operation you want on top of of these primitives, at the cost of “only” a small retry loop and that’s more RISC-y, right? This seems to be changing as ARMv8.1 got a bunch of atomic operations. &lt;a href=&quot;#fnref:atomicsup&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:java&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;From its introduction through Java 7, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt; and related classes in Java implemented all their atomic operations on top of a &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt; loop, as &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt; was the only primitive implemented as an intrinsic. In Java 8, almost exactly a decade later, these were finally replaced with dedicated atomic RMWs where possible, with &lt;a href=&quot;http://ashkrit.blogspot.com/2014/02/atomicinteger-java-7-vs-java-8.html&quot;&gt;good results&lt;/a&gt;. &lt;a href=&quot;#fnref:java&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:l3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;On my system and most (all?) modern Intel systems this is essentially the L3 cache, as the caching home agent (CHA) lives in or adjacent to the L3 cache. &lt;a href=&quot;#fnref:l3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:inter&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This doesn’t imply that each atomic operation needs to take 70 cycles under contention: a single core could do &lt;em&gt;multiple&lt;/em&gt; operations on the cache line after it gains exclusive ownership, so the cost of obtaining the line could be amortized over all of these operations. How much of this occurs is a measure of fairness: a very fair CPU will not let any core monopolize the line for long, but this makes highly concurrent benchmarks like this slower. Recent Intel CPUs seem quite fair in this sense. &lt;a href=&quot;#fnref:inter&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:notwhat&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;It also might not &lt;a href=&quot;https://www.realworldtech.com/forum/?threadid=189711&amp;amp;curpostid=189752&quot;&gt;work how you think&lt;/a&gt;, depending on details of the OS scheduler. &lt;a href=&quot;#fnref:notwhat&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:spectre&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;They used to be cheaper: based on my measurements the cost of system calls has more than doubled, on most Intel hardware, after the Spectre and Meltdown mitigations have been applied. &lt;a href=&quot;#fnref:spectre&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:hyst&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;An interesting thing about convoys is that they exhibit hysteresis: once you start having a convoy, they become self-sustaining, even if the conditions that started it are removed. Imagine two threads that lock a common lock for 1 nanosecond every 10,000 nanoseconds. Contention is low: the chance of any particular lock acquisition being contended is 0.01%. However, as soon as a contended acquisition occurs, the lock effectively becomes held for the amount of time it takes to do a full context switch (for the losing thread to block, and then to wake up). If that’s longer than 10,000 nanoseconds, the convoy will sustain itself indefinitely, until something happens to break the loop (e.g., one thread deciding to work on something else). A restart also “fixes” it, which is one of many possible explanations for processes that suddenly shoot to 100% CPU (but are still making progress), but can be fixed by a restart. Everything becomes worse with more than two threads, too. &lt;a href=&quot;#fnref:hyst&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:huh&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Actually I find it remarkable that this performs about as well as the &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt;-based &lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt;, since the fairness necessarily implies that the lock is acquired in a round-robin order, so the cache line with the lock must at a minimum move around to each acquiring thread. This is a real stress test of the arbitrary coherency mechanisms offered by the CPU. &lt;a href=&quot;#fnref:huh&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:noht&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;And no SMT enabled, so there are 4 logical processors from the point of view of the OS. &lt;a href=&quot;#fnref:noht&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:once&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In fact, the &lt;em&gt;once&lt;/em&gt; scenario is the most likely, since one would assume with homogeneous threads the scheduler will approximate something like round-robin scheduling. So the thread that is descheduled is most likely the one that is also closest to the head of the lock queue, because it had been spinning the longest. &lt;a href=&quot;#fnref:once&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:perf&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In fact, you can measure this with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;perf&lt;/code&gt; and see that the total number of context switches is usually within a factor of 2 for both tests, when oversubscribed. &lt;a href=&quot;#fnref:perf&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:csdepend&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;There is another level of complication here: the convoy only gets set up when the fifth thread joins the fun &lt;em&gt;if&lt;/em&gt; the thread that gets switched out had expressed interest in the lock before it lost the CPU. That is, after a thread unlocks the lock, there is a period before it gets a new ticket as it tries to obtain the lock again. Before it gets that ticket, it is essentially invisible to the other threads, and if it gets context switched out, the catastrophic convoy won’t be set up (because the new set of four threads will be able to efficiently share the lock among themselves). &lt;a href=&quot;#fnref:csdepend&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:notexx&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This won’t always &lt;em&gt;necessarily&lt;/em&gt; be the case. You could write a primitive that always makes a system call, putting it at level 3, even if there is no contention, but here I’ve made sure to always have a no-syscall fast path for the no-contention case. &lt;a href=&quot;#fnref:notexx&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:atomhow&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;On Intel hardware you can use &lt;a href=&quot;https://github.com/travisdowns/concurrency-hierarchy-bench/blob/master/scripts/details.sh&quot;&gt;details.sh&lt;/a&gt; to collect the atomic instruction count easily, taking advantage of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_inst_retired.lock_loads&lt;/code&gt; performance counter. &lt;a href=&quot;#fnref:atomhow&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:casworse&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The &lt;abbr title=&quot;Uses a CAS loop to increment a single shared counter.&quot;&gt;cas add&lt;/abbr&gt; implementation comes off looking slightly worse than the other single-atomic implementations here because the load required to set up the &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt; value effectively adds to the dependency chain involving the atomic operation, which explains the 5-cycle difference with &lt;abbr title=&quot;Uses an atomic increment on a single shared counter.&quot;&gt;atomic add&lt;/abbr&gt;. This goes away if you can do a &lt;em&gt;blind &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt;&lt;/em&gt; (e.g., in locks’ acquire paths), but that’s not possible here. &lt;a href=&quot;#fnref:casworse&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:twolayer&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Actually three layers, &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/4ff685a8705e8ee55fa86e75afb769ffb0975aea/libstdc%2B%2B-v3/include/bits/std_mutex.h#L98&quot;&gt;libstdc++&lt;/a&gt;, then &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/4ff685a8705e8ee55fa86e75afb769ffb0975aea/libgcc/gthr-posix.h#L775&quot;&gt;libgcc&lt;/a&gt; and then finally pthreads. I’ll count the first two as one though because those can all inline into the caller. Based on a rough accounting, probably 75% of the instruction count comes from pthreads, the rest from the other two layers. The pthreads mutexes are more general purpose than what &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; offers (e.g., they support recursion), and the features are configured at runtime on a per-mutex basis, so that explains a lot of the additional work these functions are doing. It’s only due to cost of atomic operations that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; doesn’t take a significant penalty compared to a more svelte design. &lt;a href=&quot;#fnref:twolayer&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:padded&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;em&gt;Padded&lt;/em&gt; means that the counters are aligned such that each falls into its own 64 byte cache line, to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/False_sharing&quot;&gt;&lt;em&gt;false sharing&lt;/em&gt;&lt;/a&gt;. This means that even though each counter only has 8 bytes of logical payload, it requires 64 bytes of storage. Some people claim that you need to pad out to 128 bytes, not 64, to avoid the effect of the &lt;em&gt;adjacent line prefetcher&lt;/em&gt; which fetches the 64-byte that completes an aligned 128-byte pair of lines. However, I have not observed this effect often on modern CPUs. Maybe the prefetcher is conservative and doesn’t trigger unless past behavior indicates the fetches are likely to be used, or the prefetch logic can detect and avoid cases of false sharing (e.g., by noticing when prefetched lines are subsequently invalidated by a snoop). &lt;a href=&quot;#fnref:padded&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:notallfailure&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Actually, not &lt;em&gt;all&lt;/em&gt; failure indicates contention: there is a small chance also that a context switch exactly splits the load and the subsequent &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt;, and in this case the &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt; would fail when the thread was scheduled again if any thread that ran in the meantime updated the same counter. Treating this as contention doesn’t really cause any serious problems. &lt;a href=&quot;#fnref:notallfailure&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:perfsame&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Not surprising, since there is no contention and the fast path looks the same for either algorithm: a single &lt;abbr title=&quot;Compare-and-swap: an atomic operation implemented on x86 and other CPUs.&quot;&gt;CAS&lt;/abbr&gt; that always succeeds. &lt;a href=&quot;#fnref:perfsame&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:eightbyte&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Here I’m assuming that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sizeof(std::atomic&amp;lt;uint64_t&amp;gt;)&lt;/code&gt; is 8, and this is the case on all current mainstream platforms. Also, you may or may not want to pad out the single-counter version to 64 bytes as well, to avoid some &lt;em&gt;potential&lt;/em&gt; false sharing with nearby values, but this is different than the multi-counter case where padding is obligatory to avoid guaranteed false sharing. &lt;a href=&quot;#fnref:eightbyte&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:read&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In this limited case, I &lt;em&gt;think&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; provides the same guarantees as the single-counter case. Informally, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; returns some value that the counter had at some point between the start and end of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; call. Formally, there is a &lt;em&gt;linearization point&lt;/em&gt; within &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; although this point can only be determined in retrospect by examining the returned value (unlike the single-counter approaches, where the linearization is clear regardless of the value). However, &lt;em&gt;this is only true because the only mutating operation is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;increment()&lt;/code&gt;&lt;/em&gt;. If we also offered a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;decrement()&lt;/code&gt; method, this would no longer be true: you could read values that the logical counter never had based on the sequence of increments and decrements. Specifically, if you execute &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;increment(); decrement(); increment()&lt;/code&gt; and even if you know these operations are strictly ordered (e.g., via locking), a concurrent call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; could return &lt;em&gt;2&lt;/em&gt;, even though the counter never logically exceeded 1. &lt;a href=&quot;#fnref:read&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:sharedidx&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In particular, if contention is seen on one object, the per-thread index will change to avoid it, which changes the index of all other objects as well, even if they have not seen any contention. This doesn’t seem like much of a problem for this simple implementation (which index we write to doesn’t matter much), but it could make some other optimizations more difficult: e.g., if we size the counter array dynamically, we don’t want to unnecessarily change the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idx&lt;/code&gt; for uncontended objects, since it requires a larger counter array, unnecessarily. &lt;a href=&quot;#fnref:sharedidx&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:rtcost&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;At least, an extra indirection to access the array which is no longer embedded in the object&lt;sup id=&quot;fnref:soa&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:soa&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;41&lt;/a&gt;&lt;/sup&gt;, and checks to ensure the array is large enough. Furthermore, we have another decision to make: when to expand the array. How much contention should we suffer before we decide the array is too small? &lt;a href=&quot;#fnref:rtcost&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:subtle&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The intuition is later counter positions only get written when an earlier position failed a compare and swap, which necessarily implies it was written to by some other thread and hence non-zero. There is some subtlety here: this wouldn’t hold if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compare_exchange_weak&lt;/code&gt; was used instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compare_exchange_strong&lt;/code&gt;, and it more obviously wouldn’t apply if we allowed decrements or wanted to change the “probe” strategy. &lt;a href=&quot;#fnref:subtle&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:lesshot&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I’m not sure if “less hot” means &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__attribute__((cold))&lt;/code&gt; necessarily, that might be &lt;em&gt;too&lt;/em&gt; cold. We mostly just want to separate the first-cas-succeeds case and the rest of the logic so we don’t pay the dynamic code size impact except when the fallback path is taken. &lt;a href=&quot;#fnref:lesshot&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:dynamictls&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;A sketch of an implementation would be to use something like a single static &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_local&lt;/code&gt; pointer to an array or map, which maps an ID contained in the dynamic TLS key to the object data. Lookup speed is important, which favors an array, but you also need to be able to remove elements, which can favor some type of hash map. All of this is probably at least twice as slow as a plain &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_local&lt;/code&gt; access … or just use &lt;a href=&quot;https://github.com/facebook/folly/blob/master/folly/docs/ThreadLocal.md&quot;&gt;folly&lt;/a&gt; or &lt;a href=&quot;https://www.boost.org/doc/libs/1_73_0/doc/html/thread/thread_local_storage.html&quot;&gt;boost&lt;/a&gt;. &lt;a href=&quot;#fnref:dynamictls&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:noatomic&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;On x86, what’s vanilla and what isn’t is fairly cut and dried: regular memory accesses and read-modify-write instructions are &lt;em&gt;vanilla&lt;/em&gt; while LOCKed &lt;abbr title=&quot;Read-modify-write: an instruction that reads from a memory location, operates on the value, and writes the result back to the same location.&quot;&gt;RMW&lt;/abbr&gt; instructions, whether explicit like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock inc&lt;/code&gt; or implicit like &lt;a href=&quot;https://www.felixcloutier.com/x86/xchg&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xchg [mem], reg&lt;/code&gt;&lt;/a&gt;, are not and are an order of magnitude slower. Out of the fences, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mfence&lt;/code&gt; is also a slow non-vanilla instruction, comparable in cost to a LOCKed instruction. On other platforms like ARM or POWER, there may be shades of grey: you still have vanilla accesses on one end, and expensive full barriers like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dmb&lt;/code&gt; on ARM or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync&lt;/code&gt; on POWER at the other, but you also have things in the middle with some additional ordering guarantees but still short of sequential consistency. This includes things like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LDAR&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LDAPR&lt;/code&gt; on ARM which implement sort of a sliding scale of load ordering and performance. Still, on any given hardware, you might find that instructions generally fall into a “cheap” (vanilla) and “expensive” (non-vanilla) bucket. &lt;a href=&quot;#fnref:noatomic&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:whyatomic&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The only reason we even need &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::atomic&amp;lt;uint64_t&amp;gt;&lt;/code&gt; at all is because it is &lt;em&gt;undefined behavior&lt;/em&gt; to have concurrent access to any variable if at least one access is a write. Since the owning thread is making writes, this would &lt;em&gt;technically&lt;/em&gt; be a violation of the standard if there was a concurrent &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tls_counter::read()&lt;/code&gt; call. Most actual hardware has no problem with concurrent reads and writes like this, but it’s better to stay on the right side of the law. Some hardware could also exhibit &lt;em&gt;tearing&lt;/em&gt; of the writes, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::atomic&lt;/code&gt; guarantees this doesn’t happen. That is, the read and write are still &lt;em&gt;individually&lt;/em&gt; atomic. &lt;a href=&quot;#fnref:whyatomic&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:barrier&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;If you use the default &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::memory_order_seq_cst&lt;/code&gt;, on x86 gcc inserts an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mfence&lt;/code&gt; which makes this &lt;em&gt;even slower than an atomic increment&lt;/em&gt; since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mfence&lt;/code&gt; is generally slower than instructions with a lock prefix (it has slightly stronger barrier semantics). &lt;a href=&quot;#fnref:barrier&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:whitelie&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This is a very small white lie. I’ll explain more elsewhere. &lt;a href=&quot;#fnref:whitelie&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:tlsmem&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;On the other hand, the TLS approach doesn’t need padding since the counters will generally appear next to other thread-local data, and not subject to false sharing, which means an 8x reduction (from 64 to 8 bytes) in the per-counter size, so if your process has a number of threads roughly equal to the number of cores, you will probably &lt;em&gt;save&lt;/em&gt; memory over the per-CPU approach. &lt;a href=&quot;#fnref:tlsmem&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:tricky&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;It’s easy to introduce a missed wakeup problem if this isn’t done correctly. The usual cause is a race condition between some waiter arriving at a lock-like thing, seeing that it’s locked and then indicating interest, but in the critical region of that check-then-act the owning thread left the lock and didn’t see any waiters. The waiter blocks but there is nobody to unblock them. These bugs often go undetected since the situation resolves itself as soon as another thread arrives, so in a busy system you might not notice the temporarily hung threads. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;futex&lt;/code&gt; system call is basically designed to make solving this easy, while the Event stuff in Windows requires a bit more work (usually based on a compare-and-swap). &lt;a href=&quot;#fnref:tricky&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:spin&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;An “appropriate” time is probably something like the typical runtime of the locked region. Basically you want to spin in any case where the lock is held by a currently running thread, which will release it soon. As soon as you’ve been spinning for more than the typical hold time of the lock, it becomes much more likely you are simply waiting for a lock held by a thread that is &lt;em&gt;not&lt;/em&gt; running (e.g., it was unlucky enough to incur a context switch while it held the lock). In that case, you are better off sleeping. &lt;a href=&quot;#fnref:spin&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:hiddenbatch&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;An interesting design point is a data type that implements batching internally behind an API offering single-element operations. For example, a queue might decide that added elements won’t be immediately consumed (because there are already some elements in the queue), and hold them in a local staging area until several can be added as a batch, or until their absence would be noticed. &lt;a href=&quot;#fnref:hiddenbatch&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:despite&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Despite the current claim in wikipedia that seqlocks are somehow a Linux-specific construct involving the kernel, they work great in userspace only and are not tied to Linux. It is likely they were not invented for use in Linux but &lt;a href=&quot;https://twitter.com/davidtgoldblatt/status/1280189008803278848&quot;&gt;pre-dated&lt;/a&gt; the OS, although maybe the use in Linux was where the name &lt;em&gt;seqlock&lt;/em&gt; first appeared? &lt;a href=&quot;#fnref:despite&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:stampedlock&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Java does provide &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/StampedLock.html&quot;&gt;StampedLock&lt;/a&gt; which offers seqlock functionality. &lt;a href=&quot;#fnref:stampedlock&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:soa&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Of course, we could go even &lt;em&gt;one step further&lt;/em&gt; and embed a small array of 1 or 2 elements in the counter object, in the hope that this is enough and only use a dynamically allocated array and suffer the additional indirection if we observe contention. &lt;a href=&quot;#fnref:soa&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Travis Downs</name><email>travis.downs@gmail.com</email></author><category term="blog" /><category term="performance" /><category term="c++" /><category term="concurrency" /><summary type="html">Concurrent operations can be grouped relatively neatly into categories based on their cost</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://travisdowns.github.io/assets/concurrency-costs/avatar.jpg" /><media:content medium="image" url="https://travisdowns.github.io/assets/concurrency-costs/avatar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">AVX-512 Mask Registers, Again</title><link href="https://travisdowns.github.io/blog/2020/05/26/kreg2.html" rel="alternate" type="text/html" title="AVX-512 Mask Registers, Again" /><published>2020-05-26T00:00:00+00:00</published><updated>2020-05-26T00:00:00+00:00</updated><id>https://travisdowns.github.io/blog/2020/05/26/kreg2</id><content type="html" xml:base="https://travisdowns.github.io/blog/2020/05/26/kreg2.html">&lt;!-- boilerplate 
page.assets: /assets/kreg2
assetpath: /assets/kreg2
tablepath: /misc/tables/kreg2
--&gt;

&lt;h2 id=&quot;exposition&quot;&gt;Exposition&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2019/12/05/kreg-facts.html&quot;&gt;Not that long ago&lt;/a&gt; we looked at the AVX-512 mask registers. Specifically, the number of physical registers underlying the eight architectural ones, and some other behaviors such as zeroing idioms. Recently, a high resolution die shot of &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt; appeared, and I thought it would be cool to verify our register count by visual inspection.&lt;/p&gt;

&lt;p&gt;After all, rather than writing some complex software to test hardware, why not &lt;em&gt;simply&lt;/em&gt; use a series of noxious chemicals and manual labor to painstakingly expose the CPU, then carefully photograph it with a microscope and stitch the photos together and finally, &lt;em&gt;just use our eyes&lt;/em&gt; to count the register? If that doesn’t sound all that easy, you are not alone, but as luck would have it someone else has already done that part.&lt;/p&gt;

&lt;p&gt;While trying to simply count the mask registers, I ran across something else even more interesting&lt;sup id=&quot;fnref:bar&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:bar&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; instead…&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#exposition&quot; id=&quot;markdown-toc-exposition&quot;&gt;Exposition&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rising-action&quot; id=&quot;markdown-toc-rising-action&quot;&gt;Rising Action&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#the-die-shot&quot; id=&quot;markdown-toc-the-die-shot&quot;&gt;The Die Shot&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#the-register-files&quot; id=&quot;markdown-toc-the-register-files&quot;&gt;The Register Files&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#the-mystery-block&quot; id=&quot;markdown-toc-the-mystery-block&quot;&gt;The Mystery Block&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#lets-get-legacy&quot; id=&quot;markdown-toc-lets-get-legacy&quot;&gt;Let’s Get Legacy&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#testing-our-theory&quot; id=&quot;markdown-toc-testing-our-theory&quot;&gt;Testing Our Theory&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#some-missing-pieces&quot; id=&quot;markdown-toc-some-missing-pieces&quot;&gt;Some Missing Pieces&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#thanks&quot; id=&quot;markdown-toc-thanks&quot;&gt;Thanks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#discussion-and-feedback&quot; id=&quot;markdown-toc-discussion-and-feedback&quot;&gt;Discussion and Feedback&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rising-action&quot;&gt;Rising Action&lt;/h2&gt;

&lt;h3 id=&quot;the-die-shot&quot;&gt;The Die Shot&lt;/h3&gt;

&lt;p&gt;We’re interested in this die shot, recently released by &lt;a href=&quot;https://twitter.com/FritzchensFritz&quot;&gt;Fritzchens Fritz&lt;/a&gt; on &lt;a href=&quot;https://www.flickr.com/photos/130561288@N04/49825363402/in/photostream/&quot;&gt;Flickr&lt;/a&gt;. We’ll be focusing on the highlighted area, which seems to have all the &lt;a href=&quot;https://en.wikipedia.org/wiki/Register_file&quot;&gt;&lt;em&gt;register files&lt;/em&gt;&lt;/a&gt; on the chip. If you want a full breakdown of the core, you can check guesses &lt;a href=&quot;https://twitter.com/GPUsAreMagic/status/1256866465577394181&quot;&gt;here on Twitter&lt;/a&gt;, &lt;a href=&quot;https://www.realworldtech.com/forum/?threadid=191663&amp;amp;curpostid=191916&quot;&gt;on RWT&lt;/a&gt; and on &lt;a href=&quot;https://software.intel.com/sites/default/files/managed/5f/99/Skylake_core.jpg&quot;&gt;Intel’s forums&lt;/a&gt; (&lt;a href=&quot;https://software.intel.com/en-us/forums/software-tuning-performance-optimization-platform-monitoring/topic/852272&quot;&gt;thread&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg2/skx-full-small.jpg&quot; alt=&quot;SKL full&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-register-files&quot;&gt;The Register Files&lt;/h3&gt;

&lt;p&gt;Here’s a close-up of that section, with the assumed register files and their purpose labeled&lt;sup id=&quot;fnref:xmmetc&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:xmmetc&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg2/zoomed.png&quot; alt=&quot;SKL zoomed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We guess the register file identities based on:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The general purpose register files are of the right relative width (64 bits), and are in the right position below the integer execution units, and seem to have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EFLAGS&lt;/code&gt; nearby.&lt;/li&gt;
  &lt;li&gt;The &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; registers are obvious from their size and positioning underneath the vector pipes.&lt;/li&gt;
  &lt;li&gt;The upper 256 bits of the 512-bit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zmm&lt;/code&gt; registers (labelled ZMM on the closeup) can be determined from comparing the &lt;abbr title=&quot;Intel's Skylake (client) architecture, aka 6th Generation Intel Core i3,i5,i7&quot;&gt;SKL&lt;/abbr&gt;&lt;sup id=&quot;fnref:kbl&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:kbl&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; (no AVX-512) and &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt; (has AVX-512) dies and noting that the bottom file is not present in &lt;abbr title=&quot;Intel's Skylake (client) architecture, aka 6th Generation Intel Core i3,i5,i7&quot;&gt;SKL&lt;/abbr&gt; (a large empty area is present at that spot in &lt;abbr title=&quot;Intel's Skylake (client) architecture, aka 6th Generation Intel Core i3,i5,i7&quot;&gt;SKL&lt;/abbr&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;the-mystery-block&quot;&gt;The Mystery Block&lt;/h3&gt;

&lt;p&gt;This leaves the mystery block in red. This block is in a prime spot below the vector execution units. Could it be the mask registers (kregs)? We found in the &lt;a href=&quot;/blog/2019/12/05/kreg-facts.html&quot;&gt;first post&lt;/a&gt; that the mask aren’t shared with either the scalar or &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; registers, so we expect them to have their own physical register file. Maybe this is it?&lt;/p&gt;

&lt;p&gt;Let’s compare the mystery register file to the integer register file, since they should be similar in size and appear to be implemented similarly:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg2/compare.png&quot; alt=&quot;SKL zoomed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Looking at the general purpose register file on the left, each block (6 of which are numbered on the general purpose file) seems to implement 16 bits, as if you zoom in you see a repeating structure of 16 elements, and 4 blocks makes 64 bits total which is the expected width of the file. We know from published numbers that the integer register file has 180 entries, and since there are 6 rows of 4 blocks, we expect each row to implement 180 / 6 = 30 registers.&lt;/p&gt;

&lt;p&gt;Now we turn our attention to the mystery file, with the idea that it may be the mask register file. There are a total of 30 blocks. Looking at the general purpose registers, we determined each block can hold 16 bits (horizontally) from 30 registers (vertically, I guess). So 30 blocks gives us: 30 blocks * 30 registers/block * 16 bits / 64 bits = 225 registers. It’s too much! We calculated last time that there are ~142 physical mask registers, so this is way too high.&lt;/p&gt;

&lt;p&gt;There’s another problem: we only have three columns of 16-bit blocks, for a total of 48 bits, horizontally. However, we know that a mask register must hold up to 64 bits (when using a byte-wise mask for a full 512-bit vector register). Also, while our calculation above worked out to a whole number, the number of blocks (30) is not divisible by 4, so even if you assumed the arrangement of the blocks didn’t matter, there is no possible mapping from each register to 4 distinct blocks. Instead, we’d need something weird like 2 blocks providing 15 registers (instead of 30), but 64 bits wide (instead of 32). That seems very unlikely.&lt;/p&gt;

&lt;p&gt;So let’s look just at the two paired columns on the left for now: a total of 20 blocks. If we take the &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; registers as an example, it is not necessary that the full width of the register is present horizontally in a single row: the &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; registers have only 256 bits in a row (split into two 128-bit lines), and then other other 256 bits in a 512-bit zmm register appear vertically below, in the register file marked ZMM in the diagram. So there’s a kind of over-under arrangement&lt;sup id=&quot;fnref:overunder&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:overunder&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Since the mask registers are associated with elements of the vector registers, maybe they are split up in the same way? That is, a 64-bit mask register uses one 2x16-bit (32-bit) chunk from the top half and one from the bottom half, to make up 64 bits? This is 20 total blocks, giving 150 registers by the same calculation above. This is much closer to the 142 we found by experiment.&lt;/p&gt;

&lt;p&gt;Still… that nagging feeling. 142 is not equal to 150, and what about that third column of blocks? That doubt crept in: I had second thoughts that this was the mask register file after all. What could it be then?&lt;/p&gt;

&lt;h3 id=&quot;lets-get-legacy&quot;&gt;Let’s Get Legacy&lt;/h3&gt;

&lt;p&gt;I realized there was one register file unaccounted for: the file for legacy x87 floating point and MMX. We expect that x87 floating point and MMX use the the &lt;em&gt;same&lt;/em&gt; physical file because MMX registers are architecturally aliased onto the x87 registers&lt;sup id=&quot;fnref:why&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:why&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;. So where is &lt;em&gt;this&lt;/em&gt; file on the die? I looked all around&lt;sup id=&quot;fnref:lied&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:lied&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; the die shot. There are no good candidates.&lt;/p&gt;

&lt;p&gt;So maybe &lt;em&gt;this&lt;/em&gt; thing we’ve been looking at is actually the x87/MMX register file? In one way it’s a better fit: the x87 FP register file needs to be ~80 bits wide, so that would explain the extra column: if we assume each row is half of a register as before, that’s 96 bits. That’s enough to hold 80 bit extended precision values, and the 16 bits left over are probably could be used to store the FPU status word accessed by &lt;a href=&quot;https://www.felixcloutier.com/x86/fstsw:fnstsw&quot;&gt;ftstw&lt;/a&gt; and related instructions. This status word is updated after every operation so must &lt;em&gt;also&lt;/em&gt; be renamed for reasonable performance&lt;sup id=&quot;fnref:intflags&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:intflags&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Additional evidence that this might be the x87/MMX register file comes from this &lt;a href=&quot;https://flic.kr/p/YhuBWc&quot;&gt;&lt;abbr title=&quot;Intel's Kaby Lake client CPU architecture (7th, 8th gen): substantially identical to Skylake&quot;&gt;KBL&lt;/abbr&gt; die shot&lt;/a&gt; also from Fritz:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg2/kbl-compare.png&quot; alt=&quot;Kaby Lake&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note that while the high 256 bits of the register file are masked out (this chip supports only AVX2, not AVX-512 so there are no &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zmm&lt;/code&gt; registers), the register file we are considering is present in its entirety.&lt;/p&gt;

&lt;p&gt;Cool theory bro, but aren’t we back to square zero? If this is the file for the x87/MMX registers, where do the mask registers live?&lt;/p&gt;

&lt;p&gt;There’s one possibility we haven’t discussed although some of you might be screaming it at your monitors by now: maybe the x87/MMX and the kreg register files are &lt;em&gt;shared&lt;/em&gt;. That is, physically aliased&lt;sup id=&quot;fnref:aliasing&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:aliasing&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt; to the same register file, shared competitively.&lt;/p&gt;

&lt;h3 id=&quot;testing-our-theory&quot;&gt;Testing Our Theory&lt;/h3&gt;

&lt;p&gt;The good news? We can test for this, in software. That’s good, because I was never really &lt;em&gt;that&lt;/em&gt; comfortable with this die shot thing and there was the risk that I would BS more than usual. Software-based &lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt; probing is a bit more my thing.&lt;/p&gt;

&lt;p&gt;We’ll use the test method originally &lt;a href=&quot;http://blog.stuffedcow.net/2013/05/measuring-rob-capacity/&quot;&gt;described by Henry Wong&lt;/a&gt; and which we used in the &lt;a href=&quot;/blog/2019/12/05/kreg-facts.html&quot;&gt;last post&lt;/a&gt; on this topic, and implemented in the &lt;a href=&quot;https://github.com/travisdowns/robsize&quot;&gt;robsize&lt;/a&gt; tool. Here’s the quick description of the technique, a straight copy/paste from that post:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;We separate two cache miss load instructions by a variable number of &lt;em&gt;filler instructions&lt;/em&gt; which vary based on the CPU resource we are &amp;gt; probing. When the number of filler instructions is small enough, the two cache misses execute in parallel and their latencies are overlapped so the &amp;gt; total execution time is roughly as long as a single miss.&lt;/p&gt;

  &lt;p&gt;However, once the number of filler instructions reaches a critical threshold, all of the targeted resource are consumed and instruction allocation &amp;gt; stalls before the second miss is issued and so the cache misses can no longer run in parallel. This causes the runtime to spike to about twice the &amp;gt; baseline cache miss latency.&lt;/p&gt;

  &lt;p&gt;Finally, we ensure that each filler instruction consumes exactly one of the resource we are interested in, so that the location of the spike indicates the size of the underlying resource. For example, regular &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; instructions usually consume one physical register from the &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; so are a good choice to measure the size of that resource.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The trick we use to see if two register files are shared is first to use a test the size of each register file alone, using a test that uses filler that targets only that register file, then to run a third test whose filler &lt;em&gt;alternates&lt;/em&gt; between instructions that use each register file. If the register files are shared, we expect all tests to produce the same results, since they are all drawing from the same pool. If the register files are not shared, the third (alternating) test should result in a much higher apparent resource limit, since two different pools are being drawn from and so it will take twice as many&lt;sup id=&quot;fnref:roblimit&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:roblimit&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt; filler instructions to hit the RF limit.&lt;/p&gt;

&lt;p&gt;Enough talk, let’s do this. I implemented several new tests in robsize to probe possible register sharing. First, we look at &lt;strong&gt;Test 38&lt;/strong&gt;, which uses MMX instructions&lt;sup id=&quot;fnref:whymmx&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:whymmx&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt; to target the size of the x87/MMX register file:&lt;/p&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#skx-38&quot; id=&quot;skx-38&quot;&gt;[link to this chart]&lt;/a&gt; 
    
    &lt;a href=&quot;https://github.com/travisdowns/robsize/tree/master/scripts/kreg/results2/skx-38.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/kreg2/skx-38.svg&quot; alt=&quot;Test 38&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;We see a clear spike at 128 instructions, so it seems like the size of the speculative&lt;sup id=&quot;fnref:spec&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:spec&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt; x87/MMX register file is 128 entries.&lt;/p&gt;

&lt;p&gt;Next, we have &lt;strong&gt;Test 43&lt;/strong&gt; which follows the same pattern as &lt;strong&gt;Test 38&lt;/strong&gt; but using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd&lt;/code&gt; as a filler instruction so targets the mask (kreg) register file:&lt;/p&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#skx-43&quot; id=&quot;skx-43&quot;&gt;[link to this chart]&lt;/a&gt; 
    
    &lt;a href=&quot;https://github.com/travisdowns/robsize/tree/master/scripts/kreg/results2/skx-43.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/kreg2/skx-43.svg&quot; alt=&quot;Test 43&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;This is mostly indistinguishable from the previous chart and we conclude that the size of the speculative mask register file is also 128.&lt;/p&gt;

&lt;p&gt;Let’s see what happens when alternate MMX and another instruction type. &lt;strong&gt;Test 39&lt;/strong&gt; alternates MMX with integer &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instructions, and &lt;strong&gt;Test 40&lt;/strong&gt; alternatives with general purpose scalar instructions:&lt;/p&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#skx-39&quot; id=&quot;skx-39&quot;&gt;[link to this chart]&lt;/a&gt; 
    
    &lt;a href=&quot;https://github.com/travisdowns/robsize/tree/master/scripts/kreg/results2/skx-39.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/kreg2/skx-39.svg&quot; alt=&quot;Test 39&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#skx-40&quot; id=&quot;skx-40&quot;&gt;[link to this chart]&lt;/a&gt; 
    
    &lt;a href=&quot;https://github.com/travisdowns/robsize/tree/master/scripts/kreg/results2/skx-40.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/kreg2/skx-40.svg&quot; alt=&quot;Test 40&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Both of these show the same effect: the effective resource limitation is much higher: around 210 filler instructions. This indicates strongly that the x87/MMX register is not shared with either the &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; or scalar register files.&lt;/p&gt;

&lt;p&gt;Finally, we get to the end of this tale, &lt;strong&gt;Test 41&lt;/strong&gt;. This test mixes MMX and mask register instructions&lt;sup id=&quot;fnref:test41&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:test41&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#skx-41&quot; id=&quot;skx-41&quot;&gt;[link to this chart]&lt;/a&gt; 
    
    &lt;a href=&quot;https://github.com/travisdowns/robsize/tree/master/scripts/kreg/results2/skx-41.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/kreg2/skx-41.svg&quot; alt=&quot;Test 41&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;This one is definitely not like the others. We see that the resource limit is now 128, same as for the single-type tests. We can immediately conclude that this means that mask registers and MMX registers are allocated from the same resource pool: &lt;em&gt;they use the same physical register file&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This resolves the mystery of the missing register file: nothing is missing but rather this one register file simply serves double duty.&lt;/p&gt;

&lt;p&gt;Normally a shared register file might be something to watch out for, performance-wise, but it is hard to imagine this having an impact in any non-artificial example. Who is going to be making heavy use of x87 or MMX (both obsolete) along with AVX-512 mask registers (the opposite end of the spectrum from “obsolete”)? It seems extremely unlikely. In any case, the register file is still quite large so hitting the limit is unlikely in any case.&lt;/p&gt;

&lt;p&gt;So sharing these register files is a neat trick to reduce power and area: the register files aren’t all that big, but they live in pretty prime real-estate close to the execution units.&lt;/p&gt;

&lt;p&gt;What’s cool about this one though is that is the first time that I’ve &lt;em&gt;looked at a chip&lt;/em&gt; (that this is even possible is remarkable to me) and come up with a theory about the hardware we can test and confirm with a targeted microbenchmark. Here, it actually happened that way. I was already aware of the possibility of register file sharing (Henry had tests for this right in robsize from the start) – but although I considered other sharing scenarios I never considered sharing between x87/MMX and the mask registers until I tried to identify the register files on Franz’s die shots.&lt;/p&gt;

&lt;h2 id=&quot;some-missing-pieces&quot;&gt;Some Missing Pieces&lt;/h2&gt;

&lt;p&gt;It seems like we’ve wrapped everything up nicely, but there are still a few rough edges.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We calculated a total of 128 speculative registers, plus 16 non-speculative (to hold the 8 x87/MMX regs and the 8 kregs) is 144, but our ballpark estimate based on the regfile size was 150. Perhaps more importantly, with 5 rows of registers, we expect the number of registers to be a multiple of 5. Perhaps there are a handful of registers used from an unknown purpose or some other flaw in the test.&lt;/li&gt;
  &lt;li&gt;I noticed an unexplained different in results between a test that uses a single instruction like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd k1, k2, k3&lt;/code&gt; (test 27) and one that rotates through all the 8 registers: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd k0, k1, k1&lt;/code&gt; then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd k1, k2, k2&lt;/code&gt;, etc (test 43). The former test results in an register file size of about 5 more than the latter. Similarly for tests using the MMX registers (compare tests 37 and 38). This post uses the rotate through all registers approach, while the original post used the fixed register variant in some cases so the number vary slightly. I have some theories but no definite explanation for this behavior.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;thanks&quot;&gt;Thanks&lt;/h2&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://www.flickr.com/people/130561288@N04/&quot;&gt;Fritzchens Fritz&lt;/a&gt; who created the die shots analyzed here, and who graciously put them into the public domain.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.stuffedcow.net/&quot;&gt;Henry Wong&lt;/a&gt; who wrote the &lt;a href=&quot;http://blog.stuffedcow.net/2013/05/measuring-rob-capacity/&quot;&gt;original article&lt;/a&gt; which introduced me to this technique and subsequently shared the code for his tool, which is now &lt;a href=&quot;https://github.com/travisdowns/robsize&quot;&gt;hosted on github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/GPUsAreMagic&quot;&gt;Nemez&lt;/a&gt; who did a &lt;a href=&quot;https://twitter.com/GPUsAreMagic/status/1256866465577394181&quot;&gt;breakdown&lt;/a&gt; of the die shot, noting the register file in question as some type of integer register file, which originally piqued my curiosity.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://lemire.me&quot;&gt;Daniel Lemire&lt;/a&gt; who provided access to the &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt; hardware used in this post.&lt;/p&gt;

&lt;p&gt;Thanks to Matt Godbolt and Vijay who pointed out typos in the text.&lt;/p&gt;

&lt;h2 id=&quot;discussion-and-feedback&quot;&gt;Discussion and Feedback&lt;/h2&gt;

&lt;p&gt;If you have something to say, leave a comment below or discuss this article on &lt;a href=&quot;https://news.ycombinator.com/item?id=23309034&quot;&gt;Hacker News&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Feedback is also warmly welcomed by &lt;a href=&quot;mailto:travis.downs@gmail.com&quot;&gt;email&lt;/a&gt; or as &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io/issues&quot;&gt;a GitHub issue&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:bar&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Admittedly, “how many physical mask registers does the CPU have” is probably not a very high bar of interestingness to clear, to most people. &lt;a href=&quot;#fnref:bar&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:xmmetc&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The zmm, ymm and xmm registers all overlap, architecturally. That is, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xmm0&lt;/code&gt; is just the bottom 128 bits of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ymm0&lt;/code&gt;, and similarly for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ymm0&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zmm0&lt;/code&gt;. Physically, there are really &lt;em&gt;only&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zmm&lt;/code&gt; registers and the other two are simply specific ranges of bits of those larger register. So the area marked &lt;strong&gt;YMM&lt;/strong&gt; on the die shot really means: &lt;em&gt;the upper parts of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ymm&lt;/code&gt; registers which are not part of the corresponding xmm register&lt;/em&gt;. &lt;a href=&quot;#fnref:xmmetc&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:kbl&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Actually Kaby Lake, since the best die shots we have are from that chip, but it’s the same thing. &lt;a href=&quot;#fnref:kbl&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:overunder&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Incidentally, this lines up with an inspection of the execution units, which seem to have the same over-under arrangemnet: the port 5 FMA for example, looks like it has has two rows each with 4x 64-bit FMA units, rather than say a single row with 8 units. &lt;a href=&quot;#fnref:overunder&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:why&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;As a trick, I guess, to allow MMX registers to be saved and restored by operating systems and other code that weren’t aware of their presence. A similar mess occurred with the transition from SSE to AVX, where code unaware of AVX could accidentally clobber the upper part of AVX registers using SSE instructions (if SSE zeroed the upper bits), so instead we get the ongoing issue with &lt;a href=&quot;https://stackoverflow.com/questions/41303780/why-is-this-sse-code-6-times-slower-without-vzeroupper-on-skylake&quot;&gt;legacy SSE and dirty uppers&lt;/a&gt;. &lt;a href=&quot;#fnref:why&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:lied&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This is a lie: I didn’t really look around &lt;em&gt;all around&lt;/em&gt; the die: I looked near by the execution units were the register file would be with very high probability. &lt;a href=&quot;#fnref:lied&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:intflags&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The integer flags (so-called &lt;em&gt;EFLAGS&lt;/em&gt; register) also need to be renamed and I believe they pull a similar trick: writing their results to the same physical register allocated for the result: I’ve marked the file that I think holds the so-called &lt;em&gt;SPAZO&lt;/em&gt; group on the zoomed view, and the C flag may be stored in the same place or in the thin (single bit?) file immediately to the right of the &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; file. &lt;a href=&quot;#fnref:intflags&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:aliasing&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I talk of &lt;em&gt;physical&lt;/em&gt; aliasing here, to distinguish it from the logical/architectural aliasing. Logical aliasing is that which is visible to software: the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ymm&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xmm&lt;/code&gt; registers are logically aliased in that writes to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xmm0&lt;/code&gt; show up in the low bits of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ymm0&lt;/code&gt;. Similarly, the MMX and x87 register files are aliased in that writes to MMX register modify values in the FP register stack, although the rules are more complicated. Logical aliasing usually implies physical aliasing, but not the other way around. Physical aliasing, then, means that two register sets are renamed onto the same pool of physical registers, but this is usually invisible to software (except though careful performance tests, as we do here). &lt;a href=&quot;#fnref:aliasing&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:roblimit&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In practice, you don’t actually get all the way to 2x: you hit something close to the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; limit instead first. &lt;a href=&quot;#fnref:roblimit&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:whymmx&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I use MMX rather than x87 so I don’t have to deal with the x87 FP stack abstraction and understand how that maps to renaming. &lt;a href=&quot;#fnref:whymmx&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:spec&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The &lt;em&gt;speculative&lt;/em&gt; register file because we expect some entries also to be used to hold the non-speculative values of the architectural registers. We’ll return to this point in a moment. &lt;a href=&quot;#fnref:spec&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:test41&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Specifically, it mixes the same &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;por&lt;/code&gt; instructions we used in the single-type tests &lt;strong&gt;Test 38&lt;/strong&gt; and &lt;strong&gt;Test 43&lt;/strong&gt;. &lt;a href=&quot;#fnref:test41&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Travis Downs</name><email>travis.downs@gmail.com</email></author><category term="blog" /><category term="Intel" /><category term="x86" /><category term="uarch" /><category term="avx512" /><summary type="html">Taking a second look at the newly introduced mask registers, this time with the benefit of a SKX die shot from Fritzchens Fritz.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://travisdowns.github.io/assets/kreg2/zoomed.png" /><media:content medium="image" url="https://travisdowns.github.io/assets/kreg2/zoomed.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Ice Lake Store Elimination</title><link href="https://travisdowns.github.io/blog/2020/05/18/icelake-zero-opt.html" rel="alternate" type="text/html" title="Ice Lake Store Elimination" /><published>2020-05-18T00:00:00+00:00</published><updated>2020-05-18T00:00:00+00:00</updated><id>https://travisdowns.github.io/blog/2020/05/18/icelake-zero-opt</id><content type="html" xml:base="https://travisdowns.github.io/blog/2020/05/18/icelake-zero-opt.html">&lt;!-- boilerplate 
page.assets: /assets/intel-zero-opt
assetpath: /assets/intel-zero-opt
tablepath: /misc/tables//intel-zero-opt
--&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;If you made it down to the &lt;a href=&quot;/blog/2020/05/13/intel-zero-opt.html#hardware-survey&quot;&gt;hardware survey&lt;/a&gt; on the last post, you might have &lt;a href=&quot;https://twitter.com/tarlinian/status/1260629853000265728&quot;&gt;wondered&lt;/a&gt; where Intel’s newest mainstream architecture was. &lt;em&gt;Ice Lake was missing!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Well good news: it’s here… and it’s interesting. We’ll jump right into the same analysis we did last time for Skylake client. If you haven’t read the &lt;a href=&quot;/blog/2020/05/13/intel-zero-opt.html&quot;&gt;first article&lt;/a&gt; you’ll probably want to start there, because we’ll refer to concepts introduced there without reexplaining them here.&lt;/p&gt;

&lt;p&gt;As usual, you can skip to the &lt;a href=&quot;#summary&quot;&gt;summary&lt;/a&gt; for the bite sized version of the findings.&lt;/p&gt;

&lt;h2 id=&quot;icl-results&quot;&gt;ICL Results&lt;/h2&gt;

&lt;h3 id=&quot;the-compiler-has-an-opinion&quot;&gt;The Compiler Has an Opinion&lt;/h3&gt;

&lt;p&gt;Let’s first take a look at the overall performance: facing off &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill0&lt;/code&gt; vs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill1&lt;/code&gt; as we’ve been doing for every microarchitecture. Remember, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill0&lt;/code&gt; fills a region with zeros, while &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill1&lt;/code&gt; fills a region with the value one (as a 4-byte &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;).&lt;/p&gt;

&lt;p class=&quot;warning&quot;&gt;All of these tests run at 3.5 GHz. The max single-core turbo for this chip is at 3.7 GHz, but is difficult to run in a sustained manner at this frequency, because of AVX-512 clocking effects and because other cores occasionally activate. 3.5 GHz is a good compromise that keeps the chip running at the same frequency, while remaining close to the ideal turbo. Disabling turbo is not a good option, because this chip runs at 1.1 GHz without turbo, which would introduce a large distortion when exercising the uncore and RAM.&lt;/p&gt;

&lt;center&gt;&lt;strong&gt;Figure 7a&lt;/strong&gt;&lt;/center&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig7a&quot; id=&quot;fig7a&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig7a.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/icl512/overall-warm.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig7a.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig7a.svg&quot; alt=&quot;Figure 7a&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Actually, I lied. &lt;em&gt;This&lt;/em&gt; is the right plot for Ice Lake:&lt;/p&gt;

&lt;center&gt;&lt;strong&gt;Figure 7b&lt;/strong&gt;&lt;/center&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig7b&quot; id=&quot;fig7b&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig7b.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/icl/overall-warm.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig7b.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig7b.svg&quot; alt=&quot;Figure 7b&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Well, which is it?&lt;/p&gt;

&lt;p&gt;Those two have a couple of key differences. The first is this weird thing that &lt;strong&gt;Figure 7a&lt;/strong&gt; has going on in the right half of the L1 region: there are two obvious and distinct performance levels visible, each with roughly half the samples.&lt;/p&gt;

&lt;!-- https://stackoverflow.com/questions/43806515/position-svg-elements-over-an-image --&gt;
&lt;style&gt;
.img-overlay-wrap {
  position: relative;
  display: block; /* &lt;= shrinks container to image size */
}

.img-overlay-wrap svg {
  position: absolute;
  top: 0;
  left: 0;
}
&lt;/style&gt;

&lt;div class=&quot;img-overlay-wrap&quot;&gt;
  &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig7a.svg&quot; alt=&quot;Figure 7a Annotated&quot; /&gt;
  &lt;svg viewBox=&quot;0 0 90 60&quot;&gt;
    &lt;g stroke-width=&quot;.5&quot; fill=&quot;none&quot; opacity=&quot;0.5&quot;&gt;
      &lt;ellipse transform=&quot;rotate(-25 34 10)&quot; cx=&quot;34&quot; cy=&quot;10&quot; rx=&quot;12&quot; ry=&quot;5&quot; stroke=&quot;green&quot; /&gt;
      &lt;ellipse transform=&quot;rotate(-25 34 34.5)&quot; cx=&quot;34&quot; cy=&quot;34.5&quot; rx=&quot;12&quot; ry=&quot;5&quot; stroke=&quot;red&quot; /&gt;
    &lt;/g&gt;
  &lt;/svg&gt;
&lt;/div&gt;

&lt;p&gt;The second thing is that while both of the plots show &lt;em&gt;some&lt;/em&gt; of the zero optimization effect in the L3 and RAM regions, the effect is &lt;em&gt;much larger&lt;/em&gt; in &lt;strong&gt;Figure 7b&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;img-overlay-wrap&quot;&gt;
  &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig7b.svg&quot; alt=&quot;Figure 7a Annotated&quot; /&gt;
  &lt;svg viewBox=&quot;0 0 90 60&quot;&gt;
    &lt;g stroke-width=&quot;.5&quot; fill=&quot;none&quot; opacity=&quot;0.5&quot;&gt;
      &lt;ellipse cx=&quot;63&quot; cy=&quot;40&quot; rx=&quot;10&quot; ry=&quot;8&quot; stroke=&quot;blue&quot; /&gt;
    &lt;/g&gt;
  &lt;/svg&gt;
&lt;/div&gt;

&lt;p&gt;So what’s the difference between these two plots? The top one was compiled with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-march=native&lt;/code&gt;, the second with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-march=icelake-client&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since I’m compiling this &lt;em&gt;on&lt;/em&gt; the Ice Lake client system, I would expect these to do the same thing, but for &lt;a href=&quot;https://twitter.com/stdlib/status/1261038662751522826&quot;&gt;some reason they don’t&lt;/a&gt;. The primary difference is that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-march=native&lt;/code&gt; &lt;a href=&quot;https://godbolt.org/z/gm3vRa&quot;&gt;generates&lt;/a&gt; 512-bit instructions like so (for the main loop):&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.L4:&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;         &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;512&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;448&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;384&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;320&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;jne&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;.L4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-march=icelake-client&lt;/code&gt; uses 256-bit instructions&lt;sup id=&quot;fnref:still512&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:still512&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.L4:&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;96&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;160&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;vmovdqu32&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;224&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;jne&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;.L4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Most compilers use 256-bit instructions by default even for targets that support AVX-512 (reason: &lt;a href=&quot;https://reviews.llvm.org/D67259&quot;&gt;downclocking&lt;/a&gt;, so the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-march=native&lt;/code&gt; version is the weird one here. All of the earlier x86 tests used 256-bit instructions.&lt;/p&gt;

&lt;p&gt;The observation that &lt;strong&gt;Figure 7a&lt;/strong&gt; results from running 512-bit instructions, combined with a peek at the data lets us immediately resolve the mystery of the bi-modal behavior.&lt;/p&gt;

&lt;p&gt;Here’s the raw data for the 17 samples at a buffer size of 9864:&lt;/p&gt;

&lt;table border=&quot;1&quot; class=&quot;dataframe&quot; style=&quot;max-width:500px; font-size:80%;&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th colspan=&quot;2&quot; halign=&quot;left&quot;&gt;GB/s&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;Size&lt;/th&gt;
      &lt;th&gt;Trial&lt;/th&gt;
      &lt;th&gt;fill0&lt;/th&gt;
      &lt;th&gt;fill1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;17&quot; valign=&quot;top&quot;&gt;9864&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;92.3&lt;/td&gt;
      &lt;td&gt;92.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;91.9&lt;/td&gt;
      &lt;td&gt;91.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;91.9&lt;/td&gt;
      &lt;td&gt;91.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;92.4&lt;/td&gt;
      &lt;td&gt;92.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;92.0&lt;/td&gt;
      &lt;td&gt;92.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;92.1&lt;/td&gt;
      &lt;td&gt;92.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;td&gt;92.0&lt;/td&gt;
      &lt;td&gt;92.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;92.3&lt;/td&gt;
      &lt;td&gt;92.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;td&gt;92.2&lt;/td&gt;
      &lt;td&gt;92.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;9&lt;/th&gt;
      &lt;td&gt;92.0&lt;/td&gt;
      &lt;td&gt;92.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;10&lt;/th&gt;
      &lt;td&gt;183.3&lt;/td&gt;
      &lt;td&gt;93.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;11&lt;/th&gt;
      &lt;td&gt;197.3&lt;/td&gt;
      &lt;td&gt;196.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12&lt;/th&gt;
      &lt;td&gt;197.3&lt;/td&gt;
      &lt;td&gt;196.6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;13&lt;/th&gt;
      &lt;td&gt;196.6&lt;/td&gt;
      &lt;td&gt;197.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;14&lt;/th&gt;
      &lt;td&gt;197.3&lt;/td&gt;
      &lt;td&gt;196.6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;15&lt;/th&gt;
      &lt;td&gt;196.6&lt;/td&gt;
      &lt;td&gt;197.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;16&lt;/th&gt;
      &lt;td&gt;196.6&lt;/td&gt;
      &lt;td&gt;196.6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The performance follows a specific pattern with respect to the trials for both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill0&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill1&lt;/code&gt;: it starts out slow (about 90 GB/s) for the first 9-10 samples then suddenly jumps up the higher performance level (close to 200 GB/s). It turns out this is just &lt;a href=&quot;/blog/2020/01/17/avxfreq1.html&quot;&gt;voltage and frequency management&lt;/a&gt; biting us again. In this case there is no frequency change: the &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/blob/post2/results/icl512/overall-warm.csv#L546&quot;&gt;raw data&lt;/a&gt; has a frequency column that shows the trials always run at 3.5 GHz. There is only a voltage change, and while the voltage is changing, the CPU runs with reduced dispatch throughput&lt;sup id=&quot;fnref:iclbetter&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:iclbetter&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;The reason this effect repeats for every new set of trials (new buffer size value) is that each new set of trials is preceded by a 100 ms spin wait: this spin wait doesn’t run any AVX-512 instructions, so the CPU drops back to the lower voltage level and this process repeats. The effect stops when the benchmark moves into the L2 region, because there it is slow enough that the 10 discarded warmup trials are enough to absorb the time to switch to the higher voltage level.&lt;/p&gt;

&lt;p&gt;We can avoid this problem simply by removing the 100 ms warmup (passing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--warmup-ms=0&lt;/code&gt; to the benchmark), and for the rest of this post we’ll discuss the no-warmup version (we keep the 10 warmup &lt;em&gt;trials&lt;/em&gt; and they should be enough).&lt;/p&gt;

&lt;h2 id=&quot;elimination-in-ice-lake&quot;&gt;Elimination in Ice Lake&lt;/h2&gt;

&lt;p&gt;So we’re left with the second effect, which is that the 256-bit store version shows &lt;em&gt;very&lt;/em&gt; effective elimination, as opposed to the 512-bit version. For now let’s stop picking favorites between 256 and 512 (push that on your stack, we’ll get back to it), and just focus on the elimination behavior for 256-bit stores.&lt;/p&gt;

&lt;p&gt;Here’s the closeup of the L3 region for the 256-bit store version, showing also the L2 eviction type, as discussed in the previous post:&lt;/p&gt;

&lt;center&gt;&lt;strong&gt;Figure 8&lt;/strong&gt;&lt;/center&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig8&quot; id=&quot;fig8&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig8.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/icl/l2-focus.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig8.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig8.svg&quot; alt=&quot;Figure 8&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;We finally have the elusive (near) 100% elimination of redundant zero stores! The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill0&lt;/code&gt; case peaks at 96% silent (eliminated&lt;sup id=&quot;fnref:stricly&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:stricly&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;) evictions. Typical L3 bandwidth is ~59 GB/s with elimination and ~42 GB/s without, for a better than 40% speedup! So this is a potentially a big deal on Ice Lake.&lt;/p&gt;

&lt;p&gt;Like last time, we can also check the uncore tracker performance counters, to see what happens for larger buffers which would normally write back to memory.&lt;/p&gt;

&lt;center&gt;&lt;strong&gt;Figure 9&lt;/strong&gt;&lt;/center&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig9&quot; id=&quot;fig9&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig9.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/icl/l3-focus.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig9.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig9.svg&quot; alt=&quot;Figure 9&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt; the way to interpret the events in this plot is the reverse of the above: more uncore tracker writes means &lt;em&gt;less&lt;/em&gt; elimination, while in the earlier chart more silent writebacks means &lt;em&gt;more&lt;/em&gt; elimination (since every silent writeback replaces a non-silent one).&lt;/p&gt;

&lt;p&gt;As with the L3 case, we see that the store elimination appears 96% effective: the number of uncore to memory writebacks flatlines at 4% for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill0&lt;/code&gt; case. Compare this to &lt;a href=&quot;/assets/intel-zero-opt/fig3.svg&quot;&gt;&lt;strong&gt;Figure 3&lt;/strong&gt;&lt;/a&gt;, which is the same benchmark running on Skylake-S, and note that only half the writes to RAM are eliminated.&lt;/p&gt;

&lt;p&gt;This chart also includes results for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alt01&lt;/code&gt; benchmark. Recall that this benchmark writes 64 bytes of zeros alternating with 64 bytes of ones. This means that, at best, only half the lines can be eliminated by zero-over-zero elimination. On Skylake-S, only about 50% of eligible (zero) lines were eliminated, but here we again get to 96% elimination! That is, in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alt01&lt;/code&gt; case, 48% of all writes were eliminated, half of which are all-ones and not eligible.&lt;/p&gt;

&lt;p&gt;The asymptotic speedup for the all zero case for the RAM region is less than the L3 region, at about 23% but that’s still not exactly something to sneeze at. The speedup for the alternating case is 10%, somewhat less than half the benefit of the all zero case&lt;sup id=&quot;fnref:altwrites&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:altwrites&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;. In the L3 region, we also note that the benefit of elimination for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alt01&lt;/code&gt; is only about 7%, much smaller than the ~20% benefit you’d expect if you cut the 40% benefit the all-zeros case sees. We saw a similar effect in Skylake-S.&lt;/p&gt;

&lt;p&gt;Finally it’s worth noting this little uptick in uncore writes in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill0&lt;/code&gt; case:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/intel-zero-opt/little-uptick.png&quot; alt=&quot;Little Uptick&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This happens right around the transition from L3 to RAM, and this, the writes flatline down to 0.04 per line, but this uptick is fairly consistently reproducible. So there’s some interesting effect there, probably, perhaps related to the adaptive nature of the L3 caching&lt;sup id=&quot;fnref:l3adapt&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:l3adapt&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h3 id=&quot;512-bit-stores&quot;&gt;512-bit Stores&lt;/h3&gt;

&lt;p&gt;If we rewind time, time to pop the mental stack and return to something we noticed earlier: that 256-bit stores seemed to get superior performance for the L3 region compared to 512-bit ones.&lt;/p&gt;

&lt;p&gt;Remember that we ended up with 256-bit and 512-bit versions due to unexpected behavior in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-march&lt;/code&gt; flag. Rather they &lt;em&gt;relying&lt;/em&gt; on this weirdness&lt;sup id=&quot;fnref:gccfix&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:gccfix&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;, let’s just write slighly lazy&lt;sup id=&quot;fnref:lazy&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:lazy&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt; &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/blob/master/algos.cpp#L151&quot;&gt;methods&lt;/a&gt; that explicitly use 256-bit and 512-bit stores but are otherwise identical. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill256_0&lt;/code&gt; uses 256-bit stores and writes zeros, and I’ll let you pattern match the rest of the names.&lt;/p&gt;

&lt;p&gt;Here’s how they perform on my ICL hardware:&lt;/p&gt;

&lt;center&gt;&lt;strong&gt;Figure 10&lt;/strong&gt;&lt;/center&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig10&quot; id=&quot;fig10&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig10.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/icl/256-512.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig10.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig10.svg&quot; alt=&quot;Figure 10&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p class=&quot;warning&quot;&gt;This chart shows only the the median of 17 trials. You can look at the raw data for an idea of the trial variance, but it is generally low.&lt;/p&gt;

&lt;p&gt;In the L1 region, the 512-bit approach usually wins and there is no apparent difference between writing 0 or 1 (the two halves of the moon mostly line up). Still, 256-bit stores are roughly &lt;em&gt;competitive&lt;/em&gt; with 512-bit: they aren’t running at half the throughput. That’s thanks to the second store port on Ice Lake. Without that feature, you’d be limited to 112 GB/s at 3.5 GHz, but here we handily reach ~190 GB/s with 256-bit stores, and ~195 GB/s with 512-bit stores. 512-bit stores probably have a slight advantage just because of fewer total instructions executed (about half of the 256-bit case) and associated second order effects.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Ice Lake has two &lt;em&gt;store ports&lt;/em&gt; which lets it execute two stores per cycle, but only a single cache line can be written per cycle. However, if two consecutive stores fall into the &lt;em&gt;same&lt;/em&gt; cache line, they will generally both be written in the same cycle. So the maximum sustained throughput is up to two stores per cycle, &lt;em&gt;if&lt;/em&gt; they fall in the same line&lt;sup id=&quot;fnref:l1port&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:l1port&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;In the L2 region, however, the 256-bit approaches seem to pull ahead. This is a bit like the Buffalo Bills winning the Super Bowl: it just isn’t supposed to happen.&lt;/p&gt;

&lt;p&gt;Let’s zoom in:&lt;/p&gt;

&lt;center&gt;&lt;strong&gt;Figure 11&lt;/strong&gt;&lt;/center&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig11&quot; id=&quot;fig11&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig11.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/icl/256-512-l2-l3.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig11.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig11.svg&quot; alt=&quot;Figure 11&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;The 256-bit benchmarks start roughly tied with their 512 bit cousins, but then steadily pull away as the region approaches the full size of the L2. By the end of the L2 region, they have nearly a ~13% edge. This applies to &lt;em&gt;both&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill256&lt;/code&gt; versions – the zeros-writing and ones-writing flavors. So this effect doesn’t seem explicable by store elimination: we already know ones are not eliminated and, also, elimination only starts to play an obvious role when the region is L3-sized.&lt;/p&gt;

&lt;p&gt;In the L3, the situation changes: now the 256-bit version really pulls ahead, &lt;em&gt;but only the version that writes zeros&lt;/em&gt;. The 256-bit and 512-bit one-fill versions fall down in throughput, nearly to the same level (but the 256-bit version still seems &lt;em&gt;slightly but measurably ahead&lt;/em&gt; at ~2% faster). The 256-bit zero fill version is now ahead by roughly 45%!&lt;/p&gt;

&lt;p&gt;Let’s concentrate only on the two benchmarks that write zero: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill256_0&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill512_0&lt;/code&gt;, and turn on the L2 eviction counters (you probably saw that one coming by now):&lt;/p&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig12&quot; id=&quot;fig12&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig12.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/icl/256-512-l2-l3.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables//intel-zero-opt/fig12.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig12.svg&quot; alt=&quot;Figure 12&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p class=&quot;warning&quot;&gt;Only the &lt;em&gt;L2 Lines Out Silent&lt;/em&gt; event is shown – the balance of the evictions are &lt;em&gt;non-silent&lt;/em&gt; as usual.&lt;/p&gt;

&lt;p&gt;Despite the fact that I had to leave the right axis legend just kind floating around in the middle of the plot, I hope the story is clear: 256-bit stores get eliminated at the usual 96% rate, but 512-bit stores are hovering at a decidedly Skylake-like ~56%. I can’t be sure, but I expect this difference in store elimination largely explains the performance difference.&lt;/p&gt;

&lt;p&gt;I checked also the behavior with prefetching off, but the pattern is very similar, except with both approaches having reduced performance in L3 (you can &lt;a href=&quot;/assets/intel-zero-opt/fig12-nopf.svg&quot;&gt;see for yourself&lt;/a&gt;). It is interesting to note that for zero-over-zero stores, the 256-bit store performance &lt;em&gt;in L3&lt;/em&gt; is almost the same as the 512-bit store performance &lt;em&gt;in L2!&lt;/em&gt; It buys you almost a whole level in the cache hierarchy, performance-wise (in this benchmark).&lt;/p&gt;

&lt;p&gt;Normally I’d take a shot at guessing what’s going on here, but this time I’m not going to do it. I just don’t know&lt;sup id=&quot;fnref:lied&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:lied&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;. The whole thing is very puzzling, because everything after the L1 operates on a cache-line basis: we expect the fine-grained pattern of stores made by the core, &lt;em&gt;within a line&lt;/em&gt; to basically be invisible to the rest of the caching system which sees only full lines. Yet there is some large effect in the L3 and even in RAM&lt;sup id=&quot;fnref:RAM&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:RAM&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt; related to whether the core is writing a cache line in two 256-bit chunks or a single 512-bit chunk.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We have found that the store elimination optimization originally uncovered on Skylake client is still present in Ice Lake and is roughly twice as effective in our fill benchmarks. Elimination of 96% L2 writebacks (to L3) and L3 writebacks (to RAM) was observed, compared to 50% to 60% on Skylake. We found speedups of up to 45% in the L3 region and speedups of about 25% in RAM, compared to improvements of less than 20% in Skylake.&lt;/p&gt;

&lt;p&gt;We find that when zero-filling writes occur to a region sized for the L2 cache or larger, 256-bit writes are often significantly &lt;em&gt;faster&lt;/em&gt; than 512-bit writes. The effect is largest for the L2, where 256-bit zero-over-zero writes are up to &lt;em&gt;45% faster&lt;/em&gt; than 512-bit writes. We find a similar effect even for non-zeroing writes, but only in the L2.&lt;/p&gt;

&lt;h2 id=&quot;future&quot;&gt;Future&lt;/h2&gt;

&lt;p&gt;It is an interesting open question whether the as-yet-unreleased &lt;abbr title=&quot;The new 7nm microarchitecture used in Ice Lake CPUs.&quot;&gt;Sunny Cove&lt;/abbr&gt; server chips will exhibit this same optimization.&lt;/p&gt;

&lt;h2 id=&quot;advice&quot;&gt;Advice&lt;/h2&gt;

&lt;p&gt;Unless you are developing only for your own laptop, as of May 2020 Ice Lake is deployed on a microscopic fraction of total hosts you would care about, so the headline advice in the previous post applies: this optimization doesn’t apply to enough hardware for you to target it specifically. This might change in the future as Ice Lake and sequels roll out in force. In that case, the magnitude of the effect might make it worth optimizing for in some cases.&lt;/p&gt;

&lt;p&gt;For fine-grained advice, see the &lt;a href=&quot;/blog/2020/05/13/intel-zero-opt.html#tuning-advice&quot;&gt;list in the previous post&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;thanks&quot;&gt;Thanks&lt;/h2&gt;

&lt;p&gt;Vijay and Zach Wegner for pointing out typos.&lt;/p&gt;

&lt;p&gt;Ice Lake photo by &lt;a href=&quot;https://unsplash.com/@marcuslofvenberg&quot;&gt;Marcus Löfvenberg&lt;/a&gt; on Unsplash.&lt;/p&gt;

&lt;p&gt;Saagar Jha for helping me track down and fix a WebKit rendering &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io/issues/102&quot;&gt;issue&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;discussion-and-feedback&quot;&gt;Discussion and Feedback&lt;/h2&gt;

&lt;p&gt;If you have something to say, leave a comment below. There are also discussions on &lt;a href=&quot;https://twitter.com/trav_downs/status/1262428350511022081&quot;&gt;Twitter&lt;/a&gt; and &lt;a href=&quot;https://news.ycombinator.com/item?id=23225260&quot;&gt;Hacker News&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Feedback is also warmly welcomed by &lt;a href=&quot;mailto:travis.downs@gmail.com&quot;&gt;email&lt;/a&gt; or as &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io/issues&quot;&gt;a GitHub issue&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:still512&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;It’s actually still using the EVEX-encoded AVX-512 instruction &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vmovdqu32&lt;/code&gt;, which is somewhat more efficient here because AVX-512 has more compact encoding of offsets that are a multiple of the vector size (as they usually are). &lt;a href=&quot;#fnref:still512&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:iclbetter&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In this case, the throughput is only halved, versus the 1/4 throughput when we looked at dispatch throttling on &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt;, so based on this very preliminary result it seems like the dispatch throttling might be less severe in Ice Lake (this needs a deeper look: we never used stores to test on &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt;). &lt;a href=&quot;#fnref:iclbetter&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:stricly&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Strictly speaking, a silent writeback is a &lt;em&gt;sufficient&lt;/em&gt;, but not a &lt;em&gt;necessary&lt;/em&gt; condition for elimination, so it is a lower bound on the number of eliminated stores. For all I know, 100% of stores are eliminated, but out of those 4% are written back not-silently (but not in a modified state). &lt;a href=&quot;#fnref:stricly&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:altwrites&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;One reason could be that writing only alternating lines is somewhat more expensive than writing half the data but contiguously. Of course this is obviously true closer to the core, since you touch half the number of the pages in the contiguous case, need half the number of page walks, prefetching is more effective since you cross half as many 4K boundaries (prefetch stops at 4K boundaries) and so on. Even at the memory interface, alternating line writes might be less efficient because you get less benefit from opening each DRAM page, can’t do longer than 64-byte bursts, etc. In a pathological case, alternating lines could be &lt;em&gt;half&lt;/em&gt; the bandwidth if the controller maps alternating lines to alternating channels, since you’ll only be accessing a single channel. We could try to isolate this effect by trying more coarse grained interleaving. &lt;a href=&quot;#fnref:altwrites&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:l3adapt&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The L3 is capable of determining if the current access pattern would be better served by something like an &lt;abbr title=&quot;Most recently used - an eviction strategy suitable for data with little temporal locality&quot;&gt;MRU&lt;/abbr&gt; eviction strategy, for example when a stream of data is being accessed without reuse, it would be better to kick that data out of the cache quickly, rather than evicting other data that may be useful. &lt;a href=&quot;#fnref:l3adapt&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:gccfix&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;After all, there’s a good chance it will be fixed in a later version of gcc. &lt;a href=&quot;#fnref:gccfix&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:lazy&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;These are lazy in the sense that I don’t do any scalar head or tail handling: the final iteration just does a full width &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; store even if there aren’t 64 bytes left: we overwrite the buffer by up to 63 bytes. We account for this when we allocate the buffer by ensuring the allocation is oversized by at least that amount. This doesn’t matter for larger buffers, but it means this version will get a boost for very small buffers versus approaches that do the fill exactly. In any case, we are interested in large buffers here. &lt;a href=&quot;#fnref:lazy&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:l1port&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Most likely, the L1 has a single 64 byte wide write port, like &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt;, and the commit logic at the head of the store buffer can look ahead one store to see if it is in the same line in order to dequeue two stores in a single cycle. Without this feature, you could &lt;em&gt;execute&lt;/em&gt; two stores per cycle, but only commit one, so the long-run store throughput would be limited to one per cycle. &lt;a href=&quot;#fnref:l1port&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:lied&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Well I lied. I at least have some ideas. It may be that the CPU power budget is dynamically partitioned between the core and uncore, and with 512-bit stores triggering the AVX-512 power budget, there is less power for the uncore and it runs at a lower frequency (that could be checked). This seems unlikely given that it should not obviously affect the elimination chance. &lt;a href=&quot;#fnref:lied&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:RAM&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;We didn’t take a close look at the effect in RAM but it persists, albeit at a lower magnitude. 256-bit zero-over-zero writes are about 10% faster than 512-bit writes of the same type. &lt;a href=&quot;#fnref:RAM&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Travis Downs</name><email>travis.downs@gmail.com</email></author><category term="blog" /><category term="Intel" /><category term="x86" /><category term="uarch" /><category term="icelake" /><summary type="html">We look at the zero store optimization as it applies to Intel's newest micro-architecture.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://travisdowns.github.io/assets/intel-zero-opt/twitter-card-post2.png" /><media:content medium="image" url="https://travisdowns.github.io/assets/intel-zero-opt/twitter-card-post2.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hardware Store Elimination</title><link href="https://travisdowns.github.io/blog/2020/05/13/intel-zero-opt.html" rel="alternate" type="text/html" title="Hardware Store Elimination" /><published>2020-05-13T00:00:00+00:00</published><updated>2020-05-13T00:00:00+00:00</updated><id>https://travisdowns.github.io/blog/2020/05/13/intel-zero-opt</id><content type="html" xml:base="https://travisdowns.github.io/blog/2020/05/13/intel-zero-opt.html">&lt;!-- boilerplate 
page.assets: /assets/intel-zero-opt
assetpath: /assets/intel-zero-opt
tablepath: /misc/tables/intel-zero-opt
--&gt;

&lt;p&gt;I had no plans to write &lt;a href=&quot;/blog/2020/01/20/zero.html&quot;&gt;another post&lt;/a&gt; about zeros, but when life throws you a zero make zeroaid, or something like that. Here we go!&lt;/p&gt;

&lt;p&gt;If you want to jump over the winding reveal and just read the summary and advice, &lt;a href=&quot;#summary-perma&quot;&gt;now is your chance&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When writing simple memory benchmarks I have always taken the position the &lt;em&gt;value&lt;/em&gt; written to memory didn’t matter. Recently, while running a straightforward benchmark&lt;sup id=&quot;fnref:ubstore&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:ubstore&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; probing the interaction between AVX-512 stores and &lt;a href=&quot;https://en.wikipedia.org/wiki/MESI_protocol#Read_For_Ownership&quot;&gt;read for ownership&lt;/a&gt; I ran into a weird performance deviation. This is that story&lt;sup id=&quot;fnref:story&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:story&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h2&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#table-of-contents&quot; id=&quot;markdown-toc-table-of-contents&quot;&gt;Table of Contents&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#prelude&quot; id=&quot;markdown-toc-prelude&quot;&gt;Prelude&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#data-dependent-performance&quot; id=&quot;markdown-toc-data-dependent-performance&quot;&gt;Data Dependent Performance&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#source&quot; id=&quot;markdown-toc-source&quot;&gt;Source&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#benchmarks&quot; id=&quot;markdown-toc-benchmarks&quot;&gt;Benchmarks&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#a-very-simple-loop&quot; id=&quot;markdown-toc-a-very-simple-loop&quot;&gt;A Very Simple Loop&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#our-first-benchmark&quot; id=&quot;markdown-toc-our-first-benchmark&quot;&gt;Our First Benchmark&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#l1-and-l2&quot; id=&quot;markdown-toc-l1-and-l2&quot;&gt;L1 and L2&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#getting-weird-in-the-l3&quot; id=&quot;markdown-toc-getting-weird-in-the-l3&quot;&gt;Getting Weird in the L3&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#ram-still-weird&quot; id=&quot;markdown-toc-ram-still-weird&quot;&gt;RAM: Still Weird&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#wild-irresponsible-speculation-and-miscellanous-musings&quot; id=&quot;markdown-toc-wild-irresponsible-speculation-and-miscellanous-musings&quot;&gt;Wild, Irresponsible Speculation and Miscellanous Musings&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#predicting-a-new-predictor&quot; id=&quot;markdown-toc-predicting-a-new-predictor&quot;&gt;Predicting a New Predictor&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#predictor-test&quot; id=&quot;markdown-toc-predictor-test&quot;&gt;Predictor Test&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hardware-survey&quot; id=&quot;markdown-toc-hardware-survey&quot;&gt;Hardware Survey&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#further-notes&quot; id=&quot;markdown-toc-further-notes&quot;&gt;Further Notes&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#wrapping-up&quot; id=&quot;markdown-toc-wrapping-up&quot;&gt;Wrapping Up&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#findings&quot; id=&quot;markdown-toc-findings&quot;&gt;Findings&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tuning-advice&quot; id=&quot;markdown-toc-tuning-advice&quot;&gt;Tuning “Advice”&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#thanks&quot; id=&quot;markdown-toc-thanks&quot;&gt;Thanks&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#discussion-and-feedback&quot; id=&quot;markdown-toc-discussion-and-feedback&quot;&gt;Discussion and Feedback&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;prelude&quot;&gt;Prelude&lt;/h2&gt;

&lt;h3 id=&quot;data-dependent-performance&quot;&gt;Data Dependent Performance&lt;/h3&gt;

&lt;p&gt;On current mainstream CPUs, the timing of most instructions isn’t data-dependent. That is, their performance is the same regardless of the &lt;em&gt;value&lt;/em&gt; of the input(s) to the instruction. Unlike you&lt;sup id=&quot;fnref:assume&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:assume&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; or me your CPU takes the same time to add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 + 2&lt;/code&gt; as it does to add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;68040486 + 80866502&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, there are some notable exceptions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Integer division is data-dependent on most x86 CPUs: larger inputs generally take longer although the details vary widely among microarchitectures&lt;sup id=&quot;fnref:icldiv&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:icldiv&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
  &lt;li&gt;BMI2 instructions &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pdep&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pext&lt;/code&gt; have &lt;a href=&quot;https://twitter.com/uops_info/status/1202950247900684290&quot;&gt;famously terrible&lt;/a&gt; and data-dependent performance on AMD Zen and Zen2 chips.&lt;/li&gt;
  &lt;li&gt;Floating point instructions often have slower performance when &lt;a href=&quot;https://en.wikipedia.org/wiki/Denormal_number#Performance_issues&quot;&gt;denormal numbers&lt;/a&gt; are encountered, although some rounding modes such as &lt;em&gt;flush to zero&lt;/em&gt; may avoid this.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That list is not exhaustive: there are other cases of data-dependent performance, especially when you start digging into complex microcoded instructions such as &lt;a href=&quot;https://www.felixcloutier.com/x86/cpuid&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpuid&lt;/code&gt;&lt;/a&gt;. Still, it isn’t unreasonable to assume that most simple instructions not listed above execute in constant time.&lt;/p&gt;

&lt;p&gt;How about memory operations, such as loads and stores?&lt;/p&gt;

&lt;p&gt;Certainly, the &lt;em&gt;address&lt;/em&gt; matters. After all the address determines the caching behavior, and caching can easily account for two orders of magnitude difference in performance&lt;sup id=&quot;fnref:memperf&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:memperf&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;. On the other hand, I wouldn’t expect the &lt;em&gt;data values&lt;/em&gt; loaded or stored to matter. There is not much reason to expect the memory or caching subsystem to care about the value of the bits loaded or stored, outside of scenarios such as hardware-compressed caches not widely deployed&lt;sup id=&quot;fnref:atall&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:atall&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; on x86.&lt;/p&gt;

&lt;h3 id=&quot;source&quot;&gt;Source&lt;/h3&gt;

&lt;p&gt;The full benchmark associated with this post (including some additional benchmarks not mention here) is &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench&quot;&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;benchmarks&quot;&gt;Benchmarks&lt;/h2&gt;

&lt;p&gt;That’s enough prelude &lt;img src=&quot;/assets/intel-zero-opt/prelude.jpg&quot; alt=&quot;a small red car&quot; style=&quot;display:inline; height: 1.2em;&quot; /&gt; for now. Let’s write some benchmarks.&lt;/p&gt;

&lt;h3 id=&quot;a-very-simple-loop&quot;&gt;A Very Simple Loop&lt;/h3&gt;

&lt;p&gt;Let’s start with a very simple task. Write a function that takes an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; value &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;val&lt;/code&gt; and fills a buffer of a given size with copies of that value. Just like &lt;a href=&quot;https://en.cppreference.com/w/c/string/byte/memset&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt;&lt;/a&gt;, but with an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; value rather than a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; one.&lt;/p&gt;

&lt;p&gt;The canonical C implementation is probably some type of for loop, like this:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fill_int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;… or maybe this&lt;sup id=&quot;fnref:otherc&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:otherc&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fill_int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In C++, we don’t even need that much: we can simply delegate directly to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt; which does the same thing as a one-liner&lt;sup id=&quot;fnref:bpurp&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:bpurp&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There is nothing magic about &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt;, it also &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/866cd688d1b72b0700a7e001428bdf2fe73fbf64/libstdc%2B%2B-v3/include/bits/stl_algobase.h#L698&quot;&gt;uses a loop&lt;/a&gt; just like the C version above. Not surprisingly, gcc and clang compile them to the &lt;a href=&quot;https://godbolt.org/z/R5bJiE&quot;&gt;same machine code&lt;/a&gt;&lt;sup id=&quot;fnref:clangv&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:clangv&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;With the right compiler arguments (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-march=native -O3 -funroll-loops&lt;/code&gt; in our case), we expect this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt; version (and all the others) to be implemented with with AVX vector instructions, and &lt;a href=&quot;https://godbolt.org/z/SfGVEC&quot;&gt;it is so&lt;/a&gt;. The part which does the heavy lifting work for large fills looks like this:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.L4:&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;96&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;160&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;YMMWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;224&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;jne&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;.L4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It copies 256 bytes of data every iteration using eight 32-byte AVX2 store instructions. The full function is much larger, with a scalar portion for buffers smaller than 32 bytes (and which also handles the odd elements after the vectorized part is done), and a vectorized jump table to handle up to seven 32-byte chunks before the main loop. No effort is made to align the destination, but we’ll align everything to 64 bytes in our benchmark so this won’t matter.&lt;/p&gt;

&lt;h3 id=&quot;our-first-benchmark&quot;&gt;Our First Benchmark&lt;/h3&gt;

&lt;p&gt;Enough foreplay: let’s take the C++ version out for a spin, with two different fill values (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;val&lt;/code&gt;) selected completely at random: zero (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill0&lt;/code&gt;) and one (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill1&lt;/code&gt;). We’ll use gcc 9.2.1 and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-march=native -O3 -funroll-loops&lt;/code&gt; flags mentioned above.&lt;/p&gt;

&lt;p&gt;We organize it so that for both tests we call the &lt;em&gt;same&lt;/em&gt; non-inlined function: the exact same instructions are executed and only the value differs. That is, the compile isn’t making any data-dependent optimizations.&lt;/p&gt;

&lt;p&gt;Here’s the fill throughput in GB/s for these two values, for region sizes ranging from 100 up to 100,000,000 bytes.&lt;/p&gt;

&lt;center&gt;&lt;strong&gt;Figure 1&lt;/strong&gt;&lt;/center&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig1&quot; id=&quot;fig1&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig1.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/overall.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig1.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig1.svg&quot; alt=&quot;Figure 1&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;&lt;strong&gt;About this chart:&lt;/strong&gt;&lt;br /&gt;
At each region size (that is, at each position along the x-axis) 17 semi-transparent samples&lt;sup id=&quot;fnref:warm&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:warm&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt; are plotted and although they usually overlap almost completely (resulting in a single circle), you can see cases where there are outliers that don’t line up with the rest of this sample. This plot tries to give you an idea of the spread of back-to-back samples without hiding them behind error bars&lt;sup id=&quot;fnref:errorbars&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:errorbars&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;. Finally, the sizes of the various data caches (32, 256 and 6144 KiB for the L1D, L2 and L3, respectively) are marked for convenience.&lt;/p&gt;

&lt;h4 id=&quot;l1-and-l2&quot;&gt;L1 and L2&lt;/h4&gt;

&lt;p&gt;Not surprisingly, the performance depends heavily on what level of cache the filled region fits into.&lt;/p&gt;

&lt;p&gt;Everything is fairly sane when the buffer fits in the L1 or L2 cache (up to ~256 KiB&lt;sup id=&quot;fnref:l2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:l2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;). The relatively poor performance for very small region sizes is explained by the prologue and epilogue of the vectorized implementation: for small sizes a relatively large amount of time is spent in these int-at-a-time loops: rather than copying up to 32 bytes per cycle, we copy only 4.&lt;/p&gt;

&lt;p&gt;This also explains the bumpy performance in the fastest region between ~1,000 and ~30,000 bytes: this is highly reproducible and not noise. It occurs because because some sampled values have a larger remainder mod 32. For example, the sample at 740 bytes runs at ~73 GB/s while the next sample at 988 runs at a slower 64 GB/s. That’s because 740 % 32 is 4, while 988 % 32 is 28, so the latter size has 7x more cleanup work to do than the former&lt;sup id=&quot;fnref:badvec&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:badvec&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;13&lt;/a&gt;&lt;/sup&gt;. Essentially, we are sampling semi-randomly a sawtooth function and if you plot this region with finer granularity (go for it or just &lt;a href=&quot;/assets/intel-zero-opt/sawtooth.svg&quot;&gt;click here&lt;/a&gt;&lt;sup id=&quot;fnref:melty&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:melty&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;14&lt;/a&gt;&lt;/sup&gt;) you can see it quite clearly.&lt;/p&gt;

&lt;h4 id=&quot;getting-weird-in-the-l3&quot;&gt;Getting Weird in the L3&lt;/h4&gt;

&lt;p&gt;So while there are some interesting effects in the first half of the results, covering L1 and L2, they are fairly easy to explain and, more to the point, performance for the zero and one cases are identical: the samples are all concentric. As soon as we dip our toes into the L3, however, things start to get &lt;em&gt;weird&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Weird in that we we see a clear divergence between stores of zero versus ones. Remember that this is the exact same function, the same &lt;em&gt;machine&lt;/em&gt; code executing the same stream of instructions, only varying in the value of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ymm1&lt;/code&gt; register passed to the store instruction. Storing zero is consistently about 17% to 18% faster than storing one, both in the region covered by the L3 (up to 6 MiB on my system), and beyond that where we expect misses to RAM (it looks like the difference narrows in the RAM region, but it’s mostly a trick of the eye: the relative performance difference is about the same).&lt;/p&gt;

&lt;p&gt;What’s going on here? Why does the CPU care &lt;em&gt;what values&lt;/em&gt; are being stored, and why is zero special?&lt;/p&gt;

&lt;p&gt;We can get some additional insight by measuring the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2_lines_out.silent&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2_lines_out.non_silent&lt;/code&gt; events while we focus on the regions that fit in L2 or L3. These events measure the number of lines evicted from L2 either &lt;em&gt;silently&lt;/em&gt; or &lt;em&gt;non-silently&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Here are Intel’s descriptions of these events:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;l2_lines_out.silent&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Counts the number of lines that are silently dropped by L2 cache when triggered by an L2 cache fill. These lines are typically in Shared or Exclusive state.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;l2_lines_out.non_silent&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Counts the number of lines that are evicted by L2 cache when triggered by an L2 cache fill. Those lines are in Modified state. Modified lines are written back to L3.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The states being referred to here are &lt;a href=&quot;https://en.wikipedia.org/wiki/MESI_protocol&quot;&gt;MESI&lt;/a&gt; cache states, commonly abbreviated M (modified), E (exclusive, but not modified) and S (possibly shared, not modified).&lt;/p&gt;

&lt;p&gt;The second definition is not completely accurate. In particular, it implies that only modified lines trigger the &lt;em&gt;non-silent&lt;/em&gt; event. However, &lt;a href=&quot;https://stackoverflow.com/q/52565303/149138&quot;&gt;I find&lt;/a&gt; that unmodified lines in E state can also trigger this event. Roughly, the behavior for unmodified lines seems to be that lines that miss in L2 &lt;em&gt;and&lt;/em&gt; L3 usually get filled into the L2 in a state where they will be evicted &lt;em&gt;non-silently&lt;/em&gt;, but unmodified lines that miss in L2 and &lt;em&gt;hit&lt;/em&gt; in L3 will generally be evicted silently&lt;sup id=&quot;fnref:silent&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:silent&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;15&lt;/a&gt;&lt;/sup&gt;. Of course, lines that are modified &lt;em&gt;must&lt;/em&gt; be evicted non-silently in order to update the outer levels with the new data.&lt;/p&gt;

&lt;p&gt;In summary: silent evictions are associated with unmodified lines in E or S state, while non-silent evictions are associated with M, E or (possibly) S state lines, with the silent vs non-silent choice for E and S being made in some unknown matter.&lt;/p&gt;

&lt;p&gt;Let’s look at silent vs non-silent evictions for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill0&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill1&lt;/code&gt; cases:&lt;/p&gt;

&lt;center&gt;&lt;strong&gt;Figure 2&lt;/strong&gt;&lt;/center&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig2&quot; id=&quot;fig2&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig2.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/l2-focus.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig2.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig2.svg&quot; alt=&quot;Figure 2&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;&lt;strong&gt;About this chart:&lt;/strong&gt;&lt;br /&gt;
For clarity, I show only the median single sample for each size&lt;sup id=&quot;fnref:trust&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:trust&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;16&lt;/a&gt;&lt;/sup&gt;. As before, the left axis is fill speed and on the right axis the two types eviction events are plotted, normalized to the number of cache lines accessed in the benchmark. That is, a value of 1.0 means that for every cache line accessed, the event occurred one time.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;total&lt;/em&gt; number of evictions (sum of silent and non-silent) is the same for both cases: near zero&lt;sup id=&quot;fnref:wb&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:wb&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;17&lt;/a&gt;&lt;/sup&gt; when the region fits in L2, and then quickly increases to ~1 eviction per stored cache line. In the L3, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill1&lt;/code&gt; also behaves as we’d expect: essentially all of the evictions are non-silent. This makes sense since modified lines &lt;em&gt;must&lt;/em&gt; be evicted non-silently to write their modified data to the next layer of the cache subsystem.&lt;/p&gt;

&lt;p&gt;For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill0&lt;/code&gt;, the story is different. Once the buffer size no longer fits in L2, we see the same &lt;em&gt;total&lt;/em&gt; number of evictions from L2, but 63% of these are silent, the rest non-silent. Remember, only unmodified lines even have the hope of a silent eviction. This means that at least 63% of the time, the L2&lt;sup id=&quot;fnref:orl3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:orl3&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;18&lt;/a&gt;&lt;/sup&gt; is able to detect that the write is &lt;em&gt;redundant&lt;/em&gt;: it doesn’t change the value of the line, and so the line is evicted silently. That is, it is never written back to the L3. This is presumably what causes the performance boost: the pressure on the L3 is reduced: although all the implied reads&lt;sup id=&quot;fnref:rfo&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:rfo&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;19&lt;/a&gt;&lt;/sup&gt; still need to go through the L3, only about 1 out of 3 of those lines ends up getting written back.&lt;/p&gt;

&lt;p&gt;Once the test starts to exceed the L3 threshold, all of the evictions become non-silent even in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill0&lt;/code&gt; case. This doesn’t necessarily mean that the zero optimization stops occurring. As mentioned earlier&lt;sup id=&quot;fnref:silent:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:silent&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;15&lt;/a&gt;&lt;/sup&gt;, it is a typical pattern even for read-only workloads: once lines arrive in L2 as a result of an L3 miss rather than a hit, their subsequent eviction becomes non-silent, even if never written. So we can assume that the lines are probably still detected as not modified, although we lose our visibility into the effect at least as far as the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2_lines_out&lt;/code&gt; events go. That is, although all evictions are non-silent, some fraction of the evictions are still indicating that the outgoing data is unmodified.&lt;/p&gt;

&lt;h4 id=&quot;ram-still-weird&quot;&gt;RAM: Still Weird&lt;/h4&gt;

&lt;p&gt;In fact, we can confirm that this apparent optimization still happens as move into RAM using a different set of events. There are several to choose from – and all of those that I tried tell the same story. We’ll focus on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unc_arb_trk_requests.writes&lt;/code&gt;, &lt;a href=&quot;https://www.intel.com/content/dam/www/public/us/en/documents/manuals/6th-gen-core-family-uncore-performance-monitoring-manual.pdf&quot;&gt;documented&lt;/a&gt; as follows:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Number of writes allocated including any write transaction including full, partials and evictions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Important to note that the “uncore tracker” these events monitor is used by data flowing between L3 and memory, not between L2 and L3. So &lt;em&gt;writes&lt;/em&gt; here generally refers to writes that will reach memory.&lt;/p&gt;

&lt;p&gt;Here’s how this event scales for the same test we’ve been running this whole time (the size range has been shifted for focus on the area of interest)&lt;sup id=&quot;fnref:sneaky&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:sneaky&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;20&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;center&gt;&lt;strong&gt;Figure 3&lt;/strong&gt;&lt;/center&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig3&quot; id=&quot;fig3&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig3.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/l3-focus.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig3.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig3.svg&quot; alt=&quot;Figure 3&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;The number of writes for well-behaved &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill1&lt;/code&gt; approaches one write per cache line as the buffer exceeds the size of L3 – again, this is as expected. For the more rebellious &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill0&lt;/code&gt;, it is almost exactly half that amount. For every two lines written by the benchmark, we only write one back to memory! This same 2:1 ratio is reflected also if we measure memory writes at the integrated memory controller&lt;sup id=&quot;fnref:imcevent&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:imcevent&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;21&lt;/a&gt;&lt;/sup&gt;: writing zeros results in only half the number of writes at the memory controller.&lt;/p&gt;

&lt;h3 id=&quot;wild-irresponsible-speculation-and-miscellanous-musings&quot;&gt;Wild, Irresponsible Speculation and Miscellanous Musings&lt;/h3&gt;

&lt;p&gt;This is all fairly strange. It’s not weird that there would be a “redundant writes” optimization to avoid writing back identical values: this seems like it could benefit some common write patterns.&lt;/p&gt;

&lt;p&gt;It is perhaps a bit unusual that it only apparently applies to all-zero values. Maybe this is because zeros overwriting zeros is one of the most common redundant write cases, and detecting zero values can done more cheaply than a full compare. Also, the “is zero?” state can be communicated and stored as a single bit, which might be useful. For example, if the L2 is involved in the duplicate detection (and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2_lines_out&lt;/code&gt; results suggest it is), perhaps the detection happens when the line is evicted, at which point you want to compare to the line in L3, but you certainly can’t store the entire old value in or near the L2 (that would require storage as large as the L2 itself). You could store an indicator that the line was zero, however, in a single bit and compare the existing line as part of the eviction process.&lt;/p&gt;

&lt;h4 id=&quot;predicting-a-new-predictor&quot;&gt;Predicting a New Predictor&lt;/h4&gt;

&lt;p&gt;What is the weirdest of all, however, is that the optimization doesn’t kick in 100% of the time but only for 40% to 60% of the lines, depending on various parameters&lt;sup id=&quot;fnref:params&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:params&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;22&lt;/a&gt;&lt;/sup&gt;. What would lead to that effect? One could imagine that there could be some type of predictor which determines whether to apply this optimization or not, depending on e.g., whether the optimization has recently been effective – that is, whether redundant stores have been common recently. Perhaps this predictor also considers factors such as the occupancy of outbound queues&lt;sup id=&quot;fnref:obbus&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:obbus&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;23&lt;/a&gt;&lt;/sup&gt;: when the bus is near capacity, searching for eliminating redundant writes might be more worth the power or latency penalty compared to the case when there is little apparent pressure on the bus.&lt;/p&gt;

&lt;p&gt;In this benchmark, any predictor would find that the optimization is 100% effective: &lt;em&gt;every&lt;/em&gt; write is redundant! So we might guess that the second condition (queue occupancy) results in a behavior where only some stores are eliminated: as more stores are eliminated, the load on the bus becomes lower and so at some point the predictor no long thinks it is worth it to eliminate stores and you reach a kind of stable state where only a fraction of stores are eliminated based on the predictor threshold.&lt;/p&gt;

&lt;h4 id=&quot;predictor-test&quot;&gt;Predictor Test&lt;/h4&gt;

&lt;p&gt;We can kind of test that theory: in this model, any store is &lt;em&gt;capable&lt;/em&gt; of being eliminated, but the ratio of eliminated stores is bounded above by the predictor behavior. So if we find that a benchmark of &lt;em&gt;pure&lt;/em&gt; redundant zero stores is eliminated at a 60% rate, we might expect that any benchmark with at least 60% redundant stores can reach the 60% rate, and with lower rates, you’d see full elimination of all redundant stores (since now the bus always stays active enough to trigger the predictor).&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Apparently analogies are helpful, so an analogy here would be a person controlling the length of a line by redirecting some incoming people. For example, in an airport security line the handler tries to keep the line at a certain maximum length by redirecting (redirecting -&amp;gt; store elimination) people to the priority line if they are eligible and the main line is at or above its limit. Eligible people are those without carry-on luggage (eligible people -&amp;gt; zero-over-zero stores).&lt;br /&gt;
&lt;br /&gt;
If everyone is eligible (-&amp;gt; 100% zero stores), this control will always be successful and the fraction of people redirected will depend on the relative rate of ingress and egress through security. If security only has a throughput of 40% of the ingress rate, 60% of people will redirected in the steady state. Now, consider what happens if not everyone is eligible: if the eligible fraction is at least 60%, nothing changes. You still redirect 60% of people. Only if the eligible rate drops below 60% is there a problem: now you’ll be redirecting 100% of eligible people, but the primary line will grow beyond your limit.&lt;br /&gt;
&lt;br /&gt;
Whew! Not sure if that was helpful after all?&lt;/p&gt;

&lt;p&gt;Let’s try a benchmark which adds a new implementation, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alt01&lt;/code&gt; which alternates between writing a cache line of zeros and a cache line of ones. All the writes are redundant, but only 50% are zeros, so under the theory that a predictor is involved we expect that maybe 50% of the stores will be eliminated (i.e., 100% of the redundant stores are eliminated and they make up 50% of the total).&lt;/p&gt;

&lt;p&gt;Here we focus on the L3, similar to Fig. 2 above, showing silent evictions (the non-silent ones make up the rest, adding up to 1 total as before):&lt;/p&gt;

&lt;center&gt;&lt;strong&gt;Figure 4&lt;/strong&gt;&lt;/center&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig4&quot; id=&quot;fig4&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig4.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/l2-focus.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig4.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig4.svg&quot; alt=&quot;Figure 4&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;We don’t see 50% elimination. Rather we see less than half the elimination of the all-zeros case: 27% versus 63%. Performance is better in the L3 region than the all ones case, but only slightly so! So this doesn’t support the theory of a predictor capable of eliminating on any store and operating primarily on outbound queue occupancy.&lt;/p&gt;

&lt;p&gt;Similarly, we can examine the region where the buffer fits only in RAM, similar to Fig. 3 above:&lt;/p&gt;

&lt;center&gt;&lt;strong&gt;Figure 5&lt;/strong&gt;&lt;/center&gt;

&lt;div class=&quot;svg-fig&quot;&gt;
    &lt;a href=&quot;#fig5&quot; id=&quot;fig5&quot;&gt;[link to this chart]&lt;/a&gt; 
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig5.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/l3-focus.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig5.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig5.svg&quot; alt=&quot;Figure 5&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Recall that the lines show the number of writes reaching the memory subsystem. Here we see that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alt01&lt;/code&gt; again splits the difference between the zero and ones case: about 75% of the writes reach memory, versus 48% in the all-zeros case, so the elimination is again roughly half as effective. In this case, the performance also splits the difference between all zeros and all ones: it falls almost exactly half-way between the two other cases.&lt;/p&gt;

&lt;p&gt;So I don’t know what’s going on exactly. It seems like maybe only some fraction are of lines are eligible for elimination due to some unknown internal mechanism in the &lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt;.&lt;/p&gt;

&lt;h3 id=&quot;hardware-survey&quot;&gt;Hardware Survey&lt;/h3&gt;

&lt;p&gt;Finally, here are the performance results (same as &lt;strong&gt;Figure 1&lt;/strong&gt;) on a variety of other Intel and AMD x86 architectures, as well as IBM’s POWER9 and Amazon’s Graviton 2 ARM processor, one per tab.&lt;/p&gt;

&lt;!-- uresults: snb/remote.csv,hsw/remote.csv,skl/remote.csv,skx/remote.csv,cnl/remote.csv,zen2/remote.csv,power9/remote.csv,gra2/remote.csv --&gt;

&lt;div class=&quot;tabs&quot;&gt;
    &lt;!-- Courtesy of https://codepen.io/Merri/pen/bytea --&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-1&quot; name=&quot;tab-group-1&quot; checked=&quot;&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-1&quot;&gt;Sandy Bridge&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-snb.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/snb/remote.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-snb.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig6-snb.svg&quot; alt=&quot;Figure 4&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt; 
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-2&quot; name=&quot;tab-group-1&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-2&quot;&gt;Haswell&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-hsw.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/hsw/remote.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-hsw.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig6-hsw.svg&quot; alt=&quot;Figure 4&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt; 
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-3&quot; name=&quot;tab-group-1&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-3&quot;&gt;Skylake-S&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-skl.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/skl/remote.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-skl.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig6-skl.svg&quot; alt=&quot;Figure 4&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt; 
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-4&quot; name=&quot;tab-group-1&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-4&quot;&gt;Skylake-X&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-skx.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/skx/remote.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-skx.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig6-skx.svg&quot; alt=&quot;Figure 4&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt; 
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-5&quot; name=&quot;tab-group-1&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-5&quot;&gt;Cannon Lake&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-cnl.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/cnl/remote.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-cnl.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig6-cnl.svg&quot; alt=&quot;Figure 4&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt; 
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-6&quot; name=&quot;tab-group-1&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-6&quot;&gt;Zen2&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-zen2.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/zen2/remote.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-zen2.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig6-zen2.svg&quot; alt=&quot;Figure 4&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt; 
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-7&quot; name=&quot;tab-group-1&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-7&quot;&gt;POWER9&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-power9.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/power9/remote.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-power9.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig6-power9.svg&quot; alt=&quot;Figure 4&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt; 
    &lt;/div&gt;
    
    &lt;div class=&quot;tab&quot;&gt;
      &lt;input class=&quot;tab-radio&quot; type=&quot;radio&quot; id=&quot;tab-8&quot; name=&quot;tab-group-1&quot; /&gt;
      &lt;label class=&quot;tab-label&quot; for=&quot;tab-8&quot;&gt;Graviton 2&lt;/label&gt;
      &lt;div class=&quot;tab-panel&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;
          
          
          

&lt;div class=&quot;svg-fig&quot;&gt;
    
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-gra2.html&quot;&gt;[data table]&lt;/a&gt; 
    &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/tree/master/results/gra2/remote.csv&quot;&gt;[raw data]&lt;/a&gt; 
    &lt;br /&gt;
    &lt;a href=&quot;/misc/tables/intel-zero-opt/fig6-gra2.html&quot;&gt;
        &lt;img class=&quot;figimg&quot; src=&quot;/assets/intel-zero-opt/fig6-gra2.svg&quot; alt=&quot;Figure 4&quot; /&gt;
    &lt;/a&gt;
&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt; 
    &lt;/div&gt;
    
&lt;/div&gt;

&lt;p&gt;Some observations on these results:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The redundant write optimization isn’t evident in the performance profile for &lt;em&gt;any&lt;/em&gt; of the other non-&lt;abbr title=&quot;Intel's Skylake (client) architecture, aka 6th Generation Intel Core i3,i5,i7&quot;&gt;SKL&lt;/abbr&gt; hardware tested. Not even closely related Intel hardware like Haswell or Skylake-X. I also did a few spot tests with performance counters, and didn’t see any evidence of a reduction in writes. So for now this might a Skylake client only thing (of course, Skylake client is perhaps the most widely deployed Intel &lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt; even due to the many identical-&lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt;-except-in-name variants: Kaby Lake, Coffee Lake, etc, etc). Note that the Skylake-S result here is for a different (desktop i7-6700) chip than the rest of this post, so we can at least confirm this occurs on two different chips.&lt;/li&gt;
  &lt;li&gt;Except in the RAM region, Sandy Bridge throughput is half of its successors: a consequence of having only a 16-byte load/store path in the core, despite supporting 32-byte AVX instructions.&lt;/li&gt;
  &lt;li&gt;AMD Zen2 has &lt;em&gt;excellent&lt;/em&gt; write performance in the L2 and L3 regions. All of the Intel chips drop to about half throughput for writes in the L2: slightly above 16 bytes per cycle (around 50 GB/s for most of these chips). Zen2 maintains its L1 throughput and in fact has its highest results in L2: over 100 GB/s. Zen2 also manages more than 70 GB/s in the L3, much better than the Intel chips, in this test.&lt;/li&gt;
  &lt;li&gt;Both Cannon Lake and Skylake-X exhibit a fair amount of inter-sample variance in the L2 resident region. My theory here would be prefetcher interference which behaves differently than earlier chips, but I am not sure.&lt;/li&gt;
  &lt;li&gt;Skylake-X, with a different L3 design than the other chips, has quite poor L3 fill throughput, about half of contemporary Intel chips, and less than a third of Zen2.&lt;/li&gt;
  &lt;li&gt;The POWER9 performance is neither terrible nor great. The most interesting part is probably the high L3 fill throughput: L3 throughput is as high or higher than L1 or L2 throughput, but still not in Zen2 territory.&lt;/li&gt;
  &lt;li&gt;Amazon’s new Graviton processor is very interesting. It seems to be limited to one 16-byte store per cycle&lt;sup id=&quot;fnref:armcompile&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:armcompile&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;24&lt;/a&gt;&lt;/sup&gt;, giving it a peak possible store throughput of 40 GB/s, so it doesn’t do well in the L1 region versus competitors that can hit 100 GB/s or more (they have both higher frequency and 32 byte stores), but it sustains the 40 GB/s all the way to RAM sizes, with a RAM result flat enough to serve drinks on, and this on a shared 64-CPU host where I paid for only a single core&lt;sup id=&quot;fnref:g2ga&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:g2ga&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;25&lt;/a&gt;&lt;/sup&gt;! The RAM performance is the highest out of all hardware tested.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You might notice that Ice Lake, Intel’s newest microarchitecture, is missing from this list: that’s because there is a &lt;a href=&quot;/blog/2020/05/18/icelake-zero-opt.html&quot;&gt;whole separate post&lt;/a&gt; on it.&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;summary-perma&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;further-notes&quot;&gt;Further Notes&lt;/h3&gt;

&lt;p&gt;Here’s a grab back of notes and observations that don’t get their a full section, don’t have any associated plots, etc. That doesn’t mean they are less important! Don’t say that! These ones matter too, they really do.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Despite any impressions I may have given above: you don’t need to &lt;em&gt;fully&lt;/em&gt; overwrite a cache line with zeros for this to kick in, and you can even write &lt;em&gt;non-zero&lt;/em&gt; values if you overwrite them “soon enough” with zeros. Rather, the line must initially fully zero, and then all the &lt;em&gt;escaping&lt;sup id=&quot;fnref:escaping&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:escaping&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;26&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt; writes must be zero. Another way of thinking about this is that the thing that matters is the value of the cache line written back, as well as the old value of the line that the writeback is replacing: these must both be fully zero, but that doesn’t mean that you need to overwrite the line with zeros: any locations not written are still zero “from before”. I directly test this in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;one_per0&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;one_per1&lt;/code&gt; tests in the benchmark. These write only a single &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; value in each cache line, leaving the other values unchanged. In that benchmark the optimization kicks triggers in exactly the same way when writing a single zero.&lt;/li&gt;
  &lt;li&gt;Although we didn’t find evidence of this happening on other x86 hardware, nor on POWER or ARM, that doesn’t mean it isn’t or can’t happen. It is possible the conditions for it to happen aren’t triggered, or that it is happening but doesn’t make a difference in performance. Similarly for the POWER9 and ARM chips: we didn’t check any performance counters, so maybe the thing is happening but it just doesn’t make any difference in performance. That’s especially feasible in the ARM case where the performance is totally limited by the core-level 16-bytes-per-cycle write throughput: even if all writes are eliminated later on in the path to memory, we expect the performance to be the same.&lt;/li&gt;
  &lt;li&gt;We could learn more about this effect by setting up a test which writes ones first to a region of some fixed size, then overwrites it with zeros, and repeats this in a rolling fashion over a larger buffer. This test basically lets the 1s escape to a certain level of the cache hierarchy, and seeing where the optimization kicks in will tell us something interesting.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping Up&lt;/h2&gt;

&lt;h3 id=&quot;findings&quot;&gt;Findings&lt;/h3&gt;

&lt;p&gt;Here’s a brief summary of what we found. This will be a bit redundant if you’ve just read the whole thing, but we need to accommodate everyone who just skipped down to this part, right?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Intel chips can apparently eliminate some redundant stores when zeros are written to a cache line that is already all zero (the line doesn’t need to be fully overwritten).&lt;/li&gt;
  &lt;li&gt;This optimization applies at least as early as L2 writeback to L3, so would apply to the extend that working sets don’t fit in L2.&lt;/li&gt;
  &lt;li&gt;The effect eliminates both write accesses to L3, and writes to memory depending on the working set size.&lt;/li&gt;
  &lt;li&gt;For the pure store benchmark discussed here effect of this optimization is a reduction in the number of writes of ~63% (to L3) and ~50% (to memory), with a runtime reduction of between 15% and 20%.&lt;/li&gt;
  &lt;li&gt;It is unclear why not all redundant zero-over-zero stores are eliminated.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tuning-advice&quot;&gt;Tuning “Advice”&lt;/h3&gt;

&lt;p&gt;So is any of actually useful? Can we use this finding to quadruple the speed of the things that really matter in computation: tasks like bitcoin mining, high-frequency trading and targeting ads in real time?&lt;/p&gt;

&lt;p&gt;Nothing like that, no – but it might provide a small boost for some cases.&lt;/p&gt;

&lt;p&gt;Many of those cases are probably getting the benefit without any special effort. After all, zero is already a special value: it’s how memory arrives comes from the operating system, and at the language allocation level for some languages. So a lot of cases that could get this benefit, probably already are.&lt;/p&gt;

&lt;p&gt;Redundant zero-over-zero probably isn’t as rare as you might think either: consider that in low level languages, memory is often cleared after receiving it from the allocator, but in many cases this memory came directly from the OS so it is already zero&lt;sup id=&quot;fnref:calloc&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:calloc&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;27&lt;/a&gt;&lt;/sup&gt;. Consider also cases like fairly-sparse matrix multiplication: where your matrix isn’t sparse enough to actually use dedicated sparse routines, but still has a lot of zeros. In that case, you are going to be writing 0 all the time in your final result and scratch buffers. This optimization will reduce the writeback traffic in that case.&lt;/p&gt;

&lt;p&gt;If you are making a ton of redundant writes, the first thing you might want to do is look for a way to stop doing that. Beyond that, we can list some ways you &lt;em&gt;might&lt;/em&gt; be able to take advantage of this new behavior:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In the case you are likely to have redundant writes, prefer zero as the special value that is likely to be redundantly overwritten. For example if you are doing some blind writes, something like &lt;a href=&quot;https://richardstartin.github.io/posts/garbage-collector-code-artifacts-card-marking&quot;&gt;card marking&lt;/a&gt; where you don’t know if your write is redundant, you might consider writing zeros, rather than writing non-zeros, since in the case that some region of card marks gets repeatedly written, it will be all-zero and the optimization can apply. Of course, this cuts the wrong way when you go to clear the marked region: now you have to write non-zero so you don’t get the optimization during clearing (but maybe this happens out of line with the user code that matters). What ends up better depends on the actual write pattern.&lt;/li&gt;
  &lt;li&gt;In case you might have redundant zero-over-zero writes, pay a bit more attention to 64-byte alignment than you normally would because this optimization only kicks in when a full cache line is zero. So if you have some 64-byte structures that might often be all zero (but with non-zero neighbors), a forced 64-byte alignment will be useful since it would activate the optimization more frequently.&lt;/li&gt;
  &lt;li&gt;Probably the most practical advice of all: just keep this effect in mind because it can mess up your benchmarks and make you distrust performance counters. I found this when I noticed that the scalar version of a benchmark was writing 2x as much memory as the AVX version, despite them doing the same thing other than the choice of registers. As it happens, the dummy value in vector register I was storing was zero, while in the scalar case it wasn’t: so there was a large difference that had nothing to do with scalar vs vector, but non-zero vs zero instead. Prefer non-zero values in store microbenchmarks, unless you really expect them to be zero in real life!&lt;/li&gt;
  &lt;li&gt;Keep an eye for a more general version of this optimization: maybe one day we’ll see this effect apply to redundant writes that aren’t zero-over-zero.&lt;/li&gt;
  &lt;li&gt;Floating point has two zero values: +0 and -0. The representation of +0 is all-bits-zero, so using +0 gives you the chance of getting this optimization. Of course, everyone is already using +0 whenever they explicitly want zero.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course, the fact that this seems to currently only apply on Skylake and &lt;a href=&quot;/blog/2020/05/18/icelake-zero-opt.html&quot;&gt;Ice Lake&lt;/a&gt; client hardware makes specifically targeting this quite dubious indeed.&lt;/p&gt;

&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;Thanks to Daniel Lemire who provided access to the hardware used in the &lt;a href=&quot;#hardware-survey&quot;&gt;Hardware Survey&lt;/a&gt; part of this post.&lt;/p&gt;

&lt;p&gt;Thanks Alex Blewitt and Zach Wegner who pointed out the CSS tab technique (I used the one linked in the &lt;a href=&quot;https://twitter.com/zwegner/status/1223701307078402048&quot;&gt;comments of this post&lt;/a&gt;) and others who replied to &lt;a href=&quot;https://twitter.com/trav_downs/status/1223690150175236102&quot;&gt;this tweet&lt;/a&gt; about image carousels.&lt;/p&gt;

&lt;p&gt;Thanks to Tarlinian, 不良大脑的所有者, Bruce Dawson, Zach Wegner and Andrey Penechko who pointed out typos or omissions in the text.&lt;/p&gt;

&lt;h3 id=&quot;discussion-and-feedback&quot;&gt;Discussion and Feedback&lt;/h3&gt;

&lt;p&gt;Leave a comment below, or discuss on &lt;a href=&quot;https://twitter.com/trav_downs/status/1260620313483771905&quot;&gt;Twitter&lt;/a&gt;, &lt;a href=&quot;https://news.ycombinator.com/item?id=23169605&quot;&gt;Hacker News&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/asm/comments/gj3xq7/hardware_store_elimination/&quot;&gt;reddit&lt;/a&gt; or &lt;a href=&quot;https://www.realworldtech.com/forum/?threadid=191798&amp;amp;curpostid=191798&quot;&gt;RWT&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Feedback is also warmly welcomed by &lt;a href=&quot;mailto:travis.downs@gmail.com&quot;&gt;email&lt;/a&gt; or as &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io/issues&quot;&gt;a GitHub issue&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:ubstore&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Specifically, I was running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uarch-bench.sh --test-name=memory/bandwidth/store/*&lt;/code&gt; from &lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt;-bench. &lt;a href=&quot;#fnref:ubstore&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:story&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Like many posts on this blog, what follows is essentially a &lt;em&gt;reconstruction&lt;/em&gt;. I encountered the effect originally in a benchmark, as described, and then worked backwards from there to understand the underlying effect. Then, I wrote this post the other way around: building up a new benchmark to display the effect … but at that point I already knew what we’d find. So please don’t think I just started writing the benchmark you find on GitHub and then ran into this issue coincidentally: the arrow of causality points the other way. &lt;a href=&quot;#fnref:story&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:assume&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Probably? I don’t like to assume too much about the reader, but this seems like a fair bet. &lt;a href=&quot;#fnref:assume&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:icldiv&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Starting with Ice Lake, it seems like Intel has implemented a constant-time integer divide unit. &lt;a href=&quot;#fnref:icldiv&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:memperf&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Latency-wise, something like 4-5 cycles for an L1 hit, versus 200-500 cycles for a typical miss to DRAM. Throughput wise there is also a very large gap (256 GB/s L1 throughput &lt;em&gt;per core&lt;/em&gt; on a 512-bit wide machine versus usually less than &amp;lt; 100 GB/s &lt;em&gt;per socket&lt;/em&gt; on recent Intel). &lt;a href=&quot;#fnref:memperf&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:atall&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Is it deployed anywhere at all on x86? Ping me if you know. &lt;a href=&quot;#fnref:atall&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:otherc&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;It’s hard to say which is faster if they are compiled as written: x86 has indexed addressing modes that make the indexing more or less free, at least for arrays of element size 1, 2, 4 or 8, so the usual arguments againt indexed access mostly don’t apply. Probably, it doesn’t matter: this detail might have made a big difference 20 years ago, but it is unlikely to make a difference on a decent compiler today, which can transform one into the other, depending on the target hardware. &lt;a href=&quot;#fnref:otherc&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:bpurp&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;For benchmarking purposes, we wrap this in &lt;a href=&quot;https://github.com/travisdowns/zero-fill-bench/blob/post1/algos.cpp#L28&quot;&gt;another function&lt;/a&gt; so we can slap a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;noinline&lt;/code&gt; attribute on this function to ensure that we have a single non-inlined version to call for different values. If we just called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt; with a literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; value, it highly likely to get inlined at the call site and we’d have code with different alignment (and possibly other differences) for each value. &lt;a href=&quot;#fnref:bpurp&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:clangv&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Admittedly I didn’t go line-by-line though the long vectorized version produced by clang but the line count is identical and if you squint so the assembly is just a big green and yellow blur they look the same… &lt;a href=&quot;#fnref:clangv&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:warm&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;There are 27 samples total at each size: the first 10 are discarded as warmup and the remaining 17 are plotted. &lt;a href=&quot;#fnref:warm&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:errorbars&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The main problem with error bars are that most performance profiling results, and especially microbenchmarks, are mightly non-normal in their distribution, so displaying an error bar based a statistic like the variance is often highly misleading. &lt;a href=&quot;#fnref:errorbars&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:l2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The ~ is there in ~256 KiB because unless you use huge pages, you might start to see L2 misses even before 256 KiB since only a 256 KiB &lt;em&gt;virtually contiguous&lt;/em&gt; buffer is not necessarily well behaved in terms of evictions: it depends how those 4k pages are mapped to physical pages. As soon as you get too many 4k pages mapping to the same group of sets, you’ll see evictions even before 256 KiB. &lt;a href=&quot;#fnref:l2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:badvec&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;It is worth noting&lt;sup id=&quot;fnref:nested&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:nested&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;28&lt;/a&gt;&lt;/sup&gt; that this performance variation with buffer size isn’t exactly inescapable. Rather, it is just a consequence of poor remainder handling in the compiler’s auto-vectorizer. An approach that would be much faster and generate much less code to handle the remaining elements would be to do a final full-width vector store but aligned to the end of the buffer. So instead of doing up to 7 additional scalar stores, you do one additional vector store (and suffer up to one fewer branch mispredictions for random lengths, since the scalar outro involves conditional jumps). &lt;a href=&quot;#fnref:badvec&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:melty&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Those melty bits where the pattern gets all weird, in the middle and near the right side are not random artifacts: they are consistently reproducible. I suspect a collision in the branch predictor history. &lt;a href=&quot;#fnref:melty&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:silent&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This behavior is interesting and a bit puzzling. There are several reasons why you might want to do a non-silent eviction. (1a) would be to keep the L3 snoop filter up to date: if the L3 knows a core no longer has a copy of the line, later requests for that line can avoid snooping the core and are some 30 cycles faster. (1b) Similarly, if the L3 wants to evict this line, this is faster if it knows it can do it without writing back, versus snooping the owning core for a possibly modified line. (2) Keeping the L3 &lt;abbr title=&quot;Least recently used - an eviction strategy suitable for data with temporal locality&quot;&gt;LRU&lt;/abbr&gt; more up to date: the L3 &lt;abbr title=&quot;Least recently used - an eviction strategy suitable for data with temporal locality&quot;&gt;LRU&lt;/abbr&gt; wants to know which lines are hot, but most of the accesses are filtered through the L1 and L2, so the L3 doesn’t get much information – a non-silent eviction can provide some of the missing info (3) If the L3 serves as a victim cache, the L2 needs to write back the line for it to be stored in L3 at all. &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt; L3 actually works this way, but despite being a very similar &lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt;, &lt;abbr title=&quot;Intel's Skylake (client) architecture, aka 6th Generation Intel Core i3,i5,i7&quot;&gt;SKL&lt;/abbr&gt; apparently doesn’t. However, one can imagine that on a miss to DRAM it may be advantageous to send the line directly to the L2, updating the L3 tags (snoop filter) only, without writing the data into L3. The data only gets written when the line is subsequently evicted from the owning L2. When lines are frequently modified, this cuts the number of writes to L3 in half. This behavior warrants further investigation. &lt;a href=&quot;#fnref:silent&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:silent:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:trust&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;You’ve already seen in Fig. 1 that there is little inter-sample variation, and this keeps the noise down. You can always check the raw data if you want the detailed view. &lt;a href=&quot;#fnref:trust&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:wb&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This shows that the L2 is a write-back cache, not write-through: modified lines can remain in L2 until they are evicted, rather than immediately being written to the outer levels of the memory hierarchy. This type of design is key for high store throughput, since otherwise the long-term store throughput is limited to the bandwidth of the slowest write-through cache level. &lt;a href=&quot;#fnref:wb&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:orl3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I say the L2 because the behavior is already reflected in the L2 performance counters, but it could be teamwork between the L2 and other components, e.g., the L3 could say “OK, I’ve got that line you &lt;abbr title=&quot;Request for ownership: when a request for a cache line originates from a store, or a type of prefetch that predicts the location is likely to be the target of a store, an RFO is performed which gets the line in an exclusive MESI state.&quot;&gt;RFO&lt;/abbr&gt;’d and BTW it is all zeros”. &lt;a href=&quot;#fnref:orl3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:rfo&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Although only stores appear in the source, at the hardware level this benchmark does at least as many reads as stores: every store must do a &lt;em&gt;read for ownership&lt;/em&gt; (&lt;abbr title=&quot;Request for ownership: when a request for a cache line originates from a store, or a type of prefetch that predicts the location is likely to be the target of a store, an RFO is performed which gets the line in an exclusive MESI state.&quot;&gt;RFO&lt;/abbr&gt;) to get the current value of the line before storing to it. &lt;a href=&quot;#fnref:rfo&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:sneaky&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Eagle-eyed readers, all two of them, might notice that the performance in the L3 region is different than the previous figure: here the performance slopes up gradually across most of the L3 range, while in the previous test it was very flat. Absolute performance is also somewhat lower. This is a testing artifact: reading the uncore performance counters necessarily involves a kernel call, taking over 1,000 cycles versus the &amp;lt; 100 cycles required for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdpmc&lt;/code&gt; to measure the CPU performance counters needed for the prior figure. Due to “flaws” (laziness) in the benchmark, this overhead is captured in the shown performance, and larger regions take longer, meaning that this fixed measurement overhead has a smaller relative impact, so you get this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;measured = actual - overhead/size&lt;/code&gt; type effect. It can be fixed, but I have to reboot my host into single-user mode to capture clean numbers, and I am feeling too lazy to do that right now, although as I look back at the size of the footnote I needed to explain it I am questioning my judgement. &lt;a href=&quot;#fnref:sneaky&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:imcevent&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;On &lt;abbr title=&quot;Intel's Skylake (client) architecture, aka 6th Generation Intel Core i3,i5,i7&quot;&gt;SKL&lt;/abbr&gt; client CPUs we can do this with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uncore_imc/data_writes/&lt;/code&gt; events, which polls internal counters in the memory controller itself. This is a socket-wide event, so it is important to do this measurement on as quiet a machine as possible. &lt;a href=&quot;#fnref:imcevent&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:params&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I tried a bunch of other stuff that I didn’t write up in detail. Many of them affect the behavior: we still see the optimization but with different levels of effectiveness. For example, with L2 prefetching off, only about 40% of the L2 evictions are eliminated (versus &amp;gt; 60% with prefetch on), and the performance difference between is close to zero despite the large number of eliminations. I tried other sizes of writes, and with narrow writes the effect is reduced until it is eliminated at 4-byte writes. I don’t think the write size &lt;em&gt;directly&lt;/em&gt; affects the optimization, but rather narrower writes slow down the maximum possible performance which interacts in some way with the hardware mechanisms that support this to reduce how often it occurs (a similar observation could apply to prefetching). &lt;a href=&quot;#fnref:params&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:obbus&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;By &lt;em&gt;outbound queues&lt;/em&gt; I mean the path between an inner and outer cache level. So for the L2, the outbound bus is the so-called &lt;em&gt;superqueue&lt;/em&gt; that connects the L2 to the uncore and L3 cache. &lt;a href=&quot;#fnref:obbus&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:armcompile&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The Graviton 2 uses the Cortex A76 &lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt;, which can &lt;em&gt;execute&lt;/em&gt; 2 stores per cycle, but the L1 cache write ports limits sustained execution to only one 128-bit store per cycle. &lt;a href=&quot;#fnref:armcompile&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:g2ga&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;It was the first full day of general availability for Graviton, so perhaps these hosts are very lightly used at the moment because it certainly felt like I had the whole thing to myself. &lt;a href=&quot;#fnref:g2ga&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:escaping&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;By &lt;em&gt;escaping&lt;/em&gt; I mean that a store that visibly gets to the cache level where this optimization happens. For example, if I write a 1 immediately followed by a 0, the 1 will never make it out of the L1 cache, so from the point of view of the L2 and beyond only a zero was written. I expect the optimization to still trigger in this case. &lt;a href=&quot;#fnref:escaping&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:calloc&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This phenomenon is why &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calloc&lt;/code&gt; is sometimes considerably faster than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;malloc + memset&lt;/code&gt;. With &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calloc&lt;/code&gt; the zeroing happens within the allocator, and the allocator can track whether the memory it is about to return is &lt;em&gt;known zero&lt;/em&gt; (usually because it the block is fresh from the OS, which always zeros memory before handing it out to userspace), and in the case of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calloc&lt;/code&gt; it can avoid the zeroing entirely (so &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calloc&lt;/code&gt; runs as fast as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;malloc&lt;/code&gt; in that case). The client code calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;malloc&lt;/code&gt; doesn’t receive this information and can’t make the same optimization. If you stretch the analogy almost to the breaking point, one can see what Intel is doing here as “similar, but in hardware”. &lt;a href=&quot;#fnref:calloc&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:nested&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Ha! To me, everything is “worth noting” if it means another footnote. &lt;a href=&quot;#fnref:nested&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Travis Downs</name><email>travis.downs@gmail.com</email></author><category term="blog" /><category term="Intel" /><category term="x86" /><category term="uarch" /><summary type="html">Probing a previously undocumented zero-related optimization on Intel CPUs.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://travisdowns.github.io/assets/intel-zero-opt/twitter-card.png" /><media:content medium="image" url="https://travisdowns.github.io/assets/intel-zero-opt/twitter-card.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Adding Staticman Comments</title><link href="https://travisdowns.github.io/blog/2020/02/05/now-with-comments.html" rel="alternate" type="text/html" title="Adding Staticman Comments" /><published>2020-02-05T00:00:00+00:00</published><updated>2020-02-05T00:00:00+00:00</updated><id>https://travisdowns.github.io/blog/2020/02/05/now-with-comments</id><content type="html" xml:base="https://travisdowns.github.io/blog/2020/02/05/now-with-comments.html">&lt;p&gt;I’ve added comments to my blog. You can find the existing comments, if any, and the new comment form &lt;a href=&quot;#comment-section&quot;&gt;at the bottom&lt;/a&gt; of any post.&lt;/p&gt;

&lt;p&gt;I thought this would take a couple hours, but it actually took &lt;strong&gt;[REDACTED]&lt;/strong&gt;. Estimates are hard.&lt;/p&gt;

&lt;p&gt;Here’s what I did.&lt;/p&gt;

&lt;h2 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h2&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#table-of-contents&quot; id=&quot;markdown-toc-table-of-contents&quot;&gt;Table of Contents&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#introduction&quot; id=&quot;markdown-toc-introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#set-up-github-bot-account&quot; id=&quot;markdown-toc-set-up-github-bot-account&quot;&gt;Set Up GitHub Bot Account&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#generate-personal-access-token&quot; id=&quot;markdown-toc-generate-personal-access-token&quot;&gt;Generate Personal Access Token&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#set-up-the-blog-repository-configuration&quot; id=&quot;markdown-toc-set-up-the-blog-repository-configuration&quot;&gt;Set Up the Blog Repository Configuration&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#configuring-staticmanyml&quot; id=&quot;markdown-toc-configuring-staticmanyml&quot;&gt;Configuring staticman.yml&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#configuring-_configyml&quot; id=&quot;markdown-toc-configuring-_configyml&quot;&gt;Configuring _config.yml&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#set-up-the-api-bridge&quot; id=&quot;markdown-toc-set-up-the-api-bridge&quot;&gt;Set Up the API Bridge&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#generate-an-rsa-keypair&quot; id=&quot;markdown-toc-generate-an-rsa-keypair&quot;&gt;Generate an RSA Keypair&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sign-up-for-heroku&quot; id=&quot;markdown-toc-sign-up-for-heroku&quot;&gt;Sign Up for Heroku&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deploy-staticman-bridge-to-heroku&quot; id=&quot;markdown-toc-deploy-staticman-bridge-to-heroku&quot;&gt;Deploy Staticman Bridge to Heroku&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#configure-bridge-secrets&quot; id=&quot;markdown-toc-configure-bridge-secrets&quot;&gt;Configure Bridge Secrets&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#invite-and-accept-bot-to-blog-repo&quot; id=&quot;markdown-toc-invite-and-accept-bot-to-blog-repo&quot;&gt;Invite and Accept Bot to Blog Repo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#enable-recaptcha&quot; id=&quot;markdown-toc-enable-recaptcha&quot;&gt;Enable reCAPTCHA&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#sign-up-for-recaptcha&quot; id=&quot;markdown-toc-sign-up-for-recaptcha&quot;&gt;Sign Up for reCAPTCHA&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#configure-recaptcha&quot; id=&quot;markdown-toc-configure-recaptcha&quot;&gt;Configure reCAPTCHA&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#integrate-comments-into-site&quot; id=&quot;markdown-toc-integrate-comments-into-site&quot;&gt;Integrate Comments Into Site&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#markdown-part&quot; id=&quot;markdown-toc-markdown-part&quot;&gt;Markdown Part&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#testing-on-this-post&quot; id=&quot;markdown-toc-testing-on-this-post&quot;&gt;Testing on This Post&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#thanks&quot; id=&quot;markdown-toc-thanks&quot;&gt;Thanks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#references&quot; id=&quot;markdown-toc-references&quot;&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;I am using &lt;a href=&quot;https://staticman.net/&quot;&gt;staticman&lt;/a&gt;, created by &lt;a href=&quot;https://github.com/eduardoboucas&quot;&gt;Eduardo Bouças&lt;/a&gt;, as my comments system for this static site.&lt;/p&gt;

&lt;p&gt;The basic flow for comment submission is as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A reader submits the comment form on a blog post.&lt;/li&gt;
  &lt;li&gt;Javascript&lt;sup id=&quot;fnref:backup&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:backup&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; attached to the form submits it to my &lt;em&gt;staticman API bridge&lt;sup id=&quot;fnref:bridge&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:bridge&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt; running on Heroku.&lt;/li&gt;
  &lt;li&gt;The API bridge does some validation of the request and submits a &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io/issues&quot;&gt;pull request&lt;/a&gt; to the github repo hosting my blog, consisting of a .yml file with the post content and meta data.&lt;/li&gt;
  &lt;li&gt;When I accept the pull request, it triggers a regeneration and republishing of the content (this is a GitHub pages feature), so the reply appears almost immediately&lt;sup id=&quot;fnref:cache&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:cache&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here are the detailed steps to get this working. There are several other tutorials out there, with varying states of exhaustiveness, some of which
I found only after writing most of this, but I’m going to add the pile anyways. There have been several changes to deploying staticman which mean that existing resources (and this one, of course) are marked by which “era” they were written in.&lt;/p&gt;

&lt;p&gt;The major changes are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;At one point the idea was that everyone would use the public staticman API bridge, but this proved unsustainable. A large amount of the work in setting up staticman is associated with running your own instance of the bridge.&lt;/li&gt;
  &lt;li&gt;There are three version of the staticman API: v1, v2 and v3. This guide uses v2 (although v3 is almost identical&lt;sup id=&quot;fnref:v3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:v3&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;), but the v1 version is considerably different.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;set-up-github-bot-account&quot;&gt;Set Up GitHub Bot Account&lt;/h2&gt;

&lt;p&gt;You’ll want to create a GitHub &lt;em&gt;bot account&lt;/em&gt; which will be the account that the API bridge uses to actually submit the pull requests to your blog repository. In principle, you can skip this step entirely and simply use your existing GitHub account, but I wouldn’t recommend it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You’ll be generating a &lt;em&gt;personal access token&lt;/em&gt; for this account, and uploading it to the cloud (Heroku) and if this somehow gets compromised, it’s better that it’s a throwaway bot account than your real account.&lt;/li&gt;
  &lt;li&gt;Having a dedicated account makes it easy to segregate work done by the bot, versus what you’ve done yourself. That is, you probably don’t want all the commits and pushes the bot does to show up on your personal account.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;em&gt;bot account&lt;/em&gt; is nothing special: it is just a regular personal account that you’ll only be using from the API bridge. So, open a private browser window, go to &lt;a href=&quot;https://github.com&quot;&gt;GitHub&lt;/a&gt; and choose “Sign Up”. Call your bot something specific, which I’ll refer to as &lt;em&gt;GITHUB-BOT-NAME&lt;/em&gt; from here forwards.&lt;/p&gt;

&lt;h3 id=&quot;generate-personal-access-token&quot;&gt;Generate Personal Access Token&lt;/h3&gt;

&lt;p&gt;Next, you’ll need to generate a GitHub &lt;em&gt;personal access token&lt;/em&gt;, for your bot account. The &lt;a href=&quot;https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line&quot;&gt;GitHub doc&lt;/a&gt; does a better job of explaining this than I can. If you just want everything to work for sure now and in the future, select every single scope when it prompts you, but if you care about security you should only need the &lt;em&gt;repo&lt;/em&gt; and &lt;em&gt;user&lt;/em&gt; scopes (today):&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Repo scope:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/now-with-comments/scopes-repo.png&quot; alt=&quot;Repo scope&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;User scope:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/now-with-comments/scopes-user.png&quot; alt=&quot;User scope&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Copy and paste the displayed token somewhere safe: you’ll need this token in a later step where I’ll refer to it as  &lt;em&gt;${github_token}&lt;/em&gt;. Once you close this page there is no way to recover the access token.&lt;/p&gt;

&lt;h2 id=&quot;set-up-the-blog-repository-configuration&quot;&gt;Set Up the Blog Repository Configuration&lt;/h2&gt;

&lt;p&gt;You’ll need to include configuration for staticman in two separate places in your blog repository: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; (the primary Jekyll config file) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;staticman.yml&lt;/code&gt;, both at the top level of the repository.&lt;/p&gt;

&lt;p&gt;In general, the stuff that goes in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; is for use within the static generation phase of your site, e.g., controlling the generation of the comment form and the associated javascipt. The stuff in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;staticman.yml&lt;/code&gt; isn’t used during generation, but is used dynamically by the API bridge (read directly from GitHub on each request) to configure the activities of the bridge. A few thigns are duplicated in both places.&lt;/p&gt;

&lt;h3 id=&quot;configuring-staticmanyml&quot;&gt;Configuring staticman.yml&lt;/h3&gt;

&lt;p&gt;Most of the configuration for the ABI bridge is set in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;staticman.yml&lt;/code&gt; which lives in the top level of your &lt;em&gt;blog repository&lt;/em&gt;. This means that one API bridge can support many different blog repositories, each with their own configuration (indeed, this feature was critical for the original design of a shared ABI bridge).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/eduardoboucas/staticman/blob/master/staticman.sample.yml&quot;&gt;Here’s a sample file&lt;/a&gt; from the staticman GitHub repository, but you might want to use &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io/blob/master/staticman.yml&quot;&gt;this one&lt;/a&gt; from my repository as it is a bit more fleshed out.&lt;/p&gt;

&lt;p&gt;The main things you want to change are shown below.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;# all of these fields are nested under the comments key, which corresponds to the final element&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# of the API bridge enpoint, i.e., you can different configurations even within the same staticman.yml&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# file all under different keys&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;comments&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# There are many more required config values here, not shown:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# use the file linked above as a template&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# I guess used only for email notifications?&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Performance&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Matters&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Blog&quot;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# You may want a different set of &quot;required fields&quot;. Staticman will&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# reject posts without all of these fields&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;requiredFields&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;name&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;email&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;message&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# you are going to want reCaptcha set up, but for now leave it disabled because we need the API&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# bridge up and running in order to encrypt the secrets that go in this section&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;reCaptcha&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#  siteKey: 6LcWstQUAAAAALoGBcmKsgCFbMQqkiGiEt361nK1&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#  secret: a big encrypted secret (see Note above)&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;configuring-_configyml&quot;&gt;Configuring _config.yml&lt;/h3&gt;

&lt;p&gt;The remainder of the configuration goes in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;. Here’s the configuration I added to start with (we’ll add a bit more later):&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# The URL for the staticman API bridge endpoint&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# You will want to modify some of the values:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#  ${github-username}: the username of the account with which you publish your blog&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#  ${blog-repo}: the name of your blog repository in github&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#  master: this the branch out of which your blog is published, often master or gh-pages&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#  ${bridge_app_name}: the name you chose in Heroku for your bridge API&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#  comments: the so-called property, this defines the key in staticman.yml where the configuration is found&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# for me, this line reads:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# https://staticman-travisdownsio.herokuapp.com/v2/entry/travisdowns/travisdowns.github.io/master/comments&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;staticman_url&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;https://${bridge_app_name}.herokuapp.com/v2/entry/${github-username}/${blog-repo}/master/comments&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;set-up-the-api-bridge&quot;&gt;Set Up the API Bridge&lt;/h2&gt;

&lt;p&gt;This section covers deploying a private instances of the API bridge to Heroku.&lt;/p&gt;

&lt;h3 id=&quot;generate-an-rsa-keypair&quot;&gt;Generate an RSA Keypair&lt;/h3&gt;

&lt;p&gt;This keypair will be used to encrypt secrets that will be stored in public places, such as your reCAPTCHA site secret. The sececrets will be encrypted with the public half of the keypair, and decriped in the Bridge API server with the private part.&lt;/p&gt;

&lt;p&gt;Use the following on your local to generate to generate the pair:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-keygen -m PEM -t rsa -b 4096 -C &quot;staticman key&quot; -f ~/.ssh/staticman_key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Don’t use any passphrase&lt;sup id=&quot;fnref:pass&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:pass&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;. You can change the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-f&lt;/code&gt; argument if you want to save the key somewhere else, in which case you’ll have to use the new location when setting up the Heroku config below.&lt;/p&gt;

&lt;p&gt;You can verify the key was genreated by running:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;head -2 ~/.ssh/staticman_key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Which should output something like:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----BEGIN RSA PRIVATE KEY-----
MIIJKAIBAAKCAgEAud7+fPWXzuxCoyyGbQTYCGi9C1N984roI/Tr7yJi074F+Cfp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Your second line will vary of course, but the first line must be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-----BEGIN RSA PRIVATE KEY-----&lt;/code&gt;. If you see something else, perhaps mentioning &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OPENSSH PRIVATE KEY&lt;/code&gt;, it won’t work.&lt;/p&gt;

&lt;h3 id=&quot;sign-up-for-heroku&quot;&gt;Sign Up for Heroku&lt;/h3&gt;

&lt;p&gt;The original idea of staticman was to have a public API bridge that everyone uses for free. However, in practice this hasn’t proved sustainable as whatever free tier the thing was running on tends to hit its limits and then the fun stops. So the current recommendation is to set up a free instance of the API bridge on Heroku. So let’s do that.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://signup.heroku.com/&quot;&gt;Sign up&lt;/a&gt; for a free account on Heroku. No credit card is required and a free account should give you enough juice for at least 1,000 comments a month&lt;sup id=&quot;fnref:juice&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:juice&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h3 id=&quot;deploy-staticman-bridge-to-heroku&quot;&gt;Deploy Staticman Bridge to Heroku&lt;/h3&gt;

&lt;p&gt;The easiest way to do this is simply to click the &lt;em&gt;Deploy to Heroku&lt;/em&gt; button in the &lt;a href=&quot;https://github.com/eduardoboucas/staticman&quot;&gt;README on the staticman repo&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/now-with-comments/deploy.png&quot; alt=&quot;Deploy&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You’ll see probably some logging indicating that the project is downloading, building and then successfully deployed.&lt;/p&gt;

&lt;h3 id=&quot;configure-bridge-secrets&quot;&gt;Configure Bridge Secrets&lt;/h3&gt;

&lt;p&gt;The bridge needs a couple of secrets to do its job:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The &lt;em&gt;GitHub personal access token&lt;/em&gt; of your bot account. This lets it do work on behalf of your bot account (in particular, submit pull requests to your blog repository).&lt;/li&gt;
  &lt;li&gt;The private key of the keypair you generated earlier.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you want, you can add both of these through the Heroku web dashboard: go to Settings -&amp;gt; Reveal Config Vars, and enter them &lt;a href=&quot;/assets/now-with-comments/config-vars.png&quot;&gt;like this&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;However, you might as well get familiar with the Heroku command line, because it’s pretty cool and allows you to complete this flow without having your GitHub token flow through your clipboard and makes it easy to remove the newline characters in the private key.&lt;/p&gt;

&lt;p&gt;Follow &lt;a href=&quot;https://devcenter.heroku.com/articles/heroku-cli&quot;&gt;the instructions&lt;/a&gt; to install and login to the Heroku CLI, then issue the following commands from any directory (note that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;${github_token}&lt;/code&gt; is the &lt;em&gt;personal access token&lt;/em&gt; you generated earlier: copy and paste it into the command):&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;heroku config:add &lt;span class=&quot;nt&quot;&gt;--app&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;bridge_app_name&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;RSA_PRIVATE_KEY=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; ~/.ssh/staticman_key | &lt;span class=&quot;nb&quot;&gt;tr&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
heroku config:add &lt;span class=&quot;nt&quot;&gt;--app&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;bridge_app_name&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;GITHUB_TOKEN=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;github_token&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tr -d '\n'&lt;/code&gt; part of the pipeline is removing the newlines from the private key, since Heroku config variables can’t handle them and/or the API bridge can’t handle them.&lt;/p&gt;

&lt;p&gt;You can check that the config was correctly set by outputting it as follows:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;heroku config &lt;span class=&quot;nt&quot;&gt;--app&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;bridge_app_name&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;invite-and-accept-bot-to-blog-repo&quot;&gt;Invite and Accept Bot to Blog Repo&lt;/h2&gt;

&lt;p&gt;Finally, you need to invite your GitHub &lt;em&gt;bot account&lt;/em&gt; that you created earlier to your blog repository&lt;sup id=&quot;fnref:whycollab&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:whycollab&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt; and accept the invite.&lt;/p&gt;

&lt;p&gt;Open your blog repository, go to &lt;em&gt;Settings -&amp;gt; Collaborators&lt;/em&gt; and search for and add the GitHub bot account that you created earlier as a collaborator:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/now-with-comments/add-collab.png&quot; alt=&quot;Adding Collaborators&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next, accept&lt;sup id=&quot;fnref:invite&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:invite&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt; the invitation using the bridge API, by going to the following URL:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://${bridge_app_name}.herokuapp.com/v2/connect/${github-username}/${blog-repo}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You should see &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OK!&lt;/code&gt; as the output if it worked: this only appears &lt;em&gt;once&lt;/em&gt; when the invitation got accepted, at all other times it will show &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Invitation not found&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;enable-recaptcha&quot;&gt;Enable reCAPTCHA&lt;/h2&gt;

&lt;p&gt;You are going to want to gate comment submission using reCAPTCHA or a similar system so you don’t get destroyed by spam (even if you have moderation enabled, dealing with all the pull requests will probably be tiring).&lt;/p&gt;

&lt;p&gt;Here we’ll cover setting up reCAPTCHA, which has built-in support in staticman. Although it involves modifying the same &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;staticman.yml&lt;/code&gt; files that we’ve modified before, this part of the configuration needs to occur after the bridge is running because we use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/encrypt&lt;/code&gt; endpoint on the bridge as part of the setup.&lt;/p&gt;

&lt;h3 id=&quot;sign-up-for-recaptcha&quot;&gt;Sign Up for reCAPTCHA&lt;/h3&gt;

&lt;p&gt;Go to &lt;a href=&quot;https://developers.google.com/recaptcha&quot;&gt;reCAPTCHA&lt;/a&gt; and sign up if you haven’t already, and create a new site. We are going to use the “v2, Checkbox” variant (&lt;a href=&quot;https://developers.google.com/recaptcha/docs/display&quot;&gt;docs here&lt;/a&gt;), although I’m interested to hear how it works out with other variants.&lt;/p&gt;

&lt;p&gt;You will need the reCAPTCHA &lt;em&gt;site key&lt;/em&gt; and &lt;em&gt;secret key&lt;/em&gt; for configuration in the next section.&lt;/p&gt;

&lt;h3 id=&quot;configure-recaptcha&quot;&gt;Configure reCAPTCHA&lt;/h3&gt;

&lt;p&gt;Next, we need to add the &lt;em&gt;site key&lt;/em&gt; and &lt;em&gt;secret key&lt;/em&gt; to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;staticman.yml&lt;/code&gt; config files.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;site key&lt;/em&gt; will be used as-is, but the &lt;em&gt;secret key&lt;/em&gt; property will be &lt;a href=&quot;https://staticman.net/docs/encryption&quot;&gt;&lt;em&gt;encrypted&lt;/em&gt;&lt;/a&gt; so that it is not exposed in plaintext in your configuration files. To encrypt the secret key copy the secret from the reCAPTCHA admin console, and load the following URL from your API bridge, replacing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YOUR_SITE_KEY&lt;/code&gt; at with the copied secret key.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://${bridge_app_name}.herokuapp.com/v2/encrypt/YOUR_SITE_KEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You should get a blob of characters back as a result (considerably longer than the original secret) – it is &lt;em&gt;this&lt;/em&gt; value that you need to include as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reCaptcha.secret&lt;/code&gt; in both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;staticman.yml&lt;/code&gt; and in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The reCAPTCHA configuration for both files is almost the same. It looks like this for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;staticman.yml&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;comments&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# more stuff&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# note that reCaptcha is nested under comments&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;reCaptcha&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# the siteKey is used as-is (no encryption)&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;siteKey&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;6LcWstQUAAAAALoGBcmKsgCFbMQqkiGiEt361nK1&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# the secret is the encrypted blob you got back from the encrypt call&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;secret&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;a big encrypted secret (see description above)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; version is similar except that they key appears at the top level and there is no enabled property:&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# reCaptcha configuration info: the exact same site key and *encrypted* secret that you used in staticman.yml&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# I personally don't think the secret needs to be included in the generated site, but the staticman API bridge uses&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# it to ensure the site configuration and bridge configuration match (but why not just compare the site key?)&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;reCaptcha&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;siteKey&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;6LcWstQUAAAAALoGBcmKsgCFbMQqkiGiEt361nK1&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;secret&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;exactly the same secret as the staticman.yml file&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;integrate-comments-into-site&quot;&gt;Integrate Comments Into Site&lt;/h2&gt;

&lt;p&gt;Finally, you need to integrate code to display the existing comments and submit new comments.&lt;/p&gt;

&lt;p&gt;I used a mash up of commenting code from the &lt;a href=&quot;https://spinningnumbers.org&quot;&gt;spinningnumbers.org&lt;/a&gt; blog as well as the staticman integration in the &lt;a href=&quot;https://mmistakes.github.io/minimal-mistakes/docs/configuration/#static-based-comments-via-staticman&quot;&gt;minimal mistakes theme&lt;/a&gt;. The advantage the former has over the latter is that the comments allow one level of nesting (replies to top-level comments are nested beneath it).&lt;/p&gt;

&lt;p&gt;I planed to extract the associated markdown, liquid and JavaScript code to a separate repository as a single point where people could collaborate on this part of the integration, but man I’ve already spent way to long on this. I may still do it, but for now here’s how I did the integration.&lt;/p&gt;

&lt;h3 id=&quot;markdown-part&quot;&gt;Markdown Part&lt;/h3&gt;

&lt;p&gt;The key thing you need to do is include a blob of HTML and associated JavaScript in any page where you want to display and accept comments. I do this as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% if page.comments == true %}
  {% include comments.html %}
{% endif %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can paste it into any post, or better add it to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;footer.html&lt;/code&gt; include or something like that (details depend on your theme). The invariant is that wherever this appears, the existing comments appear, followed by a form to submit new comments. You can see the &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io/blob/master/_includes/comments.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comments.html&lt;/code&gt; include here&lt;/a&gt; – in turn, it includes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comment.html&lt;/code&gt; (once per comment, generates the comment html) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comment_form.html&lt;/code&gt; which generates the new comment form.&lt;/p&gt;

&lt;p&gt;This ultimately includes &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io/blob/4a57e4f6d8cb4ef0ac8801a31740d1ca32dfa8ae/_includes/comments.html#L28&quot;&gt;external JavaScript&lt;/a&gt; for JQuery and reCAPTCHA, as well as &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io/blob/master/assets/main.js&quot;&gt;main.js&lt;/a&gt; which includes the JavaScript to implement the replies (moving the form when the “reply to” button is clicked, and submitting the form via AJAX to the API bridge).&lt;/p&gt;

&lt;p&gt;You can try to use this same integration in your Jekyll blog. You’d need to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Copy the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_includes/comment.html&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_includes/comments.html&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_includes/comment_form.html&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assets/main.js&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_sass/comment-styles.css&lt;/code&gt; from my &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io&quot;&gt;blog files&lt;/a&gt; to your blog repository.&lt;/li&gt;
  &lt;li&gt;In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assets/main.js&lt;/code&gt;, replace the link to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://github.com/travisdowns/travisdowns.github.io/pulls&lt;/code&gt; with a link to your own repository (or otherwise customize the “success” message as you see fit).&lt;/li&gt;
  &lt;li&gt;Include &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@import &quot;comment-styles&quot;;&lt;/code&gt; in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assets/main.scss&lt;/code&gt; file. If you don’t have one, you’ll need to create it following the rules for your theme. Usually this just means a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.scss&lt;/code&gt; with empty front-matter and an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@import &quot;your-theme&quot;;&lt;/code&gt; line to import the theme SCSS. Alternately, you could avoid putting anything in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.scss&lt;/code&gt; and just include the comment styles as a separate file, but this adds another request to each post.&lt;/li&gt;
  &lt;li&gt;Do the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include comments.html&lt;/code&gt; thing shown above in an appropriate place in your template/theme.&lt;/li&gt;
  &lt;li&gt;Set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comments: true&lt;/code&gt; in the front matter of posts you want to have comments (or set it as a default in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;testing-on-this-post&quot;&gt;Testing on This Post&lt;/h2&gt;

&lt;p&gt;If you want to leave a non-trivial comment on the content of this post, you can do so below. However, if you’d instead like to make a “just testing” post, to see how the http request works, or check the  created pull request, etc, please do it &lt;a href=&quot;/misc/comments-test.html&quot;&gt;over here&lt;/a&gt;. Testing only comments made on this post will be closed without accepting them.&lt;/p&gt;

&lt;h2 id=&quot;thanks&quot;&gt;Thanks&lt;/h2&gt;

&lt;p&gt;Thanks to Eduardo Boucas for creating staticman.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://spinningnumbers.org/&quot;&gt;Willy McAllister&lt;/a&gt; for nested comment display work I unabashedly cribbed, and helping me sort out an RSA key genreation problem, and pointing out some inconsistencies in the doc.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;p&gt;Things that were handy references while getting this working.&lt;/p&gt;

&lt;p&gt;This comment on &lt;a href=&quot;https://github.com/eduardoboucas/staticman/issues/318#issuecomment-552755165&quot;&gt;GitHub issue #318&lt;/a&gt; was the list that I more or less follwed (I didn’t use the dev branch though).&lt;/p&gt;

&lt;p&gt;Willy McAllister describes setting up staticman &lt;a href=&quot;https://spinningnumbers.org/a/staticman.html&quot;&gt;in this post&lt;/a&gt; – his implemented of nested comments forms the basis the one I used.&lt;/p&gt;

&lt;p&gt;Another &lt;a href=&quot;https://gist.github.com/jannispaul/3787603317fc9bbb96e99c51fe169731&quot;&gt;list of steps&lt;/a&gt; to get staticman working and some troubleshooting.&lt;/p&gt;

&lt;p&gt;Michael Rose, the author of minimal mistakes Jekyll theme &lt;a href=&quot;https://mademistakes.com/articles/improving-jekyll-static-comments/&quot;&gt;describes setting up nested staticman comments&lt;/a&gt; – I cribbed some stuff from here such as the submitting spinner.&lt;/p&gt;

&lt;p&gt;Willy McAllister subsequently wrote a &lt;a href=&quot;https://spinningnumbers.org/a/staticman-heroku.html&quot;&gt;great guide&lt;/a&gt; to setting up Staticman, similar in nature to this one but with some additional sections such as &lt;em&gt;troubleshooting&lt;/em&gt; and setting up reply notifications via MailGun. If that one was around when I started out, I wouldn’t have felt the need to write this one.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:backup&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;If javascript is disabled, a regular POST action takes over. &lt;a href=&quot;#fnref:backup&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:bridge&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I don’t think you’ll find this &lt;em&gt;bridge&lt;/em&gt; term in the official documentation, but I’m going to use it here. &lt;a href=&quot;#fnref:bridge&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:cache&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Well, subject to whatever edge caching GitHub pages is using – btw you can bust the cache by appending any random query parameter to the page: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...post.html?foo=1234&lt;/code&gt;. &lt;a href=&quot;#fnref:cache&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:v3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;v3 mostly just extends to the URL format for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/event&lt;/code&gt; endpoint to include the hosting provider (either GitHub or GitLab), allowing the use of GitHub in addition to GitLab. Almost everything in this guide would remain unchanged. &lt;a href=&quot;#fnref:v3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:pass&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;You could use a passphrase, but then you’ll have to change the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat&lt;/code&gt; used below to echo the key into the Heroku config. If you want to be super safe, best is to generate the key to a transient location like ramfs and then simply delete the private portion after you’ve uploaded it to the Heroku config. &lt;a href=&quot;#fnref:pass&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:juice&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In particular, the &lt;em&gt;unverified&lt;/em&gt; (no credit card) free tier gives you 550 hours of uptime a month, and since the &lt;em&gt;dyno&lt;/em&gt; (heroku speak for their on-demand host) sleeps after 30 minutes, I figure you can handle 550/0.5 = 1100 sparsely submitted comments. Of course, if comments come in bursts, you could handle much more than that, since you’ve already “paid” for the 30 minute uptime. &lt;a href=&quot;#fnref:juice&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:whycollab&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The bot needs to be a collaborator to, at a minimum, commit comments to the repository, and to delete branches (using the delete branches webhook which cleans up comment related branches). However, it is possible to not use either of these features if you have moderation enabled (in which case comments arrive as a PR, which doesn’t require any particular permissions), and aren’t using the webhook. So maybe you could do without the collaborator status in that case? I haven’t tested it. &lt;a href=&quot;#fnref:whycollab&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:invite&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I guess you can also just accept the invitation by opening the email sent to you by github and following the link there. This workflow involving the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v2/connect&lt;/code&gt; endpoint probably made more sense when the API was meant to be shared among many uses using a common github bot account. &lt;a href=&quot;#fnref:invite&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Travis Downs</name><email>travis.downs@gmail.com</email></author><category term="blog" /><category term="meta" /><category term="staticman" /><summary type="html">Adding static comments to a static blog using staticman. Static.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://travisdowns.github.io/assets/now-with-comments/twitter-card.png" /><media:content medium="image" url="https://travisdowns.github.io/assets/now-with-comments/twitter-card.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">The Hunt for the Fastest Zero</title><link href="https://travisdowns.github.io/blog/2020/01/20/zero.html" rel="alternate" type="text/html" title="The Hunt for the Fastest Zero" /><published>2020-01-20T00:00:00+00:00</published><updated>2020-01-20T00:00:00+00:00</updated><id>https://travisdowns.github.io/blog/2020/01/20/zero</id><content type="html" xml:base="https://travisdowns.github.io/blog/2020/01/20/zero.html">&lt;p&gt;Let’s say I ask you to fill a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; array of size &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; with zeros. I don’t know why, exactly, but please play along for now.&lt;/p&gt;

&lt;p&gt;If this were C, we would probably reach for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt;, but let’s pretend we are trying to write idiomatic C++ instead.&lt;/p&gt;

&lt;p&gt;You might come up with something like&lt;sup id=&quot;fnref:function&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:function&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fill1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I’d give this solution full marks. In fact, I’d call it more or less the canonical modern C++ solution to the problem.&lt;/p&gt;

&lt;p&gt;What if told you there was a solution that was up to about 29 times faster? It doesn’t even require sacrificing any goats to the C++ gods, either: just adding three characters:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fill2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Yes, switching &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'\0'&lt;/code&gt; speeds this up by nearly a factor of &lt;em&gt;thirty&lt;/em&gt; on my &lt;abbr title=&quot;Intel's Skylake (client) architecture, aka 6th Generation Intel Core i3,i5,i7&quot;&gt;SKL&lt;/abbr&gt; box&lt;sup id=&quot;fnref:qb&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:qb&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;, at least with my default compiler (gcc) and optimization level (-O2):&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Function&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Bytes / Cycle&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;fill1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fill2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;29.1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The why is becomes obvious if you look at the &lt;a href=&quot;https://godbolt.org/z/O_f3Jx&quot;&gt;assembly&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;fill1:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;fill1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;je&lt;/span&gt;      &lt;span class=&quot;nv&quot;&gt;.L1&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.L3:&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;BYTE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; store 0 into memory at [rdi]&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;; increment rdi&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;; compare rdi to size&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;jne&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;.L3&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;; keep going if rdi &amp;lt; size&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.L1:&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This version is using a byte-by-byte copy loop, which I’ve annotated – it is more or less a 1:1 translation of how you’d imagine &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt; is written. The result of 1 cycle per byte is exactly what we’d expect using &lt;a href=&quot;/blog/2019/06/11/speed-limits.html&quot;&gt;speed limit analysis&lt;/a&gt;: it is simultaneously limited by two different bottlenecks: 1 taken branch per cycle, and 1 store per cycle.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill2&lt;/code&gt; version doesn’t have a loop at all:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;fill2:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;fill2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;jne&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;.L8&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;; skip the memcpy call if size == 0&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;ret&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.L8:&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;xor&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;jmp&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;memset&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;; tailcall to memset&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Rather, it simply defers immediately to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt;. We aren’t going to dig into the assembly for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; here, but the fastest possible &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; would run at 32 bytes/cycle, limited by 1 store/cycle and maximum vector the width of 32 bytes on my machine, so the measured value of 29 bytes/cycle indicates it’s using an implementation something along those lines.&lt;/p&gt;

&lt;p&gt;So that’s the &lt;em&gt;why&lt;/em&gt;, but what’s the &lt;em&gt;why of the why&lt;/em&gt; (second order why)?&lt;/p&gt;

&lt;p&gt;I thought this had something to do with the optimizer. After all, at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-O3&lt;/code&gt; even the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill1&lt;/code&gt; version using the plain &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; constant calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I was wrong, however. The answer actually lies in the implementation of the C++ standard library (there are various, gcc is using libstdc++ in this case). Let’s take a look at the implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt; (I’ve reformatted the code for clarity and removed some compile-time concept checks):&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cm&quot;&gt;/*
   *  ...
   *
   *  This function fills a range with copies of the same value.  For char
   *  types filling contiguous areas of memory, this becomes an inline call
   *  to @c memset or @c wmemset.
  */&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;_ForwardIterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_ForwardIterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_ForwardIterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__fill_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__niter_base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__niter_base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The included part of the comment&lt;sup id=&quot;fnref:wmem&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:wmem&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; already hints at what is to come: the implementor of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt; has apparently considered specifically optimizing the call to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; in some scenarios. So we keep following the trail, which brings us to the helper method &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::__fill_a&lt;/code&gt;. There are two overloads that are relevant here, the general method and an overload which handles the special case:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;_ForwardIterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;__gnu_cxx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__enable_if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__is_scalar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__type&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;__fill_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_ForwardIterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_ForwardIterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Specialization: for char types we can use memset.&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;__gnu_cxx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__enable_if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__is_byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__type&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;__fill_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;__builtin_memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we see how the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; appears. It is called explicitly by the second implementation shown above, selected by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enable_if&lt;/code&gt; when the SFINAE condition &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__is_byte&amp;lt;_Tp&amp;gt;&lt;/code&gt; is true. Note, however, that unlike the general function, this variant has a single template argument: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;template&amp;lt;typename _Tp&amp;gt;&lt;/code&gt;, and the function signature is:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;__fill_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hence, it will only be considered when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__first&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__last&lt;/code&gt; pointers which delimit the range have the &lt;em&gt;exact same type as the value being filled&lt;/em&gt;. When when you write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill(p, p + n, 0)&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char *&lt;/code&gt;, you rely on template type deduction for the parameters, which ends up deducing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char *&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; for the iterator type and value-to-fill type, &lt;em&gt;because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; is an integer constant&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;That is, it is if you had written:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This prevents the clever &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; optimization from taking place: the overload that does it is never called because the iterator value type is different than the value-to-fill type.&lt;/p&gt;

&lt;p&gt;This suggests a fix: we can simply force the template argument types rather than rely on type deduction:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fill3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This way, we &lt;a href=&quot;https://godbolt.org/z/VTssh9&quot;&gt;get the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; version&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, why does &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill2&lt;/code&gt; using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'\0'&lt;/code&gt; get the fast version, without forcing the template arguments? Well &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'\0'&lt;/code&gt; is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; constant, so the value-to-assign type is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt;. You could achieve the same effect with a cast, e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static_cast&amp;lt;char&amp;gt;(0)&lt;/code&gt; – and for buffers which have types like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsigned char&lt;/code&gt; this is necessary because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'\0'&lt;/code&gt; does not have the same type as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsigned char&lt;/code&gt; (at least &lt;a href=&quot;https://godbolt.org/z/YQKp7V&quot;&gt;on gcc&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;One might reasonably ask if this could be fixed in the standard library. I think so.&lt;/p&gt;

&lt;p&gt;One idea would be to keying off of &lt;em&gt;only&lt;/em&gt; the type of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last&lt;/code&gt; pointers, like this:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;_Tvalue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;__gnu_cxx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__enable_if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__is_byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__type&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;__fill_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tvalue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tvalue&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;__builtin_memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This says: who cares about the type of the value, it is going to get converted during assignment to the value type of the pointer anyways, so just look at the pointer type. E.g., if the type of the value-to-assign &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_Tvalue&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;, but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_Tp&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; then this expands to this version, which is totally equivalent:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;__fill_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;__builtin_memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This works … for simple types like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;. Where it fails is if the value to fill has a tricky, non-primitive type, like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct conv_counting_int {
    int v_;
    mutable size_t count_ = 0;

    operator char() const {
        count_++;
        return (char)v_;
    }
};

size_t fill5(char *p, size_t n) {
    conv_counting_int zero{0};
    std::fill(p, p + n, zero);
    return zero.count_;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the pointer type passed to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt;, but you cannot safely apply the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; optimization above, since the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;conv_counting_int&lt;/code&gt; counts the number of times it is converted to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt;, and this value will be wrong (in particular, it will be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, not &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;) if you perform the above optimization.&lt;/p&gt;

&lt;p&gt;This can be fixed. You could limit the optimization to the case where the pointer type is char-like &lt;em&gt;and&lt;/em&gt; the value-to-assign type is “simple” in the sense that it won’t notice how many times it has been converted. A sufficient check would be that the type is scalar, i.e. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::is_scalar&amp;lt;T&amp;gt;&lt;/code&gt; – although there is probably a less conservative check possible. So something like this for the SNIFAE check:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;_Tpointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;__gnu_cxx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__enable_if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__is_byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Tpointer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__is_scalar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__type&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;__fill_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tpointer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_Tpointer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here’s &lt;a href=&quot;https://godbolt.org/z/PXRWSB&quot;&gt;an example&lt;/a&gt; of how that would work. It’s not fully fleshed out but shows the idea.&lt;/p&gt;

&lt;p&gt;Finally, one might ask why &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; &lt;em&gt;is&lt;/em&gt; used when gcc is run at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-O3&lt;/code&gt; or when clang is used (&lt;a href=&quot;https://godbolt.org/z/9nhWAh&quot;&gt;like this&lt;/a&gt;). The answer is the optimizer. Even if the compile-time semantics of the language select what appears to a byte-by-byte copy loop, the compiler itself can transform that into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt;, or something else like a vectorized loop, if it can prove it is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;as-if&lt;/code&gt; equivalent. That recognition happens at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-O3&lt;/code&gt; for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gcc&lt;/code&gt; but at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-O2&lt;/code&gt; for clang.&lt;/p&gt;

&lt;h3 id=&quot;what-does-it-mean&quot;&gt;What Does It Mean&lt;/h3&gt;

&lt;p&gt;So what does it all mean? Is there a moral to this story?&lt;/p&gt;

&lt;p&gt;Some use this as evidence that the somehow C++ and/or the STL are irreparably broken. I don’t agree. Some other languages, even “fast” ones, will &lt;em&gt;never&lt;/em&gt; give you the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; speed, although many will - but many of those that do (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.Arrays.fill()&lt;/code&gt;) do it via special recognition or handling of the function by the compiler or runtime. In the C++ standard library, the optimization the library writers have done is available to anyone, which is a big advantage. That the optimization fails, perhaps unexpectedly, in some cases is unfortunate but it’s nice that you can fix it yourself.&lt;/p&gt;

&lt;p&gt;Also, C++ gets &lt;em&gt;two&lt;/em&gt; shots at this one: many other languages rely on the compiler to optimize these patterns, and this also occurs in C++. It’s just a bit of a quirk of gcc that optimization doesn’t help here: it doesn’t vectorize at -O2, nor does it do &lt;em&gt;idiom recognition&lt;/em&gt;. Both of those result in much faster code: we’ve seen the effect of idiom recognition already: it results in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt;. Even if idiom recognition wasn’t enabled or didn’t work, vectorization would help a lot: here’s &lt;a href=&quot;https://godbolt.org/z/53c6W5561&quot;&gt;gcc at -O3&lt;/a&gt;, but with idiom recognition disabled. It uses 32-byte stores (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vmovdqu YMMWORD PTR [rax], ymm0&lt;/code&gt;) which will be close to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; speed (but a bit of unrolling woudl have helped). In many other languages it would only be up to the compiler: there wouldn’t be a chance to get &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; even with no optimization as there is in C++.&lt;/p&gt;

&lt;p&gt;Do we throw out modern C++ idioms, at least where performance matters, for example by replacing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt;? I don’t think so. It is far from clear where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; can even be used safely in C++. Unlike say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memcpy&lt;/code&gt; and &lt;em&gt;trivially copyable&lt;/em&gt;, there is no type trait for “memset is equivalent to zeroing”. It’s probably OK for byte-like types, and is widely used for other primitive types (which we can be sure are trivial, but can’t always be sure of the representation), but even that may not be safe. Once you introduced even simple structures or classes, the footguns multiply. I recommend &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt; and more generally sticking to modern idioms, except in very rare cases where profiling has identified a hotspot, and even then you should take the safest approach that still provides the performance you need (e.g., by passing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(char)0&lt;/code&gt; in this case).&lt;/p&gt;

&lt;h3 id=&quot;source&quot;&gt;Source&lt;/h3&gt;

&lt;p&gt;The source for my benchmark is &lt;a href=&quot;https://github.com/travisdowns/fill-bench&quot;&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://twitter.com/mattgodbolt&quot;&gt;Matt Godbolt&lt;/a&gt; for creating &lt;a href=&quot;https://godbolt.org/&quot;&gt;Compiler Explorer&lt;/a&gt;, without which this type of investigation would be much more painful – to the point where it often wouldn’t happen at all.&lt;/p&gt;

&lt;p&gt;Matt Godbolt, tc, Nathan Kurz and Pocak for finding typos.&lt;/p&gt;

&lt;h3 id=&quot;discuss&quot;&gt;Discuss&lt;/h3&gt;

&lt;p&gt;I am &lt;em&gt;still&lt;/em&gt; working on my comments system (no, I don’t want Disqus), but in the meantime you can discuss this post on &lt;a href=&quot;https://news.ycombinator.com/item?id=22104576&quot;&gt;Hacker News&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/cpp/comments/erialk/the_hunt_for_the_fastest_zero/&quot;&gt;Reddit&lt;/a&gt; or &lt;a href=&quot;https://lobste.rs/s/bylri4/hunt_for_fastest_zero&quot;&gt;lobste.rs&lt;/a&gt;.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;If you liked this post, check out the &lt;a href=&quot;/&quot;&gt;homepage&lt;/a&gt; for others you might enjoy.&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:function&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Of course, you wouldn’t wrap the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt; function in another &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill&lt;/code&gt; function that just forwards directly to the standard function: you’d just call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::fill&lt;/code&gt; directly. We use a function here so you can see the parameter types and we can examine the disassembly easily. &lt;a href=&quot;#fnref:function&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:qb&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;On &lt;a href=&quot;http://quick-bench.com/yGy2Mzlr2ZZhWVxoH7HscmbEC94&quot;&gt;quickbench&lt;/a&gt;, the difference varies slightly from run to run but is usually around 31 to 32 times. &lt;a href=&quot;#fnref:qb&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:wmem&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Interestingly, the comment mentions &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmemset&lt;/code&gt; in addition to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt; which would presumably be applied for values of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wchar_t&lt;/code&gt; (32-bits on this platform), but I don’t find any evidence that is actually the case via experiment or by examining the code – the optimization appears to only be currently implemented for byte-like values and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memset&lt;/code&gt;. &lt;a href=&quot;#fnref:wmem&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Travis Downs</name><email>travis.downs@gmail.com</email></author><category term="blog" /><category term="performance" /><category term="c++" /><category term="gcc" /><category term="compiler-optimization" /><summary type="html">Unexpected performance deviations depending on how you spell zero.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://travisdowns.github.io/assets/zero/twitter-card.png" /><media:content medium="image" url="https://travisdowns.github.io/assets/zero/twitter-card.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Gathering Intel on Intel AVX-512 Transitions</title><link href="https://travisdowns.github.io/blog/2020/01/17/avxfreq1.html" rel="alternate" type="text/html" title="Gathering Intel on Intel AVX-512 Transitions" /><published>2020-01-17T00:00:00+00:00</published><updated>2020-01-17T00:00:00+00:00</updated><id>https://travisdowns.github.io/blog/2020/01/17/avxfreq1</id><content type="html" xml:base="https://travisdowns.github.io/blog/2020/01/17/avxfreq1.html">&lt;p class=&quot;info&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt; For the really short version, you can &lt;a href=&quot;#summary&quot;&gt;skip to the summary&lt;/a&gt;, but then what will do you for the rest of the day?&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This is a post about AVX and AVX-512 related frequency scaling&lt;sup id=&quot;fnref:first&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:first&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Now, something more than nothing has been written about this already, including &lt;a href=&quot;https://blog.cloudflare.com/on-the-dangers-of-intels-frequency-scaling/&quot;&gt;cautionary tales&lt;/a&gt; of performance loss and some &lt;a href=&quot;https://lemire.me/blog/2018/09/07/avx-512-when-and-how-to-use-these-new-instructions/&quot;&gt;broad guidelines&lt;/a&gt;&lt;sup id=&quot;fnref:dmore&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:dmore&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;, so do we really need to add to the pile?&lt;/p&gt;

&lt;p&gt;Perhaps not, but I’m doing it anyway. My angle is a lower level look, almost microscopic really, at the specific transition behaviors. One would hope that this will lead to specific, &lt;em&gt;quantitative&lt;/em&gt; advice about exactly when various instruction types are likely to pay off, but (spoiler) I didn’t make it there in this post.&lt;/p&gt;

&lt;p&gt;Now I wasn’t really planning on writing about this just now, but I got off on a (nested) tangent&lt;sup id=&quot;fnref:intro&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:intro&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, so let’s examine the AVX-512 downclocking behavior using target tests. At a minimum, this is necessary background for the next post, but I hope that it is also standalone interesting.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you are here because of your footnote fetish, skip straight to the &lt;a href=&quot;#footnotes&quot;&gt;good 🦶 stuff&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h3&gt;

&lt;p&gt;You could perhaps trying skipping ahead to a section that interests you using this obligatory table of contents, but sections are not self contained, so you’ll be better off reading the whole thing linearly.&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introduction&quot; id=&quot;markdown-toc-introduction&quot;&gt;Introduction&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#table-of-contents&quot; id=&quot;markdown-toc-table-of-contents&quot;&gt;Table of Contents&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#the-source&quot; id=&quot;markdown-toc-the-source&quot;&gt;The Source&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#test-structure&quot; id=&quot;markdown-toc-test-structure&quot;&gt;Test Structure&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#hardware&quot; id=&quot;markdown-toc-hardware&quot;&gt;Hardware&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tests&quot; id=&quot;markdown-toc-tests&quot;&gt;Tests&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#256-bit-integer-simd-avx&quot; id=&quot;markdown-toc-256-bit-integer-simd-avx&quot;&gt;256-bit Integer &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; (AVX)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#512-bit-integer-simd-avx-512&quot; id=&quot;markdown-toc-512-bit-integer-simd-avx-512&quot;&gt;512-bit Integer &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; (AVX-512)&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#enter-ipc&quot; id=&quot;markdown-toc-enter-ipc&quot;&gt;Enter &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt;&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#voltage-only-transitions&quot; id=&quot;markdown-toc-voltage-only-transitions&quot;&gt;Voltage Only Transitions&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#attenuation&quot; id=&quot;markdown-toc-attenuation&quot;&gt;Attenuation&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#what-was-left-out&quot; id=&quot;markdown-toc-what-was-left-out&quot;&gt;What Was Left Out&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#summary&quot; id=&quot;markdown-toc-summary&quot;&gt;Summary&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#thanks&quot; id=&quot;markdown-toc-thanks&quot;&gt;Thanks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#discuss&quot; id=&quot;markdown-toc-discuss&quot;&gt;Discuss&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-source&quot;&gt;The Source&lt;/h2&gt;

&lt;p&gt;All of the code underlying this post is available in the &lt;a href=&quot;https://github.com/travisdowns/freq-bench/tree/post1&quot;&gt;post1 branch of freq-bench&lt;/a&gt;, so you can follow along at home, check my work, and check out the behavior on your own hardware. It requires Linux and the &lt;a href=&quot;https://github.com/travisdowns/freq-bench/blob/post1/README.md&quot;&gt;README&lt;/a&gt; gives basic clues on getting started.&lt;/p&gt;

&lt;p&gt;The source includes the &lt;a href=&quot;https://github.com/travisdowns/freq-bench/blob/post1/scripts/data.sh&quot;&gt;data generation scripts&lt;/a&gt; as well as those to &lt;a href=&quot;https://github.com/travisdowns/freq-bench/blob/post1/scripts/plots.sh&quot;&gt;generate the plots&lt;/a&gt;. Neither shell scripting nor Python are my forte, so be gentle.&lt;/p&gt;

&lt;h2 id=&quot;test-structure&quot;&gt;Test Structure&lt;/h2&gt;

&lt;p&gt;We want to investigate what happens when instruction stream related performance transitions occur. The most famous example is what happens when you execute an AVX-512 instruction&lt;sup id=&quot;fnref:widthmatters&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:widthmatters&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; for the first time in a while, but as we will see there are other cases.&lt;/p&gt;

&lt;p&gt;The basic idea is that the test has a &lt;em&gt;duty period&lt;/em&gt; and every time this period elapses, we run a test-specific payload for the duration of the &lt;em&gt;payload period&lt;/em&gt; which consists of one or more “interesting” instructions (which depend on the test). During the entire test we sample various metrics at a best-effort fixed frequency. This repeats for the entire test period. The sample period will generally be much smaller than the duty period&lt;sup id=&quot;fnref:speriod&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:speriod&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;: in our tests we use a 5,000 μs duty period and a sample period of 1 μs, mostly.&lt;/p&gt;

&lt;p&gt;Visually, it is something like this (showing a single duty period: one benchmark is composed of multiple duty cycles back to back):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/avxfreq1/test-structure.png&quot; alt=&quot;Test Structure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This diagram shows the payload period as occupying a non-negligible amount of time. However, in the first few first tests, the payload period is essentially zero: we run the payload function (which consists of only a couple instructions) only once, so it is really a payload &lt;em&gt;moment&lt;/em&gt; rather than period.&lt;/p&gt;

&lt;h3 id=&quot;hardware&quot;&gt;Hardware&lt;/h3&gt;

&lt;p&gt;We are running these tests on a &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt; architecture W-series CPU: a W-2104&lt;sup id=&quot;fnref:f2104&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:f2104&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; with the following &lt;a href=&quot;https://stackoverflow.com/a/56861355/149138&quot;&gt;license-based&lt;/a&gt; frequencies&lt;sup id=&quot;fnref:avxt&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:avxt&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;License&lt;/th&gt;
      &lt;th&gt;Frequency&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Non-AVX Turbo&lt;/td&gt;
      &lt;td&gt;L0&lt;/td&gt;
      &lt;td&gt;3.2 GHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AVX Turbo&lt;/td&gt;
      &lt;td&gt;L1&lt;/td&gt;
      &lt;td&gt;2.8 GHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AVX-512 Turbo&lt;/td&gt;
      &lt;td&gt;L2&lt;/td&gt;
      &lt;td&gt;2.4 GHz&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;For one (voltage) test I also use my Skylake (mobile) &lt;a href=&quot;https://ark.intel.com/content/www/us/en/ark/products/88967/intel-core-i7-6700hq-processor-6m-cache-up-to-3-50-ghz.html&quot;&gt;i7-6700HQ&lt;/a&gt;, running at either it’s nominal frequency of 2.6 GHz, or the turbo frequency of 3.5 GHz.&lt;/p&gt;

&lt;h2 id=&quot;tests&quot;&gt;Tests&lt;/h2&gt;

&lt;p&gt;The basic approach this post will take is examining the CPU behavior using the test framework above, primarily varying what the payload is, and what metrics we look at. Let’s get the ball rolling with 256-bit instructions.&lt;/p&gt;

&lt;h3 id=&quot;256-bit-integer-simd-avx&quot;&gt;256-bit Integer &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; (AVX)&lt;/h3&gt;

&lt;p&gt;For the first test will use as payload the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vporymm_vz&lt;/code&gt; function, which is just a single 256-bit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt; instruction, followed by a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vzeroupper&lt;/code&gt;&lt;sup id=&quot;fnref:vz&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:vz&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;vporymm_vz:&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vpor&lt;/span&gt;   &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vzeroupper&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We call the payload function only once at the start of each duty period&lt;sup id=&quot;fnref:pperiod&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:pperiod&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;. The duty period is set to 5000 μs and the sample period to 1 μs, and the total test time is set to 31,000 μs (so the payload will execute 7 times).&lt;/p&gt;

&lt;p&gt;Here’s the result (plot notes&lt;sup id=&quot;fnref:plotnotes&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:plotnotes&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;), with time along the x axis&lt;sup id=&quot;fnref:falk&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:falk&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;, showing the measured frequency at each sample (there are three separate test runs shown&lt;sup id=&quot;fnref:threerun&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:threerun&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;):&lt;/p&gt;

&lt;div style=&quot;position: relative; margin-bottom: 1em;&quot;&gt;
&lt;img src=&quot;/assets/avxfreq1/fig-vporvz256-740w.png&quot; srcset=&quot;
    /assets/avxfreq1/fig-vporvz256-740w.png  740w,
    /assets/avxfreq1/fig-vporvz256-1480w.png 1480w,
    /assets/avxfreq1/fig-vporvz256-2220w.png 2220w,
    /assets/avxfreq1/fig-vporvz256-2960w.png 2960w
    &quot; sizes=&quot;(max-width: 800px) calc(100vw - 30px), 740px&quot; alt=&quot;256-bit vpor transitions&quot; /&gt;
&lt;a style=&quot;position: absolute; font-size: 70%; right: 0px; bottom: 0px&quot; href=&quot;/assets/avxfreq1/fig-vporvz256.svg&quot;&gt;SVG version of this plot&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Well that’s really boring. The entire test runs consistently at 3.2 GHz, the nominal (L0 license) frequency, if we ignore the a few uninteresting outliers&lt;sup id=&quot;fnref:outlie&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:outlie&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;13&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h3 id=&quot;512-bit-integer-simd-avx-512&quot;&gt;512-bit Integer &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; (AVX-512)&lt;/h3&gt;

&lt;p&gt;Before the crowd gets too rowdy, let’s quickly move on to the next test, which is identical except that it uses 512-bit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zmm&lt;/code&gt; registers:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;vporzmm_vz:&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vpor&lt;/span&gt;   &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;vzeroupper&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is the result:&lt;/p&gt;

&lt;div style=&quot;position: relative; margin-bottom: 1em;&quot;&gt;
&lt;img src=&quot;/assets/avxfreq1/fig-vporvz512-740w.png&quot; srcset=&quot;
    /assets/avxfreq1/fig-vporvz512-740w.png  740w,
    /assets/avxfreq1/fig-vporvz512-1480w.png 1480w,
    /assets/avxfreq1/fig-vporvz512-2220w.png 2220w,
    /assets/avxfreq1/fig-vporvz512-2960w.png 2960w
    &quot; sizes=&quot;(max-width: 800px) calc(100vw - 30px), 740px&quot; alt=&quot;512-bit vpor transitions&quot; /&gt;
&lt;a style=&quot;position: absolute; font-size: 70%; right: 0px; bottom: 0px&quot; href=&quot;/assets/avxfreq1/fig-vporvz512.svg&quot;&gt;SVG version of this plot&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;We’ve got something to sink our teeth into!&lt;/p&gt;

&lt;p&gt;Remember that the duty cycle is 5000 μs, so at each x-axis tick we execute the payload. Now the behavior is clear: every time the payload instruction executes (at multiples of 5000 μs), the frequency drops from the 3.2 GHz L0 license down to 2.8 GHz L1 license frequency. So far this is all pretty much as expected.&lt;/p&gt;

&lt;p&gt;Let’s zoom in on one of the transition points at 15,000 μs:&lt;/p&gt;

&lt;div style=&quot;position: relative; margin-bottom: 1em;&quot;&gt;
&lt;img src=&quot;/assets/avxfreq1/fig-vpor-zoomed-740w.png&quot; srcset=&quot;
    /assets/avxfreq1/fig-vpor-zoomed-740w.png  740w,
    /assets/avxfreq1/fig-vpor-zoomed-1480w.png 1480w,
    /assets/avxfreq1/fig-vpor-zoomed-2220w.png 2220w,
    /assets/avxfreq1/fig-vpor-zoomed-2960w.png 2960w
    &quot; sizes=&quot;(max-width: 800px) calc(100vw - 30px), 740px&quot; alt=&quot;512-bit vpor transitions (zoomed)&quot; /&gt;
&lt;a style=&quot;position: absolute; font-size: 70%; right: 0px; bottom: 0px&quot; href=&quot;/assets/avxfreq1/fig-vpor-zoomed.svg&quot;&gt;SVG version of this plot&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;We can make the following observations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;There is a transition period (the rightmost of the two shaded regions, in orange&lt;sup id=&quot;fnref:peachpuff&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:peachpuff&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;14&lt;/a&gt;&lt;/sup&gt;) of ~11 μs&lt;sup id=&quot;fnref:resnote&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:resnote&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;15&lt;/a&gt;&lt;/sup&gt; where the CPU is halted: no samples occur during this period&lt;sup id=&quot;fnref:halted&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:halted&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;16&lt;/a&gt;&lt;/sup&gt;. For fun, I’ll call this a &lt;em&gt;frequency transition&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;The leftmost shaded region, shown in purple&lt;sup id=&quot;fnref:thistle&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:thistle&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;17&lt;/a&gt;&lt;/sup&gt;, immediately following the payload execution at 15,000 μs and prior to the halted region, is ~9 μs long and the frequency remains unchanged. This is not just a test issue or measurement error: this period occurs after the payload and is consistently reproducible&lt;sup id=&quot;fnref:confirm&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:confirm&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;18&lt;/a&gt;&lt;/sup&gt;. Although it looks like nothing interesting is going on in this region, we’ll soon see it is indeed special and will call this region a &lt;em&gt;voltage-only&lt;/em&gt; transition.&lt;/li&gt;
  &lt;li&gt;Although not fully shown in the zoomed plot, the lower 2.8 GHz frequency period lasts for ~650 μs.&lt;/li&gt;
  &lt;li&gt;Not shown in the zoomed plot (but seen as a second downwards spike on the full plot, after the ~650 μs period of low frequency), there is another fully halted period of ~11 us, after which the CPU returns to it’s maximum speed of 3.2 GHz (L0 license).&lt;/li&gt;
  &lt;li&gt;These attributes are mostly consistent across the three runs (so much that the series, in green, mostly overlaps and obscures the others) – but there are a few outliers in where the return to 3.2 GHz takes somewhat longer. This is consistent across runs: recovery is never &lt;em&gt;faster&lt;/em&gt; than ~650 μs, but sometimes longer. I believe it occurs when an interrupt during the L1 region “resets the timer”.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;enter-ipc&quot;&gt;Enter &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt;&lt;/h4&gt;

&lt;p&gt;Although it is not visible in this plot, there is something special about the behavior of 512-bit instructions in the first shaded (purple) region – that is, in the 9 microseconds between the execution of the payload instruction and before the subsequent halted period: &lt;em&gt;they execute much slower than usual&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is easiest to see if we extend the payload period: instead executing the payload function once every 5000 μs, then looping on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdtsc&lt;/code&gt;, waiting for the next sample, we will continue to execute the payload function for 100 μs after a new duty period starts (that is, the &lt;em&gt;payload period&lt;/em&gt; is set to 100 μs). During this time we still take samples as usual, every 1 μs – but in between samples we are executing the payload instruction(s)&lt;sup id=&quot;fnref:whynot&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:whynot&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;19&lt;/a&gt;&lt;/sup&gt;. So one duty period now looks like 100 μs of payload followed by 4850 μs of normal payload-free hot spinning.&lt;/p&gt;

&lt;p&gt;We lengthen the payload period in order to examine the performance of the payload instructions. There are several metrics we could look at, but a simple one is to look at &lt;em&gt;instructions per second&lt;/em&gt;. As long as we make sure the large majority of the executed instructions are payload instructions, the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; will largely reflect the execution of the payload&lt;sup id=&quot;fnref:ideal&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:ideal&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;20&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;As payload, we will use a function composed simply of 1,000 dependent 512-bit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpord&lt;/code&gt; instructions:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;vpord&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vpord&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; ... 997 more like this&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vpord&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;zmm0&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vzeroupper&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We &lt;a href=&quot;https://uops.info/table.html?search=vpord%20(zmm%2C%20zmm%2C%20zmm)&amp;amp;cb_lat=on&amp;amp;cb_tp=on&amp;amp;cb_uops=on&amp;amp;cb_ports=on&amp;amp;cb_SKX=on&amp;amp;cb_measurements=on&amp;amp;cb_iaca30=on&amp;amp;cb_avx512=on&quot;&gt;know&lt;/a&gt; these &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpord&lt;/code&gt; instructions have a latency of 1 cycle and here they are serially dependent so we expect this function to take 1,000 cycles, give or take&lt;sup id=&quot;fnref:give&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:give&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;21&lt;/a&gt;&lt;/sup&gt;, for an &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; of 1.0.&lt;/p&gt;

&lt;p&gt;Here’s what a the same zoomed transition point for this looks like, with &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; plotted on the secondary axis:&lt;/p&gt;

&lt;div style=&quot;position: relative; margin-bottom: 1em;&quot;&gt;
&lt;img src=&quot;/assets/avxfreq1/fig-ipc-zoomed-zmm-740w.png&quot; srcset=&quot;
    /assets/avxfreq1/fig-ipc-zoomed-zmm-740w.png  740w,
    /assets/avxfreq1/fig-ipc-zoomed-zmm-1480w.png 1480w,
    /assets/avxfreq1/fig-ipc-zoomed-zmm-2220w.png 2220w,
    /assets/avxfreq1/fig-ipc-zoomed-zmm-2960w.png 2960w
    &quot; sizes=&quot;(max-width: 800px) calc(100vw - 30px), 740px&quot; alt=&quot;512-bit vpor transitions (with IPC)&quot; /&gt;
&lt;a style=&quot;position: absolute; font-size: 70%; right: 0px; bottom: 0px&quot; href=&quot;/assets/avxfreq1/fig-ipc-zoomed-zmm.svg&quot;&gt;SVG version of this plot&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;First, note that in the unshaded regions on the left (before 15,000 μs) and right (after 15,100 μs), the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; is basically irrelevant: no payload instructions are being executed, so the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; there is just the whatever the measurement code happens to net out to. We only care about the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; in the shaded regions, where the payload is executing.&lt;/p&gt;

&lt;p&gt;Let’s tackle the regions from right to left, which happens to correspond to obvious to less obvious.&lt;/p&gt;

&lt;p&gt;We have the blue region, running from ~15020 μs to 15100 μs (where the extra payload period ends). Here the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; is right at 1 instruction per cycle. So the payload is executing right at the expected rate, i.e., &lt;em&gt;full speed&lt;/em&gt;. Keeners may point out that the very beginning of the blue period, the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; (and the measured frequency) is a bit noisier and slightly above 1. This is not a CPU effect, but rather a measurement one: during this phase the benchmark is &lt;em&gt;catching up&lt;/em&gt; on samples missed during the previous halted period, which changes the payload to overhead ratio and bumps up the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; (details&lt;sup id=&quot;fnref:catchup&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:catchup&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;22&lt;/a&gt;&lt;/sup&gt;).&lt;/p&gt;

&lt;p&gt;The middle, orange, region shows us what we’ve already seen: the CPU is halted, so no samples occur. &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; doesn’t tell us much here.&lt;/p&gt;

&lt;h4 id=&quot;voltage-only-transitions&quot;&gt;Voltage Only Transitions&lt;/h4&gt;

&lt;p&gt;The most interesting part is the first shaded region (purple): after the payload starts running but before the halt which I call a &lt;em&gt;voltage only&lt;/em&gt; transition for reasons that will soon become clear.&lt;/p&gt;

&lt;p&gt;Here, we see that the payload executes &lt;em&gt;much&lt;/em&gt; more slowly, with an &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; of ~0.25. So in this region, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpord&lt;/code&gt; instructions are apparently executing at &lt;em&gt;four times&lt;/em&gt; their normal latency. I also observe an identical 4x slowdown for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpord&lt;/code&gt; throughput, using an identical &lt;a href=&quot;https://github.com/travisdowns/freq-bench/blob/434c7cf5db73e2d48061e78525c7bbf7eb7757a3/basic-impls.cpp#L64&quot;&gt;test&lt;/a&gt; except with independent &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpord&lt;/code&gt; instructions&lt;sup id=&quot;fnref:tput&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:tput&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;23&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Perhaps surprisingly, this same slowdown occurs for 256-bit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ymm&lt;/code&gt; instructions as well. This contradicts the conventional wisdom that on AVX-512 chips there is no penalty to using light 256-bit instructions:&lt;/p&gt;

&lt;div style=&quot;position: relative; margin-bottom: 1em;&quot;&gt;
&lt;img src=&quot;/assets/avxfreq1/fig-ipc-zoomed-ymm-740w.png&quot; srcset=&quot;
    /assets/avxfreq1/fig-ipc-zoomed-ymm-740w.png  740w,
    /assets/avxfreq1/fig-ipc-zoomed-ymm-1480w.png 1480w,
    /assets/avxfreq1/fig-ipc-zoomed-ymm-2220w.png 2220w,
    /assets/avxfreq1/fig-ipc-zoomed-ymm-2960w.png 2960w
    &quot; sizes=&quot;(max-width: 800px) calc(100vw - 30px), 740px&quot; alt=&quot;256-bit vpor transitions (with IPC)&quot; /&gt;
&lt;a style=&quot;position: absolute; font-size: 70%; right: 0px; bottom: 0px&quot; href=&quot;/assets/avxfreq1/fig-ipc-zoomed-ymm.svg&quot;&gt;SVG version of this plot&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;The results shown above are for a test identical to the 512-version except that it uses 256-bit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor ymm0, ymm0, ymm0&lt;/code&gt; as the payload. It shows the same slowdown for ~9 μs after the payload starts executing, but no subsequent halt and no frequency transition. That is, it shows a voltage-only transition (lack of frequency transition is expected because we don’t expect a turbo license change for light 256-bit instructions).&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;xmmeffect&quot;&gt;&lt;/a&gt;By now, you are probably wondering about 128-bit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xmm&lt;/code&gt; registers. The good news is that these show no effect at all:&lt;/p&gt;

&lt;div style=&quot;position: relative; margin-bottom: 1em;&quot;&gt;
&lt;img src=&quot;/assets/avxfreq1/fig-ipc-zoomed-xmm-740w.png&quot; srcset=&quot;
    /assets/avxfreq1/fig-ipc-zoomed-xmm-740w.png  740w,
    /assets/avxfreq1/fig-ipc-zoomed-xmm-1480w.png 1480w,
    /assets/avxfreq1/fig-ipc-zoomed-xmm-2220w.png 2220w,
    /assets/avxfreq1/fig-ipc-zoomed-xmm-2960w.png 2960w
    &quot; sizes=&quot;(max-width: 800px) calc(100vw - 30px), 740px&quot; alt=&quot;128-bit vpor transitions (with IPC)&quot; /&gt;
&lt;a style=&quot;position: absolute; font-size: 70%; right: 0px; bottom: 0px&quot; href=&quot;/assets/avxfreq1/fig-ipc-zoomed-xmm.svg&quot;&gt;SVG version of this plot&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Here, the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; jumps immediately to the expected value. So it appears that the CPU runs in a state where the 128-bit lanes are ready to go at all times&lt;sup id=&quot;fnref:orisit&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:orisit&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;24&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;The conventional wisdom regarding this “warmup” period is that the upper part&lt;sup id=&quot;fnref:upper&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:upper&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;25&lt;/a&gt;&lt;/sup&gt; of the vector units is shut down when not in use, and takes time to power up. The story goes that during this power-up period the CPU does not need to halt but it runs &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instructions at a reduced throughput &lt;em&gt;by splitting up the input&lt;/em&gt; into 128-bit chunks and passing the data two or more times through the powered-on 128-bit lanes&lt;sup id=&quot;fnref:amd&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:amd&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;26&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;However, there are some observations that seem to contradict this hypothesis (in rough order from least to most convincing):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The observed impact to latency and throughput is ~4x, whereas I would expect 2x for simple instructions such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The timing is the same for 256-bit and 512-bit instructions: despite that 512-bit instructions take at least 2x the work, i.e., need to be passed through the 128-bit unit at least 4 times.&lt;/li&gt;
  &lt;li&gt;Some instructions are more difficult to implement using this type of splitting, e.g., instructions where both high and low output lanes depend on all of the input lanes&lt;sup id=&quot;fnref:ewise&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:ewise&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;27&lt;/a&gt;&lt;/sup&gt; (see how slow they are on Zen). I expected that maybe these instructions would be slower when running in split mode, but I tested &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpermd&lt;/code&gt; and found that it runs at 4L4T&lt;sup id=&quot;fnref:lt&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:lt&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;28&lt;/a&gt;&lt;/sup&gt;, compared to 3L1T normally. So &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpermd&lt;/code&gt; (including the 512-bit version) didn’t slow more than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt;, and in fact in a relative sense it slowed down &lt;em&gt;less&lt;/em&gt; (e.g., the latency only changed from 3 to 4). The fact that the latency and throughput reacted differently for this instruction seems odd, and that it has now the exact same 4L4T timing as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt; seems like a strange coincidence.&lt;/li&gt;
  &lt;li&gt;Oddly, when I tried to time the slowdown more precisely, I kept coming with fractional value around 4.2x, not 4.0x, kind of contradicting the idea that the instruction is simply operating in a different mode, which should still have an integral latency.&lt;/li&gt;
  &lt;li&gt;As it turns out, &lt;em&gt;all ALU&lt;sup id=&quot;fnref:alu&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:alu&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;29&lt;/a&gt;&lt;/sup&gt; instructions&lt;/em&gt; are slower in this mode, not just wide &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; ones.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It was 5 that sealed the deal on this not being a slowdown related to split execution. I believe what is actually happening is the CPU is doing very fine-grained throttling when wider instructions are executing in the core. That is, the upper lanes &lt;em&gt;are&lt;/em&gt; being used in this mode (they are either not gated at at all, or are gated but enabling them is very quick, less than 1 μs) but execution frequency is reduced by 4x because CPU power delivery is not a state that can handle full-speed execution of these wider instructions, yet. While the CPU waits (e.g., for voltage to rise, fattening the guardband) for higher power execution to be allowed, this fine-grained throttling occurs.&lt;/p&gt;

&lt;p&gt;This throttling affects non-&lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instructions too, causing them to execute at 4x their normal latency and inverse throughput. We can show with the following test, which combines a single &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor ymm0, ymm0, ymm0&lt;/code&gt; with N chained &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add eax, 0&lt;/code&gt; instructions, shown here for N = 3:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;vpor&lt;/span&gt;   &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; repeated 9 more times&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If only &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt; is slowed down, each block of 4 instructions will take 4 cycles, limited by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt; chain (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; chain is 3 cycles long). However, I actually measure ~12 cycles, indicating that we are instead limited by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; chain, each of which takes 4 cycles for a total of 12.&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;throttle-anchor&quot;&gt;&lt;/a&gt;We can vary the number of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; instructions (N) to see how long this effect persists. This table is the result:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;ADD instructions (N)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Cycles/ADD&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Delta Cycles (slow)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Delta Cycles (fast)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;-0.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3.9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3.4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3.9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;30&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;40&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;50&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3.9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;60&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;70&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;80&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3.4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;90&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3.6&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;-0.2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;100&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3.3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;120&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;140&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.7&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;160&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;180&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.7&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;200&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.8&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The &lt;strong&gt;Cycles/ADD&lt;/strong&gt; column shows the number of cycles taken per add instruction over the entire slow region (roughly the first 8-10 μs after the payload starts executing). The &lt;strong&gt;Delta Cycles (slow)&lt;/strong&gt; shows how many cycles each additional &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; instruction took compared to the previous row: i.e., for row N = 30, it determines how much longer the 10 additional &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; instructions took compared to the row N = 20. The &lt;strong&gt;Delta Cycles (fast)&lt;/strong&gt; column is the same thing, but applies to the samples after ~10 μs when the CPU is back up to full speed (that column shows the expected 1.0 cycles per additional add).&lt;/p&gt;

&lt;p&gt;Here we clearly see that up to roughly 70 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; instructions, interleaved with a single &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt;, all the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; instructions are taking 4 cycles, i.e., the CPU is throttled. Somewhere between 80 and 90 a transition happens: &lt;em&gt;additional&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; instructions now take 1 cycle, but the overall time per &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; is (initially) close to 4. This shows that when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; (and presumably any non-wide instruction) is far enough away from the closest wide &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instruction, they start executing at full speed. So the timings for the larger N values can be understood as a blend of a slow section of ~70-80 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; instructions near the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt; which run at 1 per 4 cycles, and the remaining section where they run at full speed: 1 per cycle.&lt;/p&gt;

&lt;p&gt;We can probably conclude the CPU is not just throttling frequency or “duty cycling”: in that case every instruction would be slowed down by the same factor, but instead the rule is more like “latency extended to the next multiple of 4 cycles”, e.g., a latency 3 instruction like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imul eax, eax, 0&lt;/code&gt; ends up taking 4 cycles when the CPU is throttling. It is likely that the throttling happens at some part of the pipeline before execution, e.g., at issue or dispatch.&lt;/p&gt;

&lt;p&gt;The transition to fast mode when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt; instructions are spread sufficiently apart probably reflects the size of some structure such as the &lt;abbr title=&quot;Queue that collects incoming instructions from the decoder, uop cache or microcode engine and delivers them to the renamer (RAT).&quot;&gt;IDQ&lt;/abbr&gt; (64 entries in Skylake) or scheduler (97 entries claimed&lt;sup id=&quot;fnref:ratentries&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:ratentries&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;30&lt;/a&gt;&lt;/sup&gt;). The core could track whether &lt;em&gt;any&lt;/em&gt; wide instruction currently in that structure, and enforce the slow mode if so. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt; instructions are close enough together, there is &lt;em&gt;always&lt;/em&gt; at least one present, but once they are spaced out enough, you get periods of fast mode.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Voltage Effects&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We can actually test the theory that this transition is associated with waiting for a change in power delivery configuration. Specifically, we can observe the CPU core voltage, using bits 47:32 of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MSR_PERF_STATUS&lt;/code&gt; MSR. Volume 4 of the Intel Software Development Manual let’s us on a secret: these bits expose the &lt;em&gt;core voltage&lt;sup id=&quot;fnref:vcc&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:vcc&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;31&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/avxfreq1/msr_198h.png&quot; alt=&quot;Intel SDM Volume 4: Table 2-20&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let’s zoom as usual on a transition point, in this case using a 256-bit (ymm) payload of 1000 dependent &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt; instructions. This 256-bit payload means no frequency transition, only a dispatch throttling period associated with running 256-bit instructions for the first time in a while. We plot the time it takes to run an iteration of the payload&lt;sup id=&quot;fnref:whyp&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:whyp&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;32&lt;/a&gt;&lt;/sup&gt;, along with the measured voltage:&lt;/p&gt;

&lt;div style=&quot;position: relative; margin-bottom: 1em;&quot;&gt;
&lt;img src=&quot;/assets/avxfreq1/fig-volts256-1-740w.png&quot; srcset=&quot;
    /assets/avxfreq1/fig-volts256-1-740w.png  740w,
    /assets/avxfreq1/fig-volts256-1-1480w.png 1480w,
    /assets/avxfreq1/fig-volts256-1-2220w.png 2220w,
    /assets/avxfreq1/fig-volts256-1-2960w.png 2960w
    &quot; sizes=&quot;(max-width: 800px) calc(100vw - 30px), 740px&quot; alt=&quot;Voltage Changes&quot; /&gt;
&lt;a style=&quot;position: absolute; font-size: 70%; right: 0px; bottom: 0px&quot; href=&quot;/assets/avxfreq1/fig-volts256-1.svg&quot;&gt;SVG version of this plot&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;The length of the throttling period is around 10 μs as usual, as shown by the period where the payload takes ~4,000 cycles (the usual 4x throttling), and the voltage is unchanged from the pre-transition period (at about 0.951 V) during the throttling period. At the moment the throttling stops, the voltage jumps to about 0.957, a change of about 6 mV. This happens at 2.6 GHz, the nominal non-turbo speed of my i7-6700HQ. At 3.5 GHz, the transition is from 1.167 to 1.182, so both the absolute voltages and the difference (about 15 mV) are larger, consistent the basic idea that higher frequencies need higher voltages.&lt;/p&gt;

&lt;p&gt;So one theory is that this type of transition represents the period between when the CPU has requested a higher voltage (because wider 256-bit instructions imply a larger worst-case current delta event, hence a worst-case voltage drop) and when the higher voltage is delivered. While the core waits for the change to take effect, throttling is in effect in order to reduce the worst-case drop: without throttling&lt;sup id=&quot;fnref:cthrottle&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:cthrottle&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;33&lt;/a&gt;&lt;/sup&gt; there is no guarantee that a burst of wide &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instructions won’t drop the voltage below the minimum voltage required for safe operation at this frequency.&lt;/p&gt;

&lt;h4 id=&quot;attenuation&quot;&gt;Attenuation&lt;/h4&gt;

&lt;p&gt;We might check if there is any &lt;em&gt;attenuation&lt;/em&gt; of either type of transition. By &lt;em&gt;attenuation&lt;/em&gt; I mean that if a core is transitioning between frequencies too frequently, the power management algorithm may decide to simply keep the core at the lower frequency, which can provide more overall performance when considering the halted periods needed in each transition. This is exactly what happens for active core count&lt;sup id=&quot;fnref:acc&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:acc&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;34&lt;/a&gt;&lt;/sup&gt; transitions: too many transitions in a short period of time and the CPU will just decide to run at the lower frequency rather than incurring the halts need to transition between e.g. the 1-core and 2-core turbos&lt;sup id=&quot;fnref:hiddenbo&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:hiddenbo&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;35&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;We check this by setting a duty period which is just above the observed recovery time from 2.8 to 3.2 GHz, to see if we still see transitions. Here’s a duty cycle of 760 μs, about 10 μs more than the observed recovery period for this test&lt;sup id=&quot;fnref:recovery&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:recovery&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;36&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;div style=&quot;position: relative; margin-bottom: 1em;&quot;&gt;
&lt;img src=&quot;/assets/avxfreq1/fig-vporvz512-ipc-p760-740w.png&quot; srcset=&quot;
    /assets/avxfreq1/fig-vporvz512-ipc-p760-740w.png  740w,
    /assets/avxfreq1/fig-vporvz512-ipc-p760-1480w.png 1480w,
    /assets/avxfreq1/fig-vporvz512-ipc-p760-2220w.png 2220w,
    /assets/avxfreq1/fig-vporvz512-ipc-p760-2960w.png 2960w
    &quot; sizes=&quot;(max-width: 800px) calc(100vw - 30px), 740px&quot; alt=&quot;760 μs period closeup&quot; /&gt;
&lt;a style=&quot;position: absolute; font-size: 70%; right: 0px; bottom: 0px&quot; href=&quot;/assets/avxfreq1/fig-vporvz512-ipc-p760.svg&quot;&gt;SVG version of this plot&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;I’m not going to color the regions here, as by now I think you are probably (over?) familiar with them. The key points are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The payload starts executing at 7600 μs, which is &lt;em&gt;before&lt;/em&gt; the upwards frequency transition, we are still executing at 2.8 GHz - so initially the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; is high, 1 per cycle.&lt;/li&gt;
  &lt;li&gt;Despite the fact that we are already executing again 512-bit instructions, the frequency adjusts upwards a few μs later. Most likely what happened is that the power logic already evaluated earlier (say at ~7558 μs, just before the payload started) that an upwards transition should occur, but as we’ve seen the response is generally delayed by 8 to 10 μs so it occurs after the payload has already started executing.&lt;/li&gt;
  &lt;li&gt;Of course, as soon as the transition occurs, the core is no longer in a suitable state for full-speed wide &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; execution, so &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; drops to ~0.25.&lt;/li&gt;
  &lt;li&gt;Another transition back to low frequency occurs ~10 μs later and then full speed execution can resume.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So there is no attenuation, but attenuation isn’t really needed: the long (~650 μs) cooldown period between the last wide instruction and subsequent frequency boost means that the damage from halt periods are fairly limited: this is unlike the active core count scenario where the CPU has no control over the transition frequency (rather it is driven by interrupts and changes in runnable processes and threads). Here, we have the worst case scenario of transitions packed as closely as possible, but we lose only ~20 μs (for 2 transitions) out of 760 μs, less than a 3% impact. The impact of running at the lower frequency is much higher: 2.8 vs 3.2 GHz: a 12.5% impact in the case that the lowered frequency was not useful (i.e., because the wide &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; payload represents a vanishingly small part of the total work).&lt;/p&gt;

&lt;h2 id=&quot;what-was-left-out&quot;&gt;What Was Left Out&lt;/h2&gt;

&lt;p&gt;There’s lots we’ve left out. We haven’t even touched:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Checking whether xmm registers also cause a voltage-only transition, if they haven’t been used for a while. We didn’t find &lt;a href=&quot;#xmmeffect&quot;&gt;any effect&lt;/a&gt;, but it also certain that some 128-bit instructions appear in the measurement loop which would hide the effect.&lt;/li&gt;
  &lt;li&gt;Checking whether the voltage-only transition implied by 256-bit instructions are disjoint from those for 512-bit. That is, if you execute a 256-bit instruction after a while without any, you get a voltage-only transition (confirmed above). If you then execute a 512-bit instruction, before the relaxation period expires, do you get a second throttling period prior to the frequency transition? I believe so but I haven’t checked it.&lt;/li&gt;
  &lt;li&gt;Any type of investigation of “heavy” 256-bit or 512-bit instructions. These require a license one level (numerically) higher than light instructions, and knowing if any of the key timings change would be interesting&lt;sup id=&quot;fnref:heavy&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:heavy&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;37&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
  &lt;li&gt;Almost no investigation was made how any of these timings (and the magnitude of voltage changes) vary with frequency. For example, if we are already running at a lower frequency, frequency transitions are presumably not needed, and voltage-only transitions may be shorter.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;For the benefit of anyone who just skipped to the bottom, or whose eyes glazed over at some point, here’s a summary of the key findings:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;After a period of about 680 μs not using the &lt;em&gt;AVX upper bits&lt;/em&gt;  (255:128) or &lt;em&gt;AVX-512 upper bits&lt;/em&gt; (511:256) the processor enters a mode where using those bits again requires at least a voltage transition, and sometimes a frequency transition.&lt;/li&gt;
  &lt;li&gt;The processor continues executing instructions during a voltage transition, but at a greatly reduced speed: 1/4th the usual instruction dispatch rate. However, this throttling is fine-grained: it only applies when wide instructions are &lt;em&gt;in flight&lt;/em&gt; (&lt;a href=&quot;#throttle-anchor&quot;&gt;details&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;Voltage transitions end when the voltage reaches the desired level, this depends on the magnitude of the transition but 8 to 20 μs is common on the hardware I tested.&lt;/li&gt;
  &lt;li&gt;In some cases a frequency transitions is also required, e.g., because the involved instruction requires a higher power license. These transitions seem to &lt;em&gt;first&lt;/em&gt; incur a throttling period similar to a voltage-only transition, and then a halted period of 8 to 10 μs while the frequency changes.&lt;/li&gt;
  &lt;li&gt;A key motivator for this post was to give concrete, qualitative guidance on how to write code that is as fast as possible given this behavior. It got bumped to part 2.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We also summarize the key timings in this beautifully rendered table:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;What&lt;/th&gt;
      &lt;th&gt;Time&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
      &lt;th&gt;Details&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Voltage Transition&lt;/td&gt;
      &lt;td&gt;~8 to 20 μs&lt;/td&gt;
      &lt;td&gt;Time required for a voltage transition, depends on frequency&lt;/td&gt;
      &lt;td&gt;&lt;sup id=&quot;fnref:t1deets&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:t1deets&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;38&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Frequency Transition&lt;/td&gt;
      &lt;td&gt;~10 μs&lt;/td&gt;
      &lt;td&gt;Time required for the halted part of a frequency transition&lt;/td&gt;
      &lt;td&gt;&lt;sup id=&quot;fnref:fdeets&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:fdeets&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;39&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Relaxation Period&lt;/td&gt;
      &lt;td&gt;~680 μs&lt;/td&gt;
      &lt;td&gt;Time required to go back to a lower power license, measured from the last instruction requiring the higher license&lt;/td&gt;
      &lt;td&gt;&lt;sup id=&quot;fnref:lldeets&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:lldeets&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;40&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;thanks&quot;&gt;Thanks&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://lemire.me&quot;&gt;Daniel Lemire&lt;/a&gt; who provided access to the AVX-512 system I used for testing.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/thekanter&quot;&gt;David Kanter&lt;/a&gt; of &lt;a href=&quot;http://www.realworldtech.com&quot;&gt;RWT&lt;/a&gt; for a fruitful discussion on power and voltage management in modern chips.&lt;/p&gt;

&lt;p&gt;RWT forum members anon³, Ray, Etienne, Ricardo B, Foyle and Tim McCaffrey who provided feedback on this post and helped me understand the VR landscape for recent Intel chips.&lt;/p&gt;

&lt;p&gt;Alexander Monakov, Kharzette and Justin Lebar for finding typos.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/JeffSmith888&quot;&gt;Jeff Smith&lt;/a&gt; for teaching me about spread spectrum clocking.&lt;/p&gt;

&lt;h2 id=&quot;discuss&quot;&gt;Discuss&lt;/h2&gt;

&lt;p&gt;Discussion on &lt;a href=&quot;https://news.ycombinator.com/item?id=22077974&quot;&gt;Hacker News&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/trav_downs/status/1218238653354344449&quot;&gt;Twitter&lt;/a&gt; and &lt;a href=&quot;https://lobste.rs/s/qaqmyo/gathering_intel_on_intel_avx_512&quot;&gt;lobste.rs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Direct feedback also welcomed by &lt;a href=&quot;mailto:travis.downs@gmail.com&quot;&gt;email&lt;/a&gt; or as &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io/issues&quot;&gt;a GitHub issue&lt;/a&gt;.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;If you liked this post, check out the &lt;a href=&quot;/&quot;&gt;homepage&lt;/a&gt; for others you might enjoy.&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;footnotes&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:first&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;… and also &lt;em&gt;non frequency&lt;/em&gt; related performance events, which I mention only in a footnote not to spoil the fun for non-footnote type people and also to pad by footnote count. That’s why I call this &lt;em&gt;Performance&lt;/em&gt; Transitions, instead of Frequency Transitions. &lt;a href=&quot;#fnref:first&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:dmore&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Note that Daniel has &lt;a href=&quot;https://lemire.me/blog/2018/08/25/avx-512-throttling-heavy-instructions-are-maybe-not-so-dangerous/&quot;&gt;written&lt;/a&gt; &lt;a href=&quot;https://lemire.me/blog/2018/08/15/the-dangers-of-avx-512-throttling-a-3-impact/&quot;&gt;much more&lt;/a&gt; &lt;a href=&quot;https://lemire.me/blog/2018/08/24/trying-harder-to-make-avx-512-look-bad-my-quantified-and-reproducible-results/&quot;&gt;than&lt;/a&gt; &lt;a href=&quot;https://lemire.me/blog/2018/09/04/per-core-frequency-scaling-and-avx-512-an-experiment/&quot;&gt;just that&lt;/a&gt; one. &lt;a href=&quot;#fnref:dmore&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:intro&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This was going to be the actual post I was trying to write when I went off on &lt;a href=&quot;/blog/2019/11/19/toupper.html&quot;&gt;this tangent about clang-format&lt;/a&gt;. In fact I &lt;em&gt;was&lt;/em&gt; writing that post, when I went off this current tangent, but then a footnote turned into several paragraphs, then got its own section and ultimately graduated into a whole post: the one you are reading. So consider this background reading for the “interesting” post still to come, although honestly the stuff here is probably more generally useful than the next part. &lt;a href=&quot;#fnref:intro&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:widthmatters&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;We should be clear here: when I say AVX-512 instruction in this context, I mean specifically a &lt;em&gt;512-bit wide instruction&lt;/em&gt; (which currently only exist in AVX-512). The distinction is that AVX-512 includes 128-bit and 256-bit versions of almost every instruction it introduces, yet these narrower instructions behave just like 128-bit SSE* and 256-bit AVX* instructions in terms of performance transitions. So, for example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpermw&lt;/code&gt; is unabiguously &lt;em&gt;AVX-512&lt;/em&gt; instruction: it only exists in AVX-512BW, but only the version that takes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zmm&lt;/code&gt; registers causes “AVX-512 like” performance transitions: the versions that take &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ymm&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xmm&lt;/code&gt; registers act as any other integer 256-bit AVX2 or 128-bit SSE instruction. &lt;a href=&quot;#fnref:widthmatters&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:speriod&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In fact, we generally want the sample period to be as small as possible, to give the best resolution and insight into short-lived events. We can’t make it &lt;em&gt;too&lt;/em&gt; short though as the samples themselves have a minimum time to capture, and very short samples tend to be noisy due to non-atomicity, quantization effects, etc. &lt;a href=&quot;#fnref:speriod&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:f2104&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The CPU is an &lt;a href=&quot;https://en.wikichip.org/wiki/intel/xeon_w/w-2104&quot;&gt;Intel W-2104&lt;/a&gt;, a Xeon-W chip based on the &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt; &lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt;. It has no turbo and an on-the-box speed of 3200 MHz, but accurate tools will probably report it running at 3192 MHz due to &lt;em&gt;&lt;a href=&quot;https://twitter.com/JeffSmith888/status/1211821823035351043&quot;&gt;spread spectrum clocking&lt;/a&gt;&lt;/em&gt; (SSC). In fact, we can see the typical 0.5% spread spectrum triangle wave on almost any of the plots in this post, at the right zoom level, &lt;a href=&quot;/assets/avxfreq1/fig-ssc.svg&quot;&gt;like this one&lt;/a&gt;. This occurs because we measure time (the x-axis) based on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdtsc&lt;/code&gt; which is based off of a different clock not subject to SSC, while the unhalted cycles counter counts CPU cycles, which are based off of the 100 MHz BLCK which is subject to SSC. &lt;a href=&quot;#fnref:f2104&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:avxt&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.realworldtech.com/forum/?threadid=179358&amp;amp;curpostid=179652&quot;&gt;Measured&lt;/a&gt; with &lt;a href=&quot;https://github.com/travisdowns/avx-turbo&quot;&gt;avx-turbo&lt;/a&gt;. &lt;a href=&quot;#fnref:avxt&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:vz&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This is the part where I just gloss over what that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vzeroupper&lt;/code&gt; is doing there. It’s there due to &lt;em&gt;implicit widening&lt;/em&gt;. That’s a new term I just invented and it’s the first and last time I’m mentioning it this post, because it really deserves an entire post of its own. The very short version is that any time an &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instruction writes to an N-bit register (N in {256, 512}), all subsequent &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instructions are &lt;em&gt;implicitly&lt;/em&gt; N bits wide, regardless of their actual width, for the purposes of determining turbo licenses and other transitions discussed here. This sounds a bit like the &lt;a href=&quot;https://stackoverflow.com/q/41303780/149138&quot;&gt;mixed-VEX penalties thing&lt;/a&gt;, but it is very different. This a mini-bombshell hidden in a footnote, so if you want to scoop me you can, but I’m not coming to your birthday party. &lt;a href=&quot;#fnref:vz&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:pperiod&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I.e., the &lt;em&gt;payload period&lt;/em&gt; is zero, but the structure of the test ensures the function is called once, at the start of the payload period, no matter how small the payload period is. &lt;a href=&quot;#fnref:pperiod&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:plotnotes&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;All of the plots in this post are SVG images, meaning they can be zoomed arbitrarily: so if you want to zoom in on any region feel free (the browser limits the zoom amount, but just save as a file and open it with any SVG viewer). &lt;a href=&quot;#fnref:plotnotes&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:falk&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;These are basically a poor man’s version of the &lt;em&gt;Falk Diagrams&lt;/em&gt; that Brandon Falk describes in &lt;a href=&quot;https://gamozolabs.github.io/metrology/2019/08/19/sushi_roll.html&quot;&gt;this post&lt;/a&gt; among others. Poor in the sense that they have ~3000 cycle resolution instead of 1 cycle resolution, and because the measurement code has to be integrated directly into the system under test. Basically they are nothing like &lt;em&gt;Falk Diagrams&lt;/em&gt; except that they have time on the x-axis and some performance counter event on the y-axis, but they are good enough for our purposes. &lt;a href=&quot;#fnref:falk&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:threerun&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Specifically, all three runs are identical and I show them just to give a rough impression of which effects are reproducible and which are outliers. The second and third runs have the suffixes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_2&lt;/code&gt;, respectively, in the legends. &lt;a href=&quot;#fnref:threerun&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:outlie&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;These outliers usually occur when an interrupt occurs during the measurement. Originally I used a 3 μs sample time, and there were almost no visible outliers with that period, but the 1 μs value I settled on is much better in most respects other than outliers. The main problem is when an interrupt takes more than the sample time of ~1 μs: this causes one or more samples to be very short, because a long sample will cause subsequent ones to be short (maybe &lt;em&gt;very&lt;/em&gt; short) until we catch up to the fixed sample schedule, and very short samples are subject to much more noise because the absolute metric values are much smaller but the error sources usually have fixed absolute error. Another source of outliers is when an interrupt &lt;em&gt;splits the stamp&lt;/em&gt;: the &lt;em&gt;stamp&lt;/em&gt; is the series of metrics we calculate at the sample point. These various metrics aren’t sampled atomically: if an interrupt occurs in the middle of the sampling, some metrics will reflect a much shorter time period (before the interrupt) and some a longer one (after). This effect tends to cause bidirectional spike outliers: where an upspike and downspike occur in consecutive samples. I try to avoid this by retrying the stamp if I think I’ve detected an interrupt during measurement (up to a retry limit). We could avoid all this nonsense by running the benchmark itself in the kernel, where we can disable interrupts (although some SMIs might still sneak in). Maybe next time! &lt;a href=&quot;#fnref:outlie&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:peachpuff&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;More precisely, the color is &lt;a href=&quot;https://encycolorpedia.com/ffdab9&quot;&gt;peachpuff&lt;/a&gt;. &lt;a href=&quot;#fnref:peachpuff&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:resnote&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Note that the resolution of the sampling is 1 μs, so when we say things like &lt;em&gt;9 μs&lt;/em&gt; and &lt;em&gt;11 μs&lt;/em&gt; it could be off by up to 1 μs. This 1 μs “error” isn’t exactly randomly distributed, because the sampling interval is “exact” and in phase with the payload execution. So the samples are always at 1.0, 2.0, 3.0, … μs after the payload executes (plus or minus small variation on the order of 10 nanoseconds), so if the true time until halt is anywhere between 9.00 and 9.99 μs, we will always read 9 μs (because time shown for the sample is the &lt;em&gt;end&lt;/em&gt; of the sample and covers the preceding 1 us). For the halt time, the scenario is reversed: the start of the interval is uncertain, but the end should be exact modulo the delay in taking the sample. &lt;a href=&quot;#fnref:resnote&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:halted&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Generally you can detect halted periods when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdtsc&lt;/code&gt; jumps forward, but performance counters like “non-halted cycles” do not, and there are not indications of a larger interruption such as a context switch. You can find a similar case of halted periods &lt;a href=&quot;https://stackoverflow.com/q/45472147/149138&quot;&gt;in this question&lt;/a&gt; which was also caused by frequency transitions (in this case, to obey the different active core count turbo ratios). &lt;a href=&quot;#fnref:halted&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:thistle&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;More precisely, the color is &lt;a href=&quot;https://encycolorpedia.com/d8bfd8&quot;&gt;thistle&lt;/a&gt;. &lt;a href=&quot;#fnref:thistle&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:confirm&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In particular, I have confirmed that these three samples all occur after the payload has executed and retired using the &lt;em&gt;period&lt;/em&gt; column in the output, which indicates clearly which sames are before or after a given execution of the payload. The payload itself is followed by an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lfence&lt;/code&gt; to ensure it has retired before taking further samples (and in any case the number of instructions per sample is too large be accommodated by the &lt;abbr title=&quot;Out-of-order execution allows CPUs to execute instructions out of order with respect to the source.&quot;&gt;OoO&lt;/abbr&gt; window). &lt;a href=&quot;#fnref:confirm&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:whynot&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Those who are still awake at this point might be wondering why introduce this new variant of the test now: why not just execute the payload instructions during the wait period in the original tests too? One reason is that by hot spinning on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdtsc&lt;/code&gt; we get somewhat more consistent results when we care only about measuring the frequency in that we almost always sample at exactly the specified period (plus or minus the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdtsc&lt;/code&gt; latency, more or less). When we execute the longish payload function during the wait, the sample point diverges a bit more from the ideal, and the number of spins per sample suffers more quantization effects (i.e., the pattern of spin counts might be 3,3,3,2,3,3,3,2… rather than 450,450,451,450…), which can sometimes lead to a slight sawtooth effect in the samples. &lt;a href=&quot;#fnref:whynot&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ideal&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In practice, we don’t exactly reach this ideal: we execute the payload function 2 or 3 times, for 2,000 or 3,000 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt; instructions, but there are about 600 additional instructions of overhead associated with taking a sample, so the overhead instructions are a significant portion. Probably 600 instructions is too many, I haven’t optimized that and it could likely be lowered significantly. However, we can also improve the ratio simply by decreasing the sampling resolution (i.e., increasing the sampling time). I selected 1 μs as a tradeoff between these competing factors. Note: Since I wrote this footnote I optimized several things in the sampling loop, so measured IPCs are now very close to their theoretical values, but I guess this footnote still has value?. &lt;a href=&quot;#fnref:ideal&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:give&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The main uncertainty in the timing of the function itself concerns the boundary conditions: if we run this function 10 times &lt;em&gt;without&lt;/em&gt; touching &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zmm0&lt;/code&gt; in between, the dependency on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zmm0&lt;/code&gt; will be carried between functions and the total time will be very close to 10 x 1000 = 10,000 cycles. However, if some compiler generated code in between calls to the payload function happens to write to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zmm0&lt;/code&gt;, breaking the dependency, the individual chains for each function no longer depend on each other, so some overlap is possible. The amount of this overlap is limited by the size of the RS, so the effect won’t be &lt;em&gt;huge&lt;/em&gt; but it could be noticeable (with say 100 payload instructions rather than 1,000 it could be very significant). We basically sidestep this whole issue by putting an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lfence&lt;/code&gt; between each call to the payload function, which forms an &lt;em&gt;execution barrier&lt;/em&gt; between calls. &lt;a href=&quot;#fnref:give&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:catchup&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;The way the sampling works in this test could be described &lt;em&gt;locked interval without skipping&lt;/em&gt;. Here, &lt;em&gt;locked interval&lt;/em&gt; means we calculate the next target sample time based on the previous &lt;em&gt;target&lt;/em&gt; sample time (rather than the &lt;em&gt;actual&lt;/em&gt; sample time), plus the period. So if we are sampling at 10 μs, the target sample times will always be 10 μs, 20 μs, etc. In particular, the series of target sample time doesn’t depend on what happens during the test, e.g., it doesn’t depend on the actual sample time: even if we actually end up sampling at time = 12 μs rather than 10, we target time = 20 μs as the next sample, not 12 + 10 = 22 μs. This raises the question about what happens when some delay (e.g., an interrupt, a frequency transition) causes us to miss more than 1 entire sample period.&lt;/p&gt;

      &lt;p&gt;E.g., with 10 μs resolution we just sampled at 90 μs, so the next sample target is 100 μs, but a delay causes the next sample to be taken at 125 μs. We are now behind! The next sample should occur at 110 μs, but of course that is in the past. The current test design still takes all the required samples, as quickly as possible (but with a minimum of one payload call if we are in the &lt;em&gt;extra payload period&lt;/em&gt;) – that’s the &lt;em&gt;no skipping&lt;/em&gt; part. In the current example, it means we would take subsequent samples quickly until we are caught up, at say 125 μs (target 110 μs), 126 μs (target 120 μs), 130 μs (target 130 μs), with that last sample being “on target”.&lt;/p&gt;

      &lt;p&gt;These samples occur quickly: very quickly in the case of normal samples which take less than 0.2 μs each, or more slowly in the case of the &lt;em&gt;extra payload&lt;/em&gt; region, where the payload call bumps that to about 0.5 μs. So that’s what’s happening in the green region: we just had a frequency transition halt of ~10 μs, so we are ~10 samples beyind and so the following samples are taken more quickly (as you can see because the data point markers are spaced more closely), with only a single payload call each (versus 2 or 3 usually). This changes the ratio of payload instructions to overhead instructions, which tends to bump the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; a bit (for the same reason the caught-up blue region almost shows &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; &amp;gt; 1). This effect can be reduced or eliminated by increasing the sampling period, since that reduces the number of catchup samples.&lt;/p&gt;

      &lt;p&gt;Incidentally, this also explains the oscillating pattern you see in the blue region: the ideal number of payload calls to get a 1 μs sample rate is ~2.5, so the sampling strategy tends to alternative between two and three calls: more calls means &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; closer to 1: so the peaks of the oscillating are two calls and the valleys, three. &lt;a href=&quot;#fnref:catchup&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:tput&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I’m not going to fully analyze the throughput case, but the thorough among us can find the chart is &lt;a href=&quot;/assets/avxfreq1/fig-ipc-zoomed-zmm-tput.svg&quot;&gt;here&lt;/a&gt;. Note that the overhead here cuts the other way: pushing the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; below the expected value of 2.0 (there are 2 512-bit vector units capable of executing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpord&lt;/code&gt;) because here the throughput limited instructions compete for ports with the overhead instructions. &lt;a href=&quot;#fnref:tput&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:orisit&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Of course, another possibility is that something in the rest of the test loop uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xmm&lt;/code&gt; registers so they remain “hot”: they are “baseline” for x86-64 after all, so the compiler is free to use them without any special flags. We could test this theory with a more compact test loop audited to be free of any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xmm&lt;/code&gt; use… but I’m not going to bother. I’m pretty sure these guys are powered up all the time as their use is pervasive in most x86-64 code. &lt;a href=&quot;#fnref:orisit&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:upper&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Specifically, the the part handing the second (bits 128:255) for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ymm&lt;/code&gt; case, and the upper 3 lanes (bits 128:511) in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zmm&lt;/code&gt; case. &lt;a href=&quot;#fnref:upper&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:amd&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This isn’t far fetched - that’s exactly how AMD Zen always executes 256-bit AVX instructions with its 128 bit units, and similar to how SVB and &lt;abbr title=&quot;Intel's Ivy Bridge architecture, aka 3rd Generation Intel Core i3,i5,i7&quot;&gt;IVB&lt;/abbr&gt; did the same for 256-bit load and store instructions. So using narrower vector units to implement wider instructions is definitely a thing. &lt;a href=&quot;#fnref:amd&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ewise&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;These are usually called &lt;em&gt;cross lane&lt;/em&gt; instructions (where a lane is 128 bits on Intel). For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpor&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; like this: it is an &lt;em&gt;element-wise&lt;/em&gt; operation where each output element (down to each bit, in this case) depends only on the element in the same position in the input vectors. On other the hand, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpermd&lt;/code&gt; is: each 32-bit element in the output can come from &lt;em&gt;any&lt;/em&gt; position in the input vector (but it still behaves as element-wise wrt the mask register&lt;sup id=&quot;fnref:bonus&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:bonus&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;41&lt;/a&gt;&lt;/sup&gt;). &lt;a href=&quot;#fnref:ewise&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:lt&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The notation 4L4T means: “4 cycles of latency and 4 cycles of inverse throughput”. That is, an given instance of this instruction takes 4 cycles to finish (latency), and a new instruction can start every 4 cycles (inverse throughput, hence the throughput is 0.25). When the CPU is running normally, most single-&lt;abbr title=&quot;Micro-operation: instructions are translated into one or more uops, which are simple operations executed by the CPU's execution units.&quot;&gt;uop&lt;/abbr&gt; &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instructions have latency of 1 (in lane), 3 (most cross lane integer or shuffle ops) or 4 (most FP arithmetic). &lt;a href=&quot;#fnref:lt&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:alu&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I say &lt;em&gt;ALU instructions&lt;/em&gt; here, but I strongly suspect it might be all instructions: you can certainly test that at home using the same test (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vporxymm250_*&lt;/code&gt; group of tests) but with other types of instructions such as loads replacing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;. I didn’t really test &lt;em&gt;all&lt;/em&gt; ALU instructions either: just a few - but it is fair to assume that if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; is slowed down, it is something generic, probably affecting at least all ALU stuff, not something instruction specific. &lt;a href=&quot;#fnref:alu&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ratentries&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Documentation claims 97 entries, but my testing seems to indicate they are not unified in Skylake: apparently only 64 can be used for ALU ops, and 33 for memory ops. &lt;a href=&quot;#fnref:ratentries&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:vcc&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Try as I might, I can’t determine if this refers to &lt;em&gt;measured&lt;/em&gt; core voltage, i.e., true voltage as determine at some sensor within the core, or &lt;em&gt;demanded&lt;/em&gt; voltage, i.e., the voltage the processor wants right now based on the various power-relevant parameters, sometimes called the VID. In any case, we expect those values to track each other fairly closely, perhaps with some offset and since we are looking for voltage &lt;em&gt;changes&lt;/em&gt; either one works. That said, I am very interested if you know the answer to this question. &lt;a href=&quot;#fnref:vcc&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:whyp&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This payload time series is meant to show the exact same thing as the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; series in earlier charts: we just want an indication of when the Type 1 throttling starts and stops. I used &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; initially because it was easy (I didn’t have to instrument the payload section specially) - but it doesn’t work when reading volts because that measurement involves a ton of additional instructions and a user-kernel transition, so it throws the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt; off completely. So I went ahead and instrumented the payload section directly, so we can still see the throttling, but no way I want to go back and change the other plots that use &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt;. &lt;a href=&quot;#fnref:whyp&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:cthrottle&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The throttling here is quite conservative I think: this is only a very small voltage change (less than 1%), so it is hard to believe that 4x throttling is &lt;em&gt;necessary.&lt;/em&gt; It seems likely, for example, that cutting the dispatch rate in half would be enough to compensate for the missing 6 mV – but it is easy to imagine that just having a big conservative throttling number for all these voltage-too-low throttling scenarios is easy and safe, and these periods don’t occur often enough for it to really matter. &lt;a href=&quot;#fnref:cthrottle&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:acc&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Essentially all modern Intel CPUs have varying maximum turbo ratios depending on the number of active (not halted or in a sleep state). E.g., my Skylake CPU can run at at a max speed of 3.5, 3.3, 3.2 or 3.1 GHz if 1, 2, 3 or 4 cores are active, respectively. If only one core is currently running, at 3.5 GHz, and another core becomes active (e.g., because the scheduler found something to run) – the first core has to immediately transition down to 3.3 GHz and as we’ve seen above, it takes an ~8-10 μs halt to do so. When the other core stops running, it can return to 3.3 GHz. If cores are flipping between inactive and active quickly enough, those halts add up and cut into your effective frequency. At some point, you might get less work done by trying to run at max turbo, versus just running at 3.3 GHz all the time since in this case no halts need to be taken when the second core starts. Further explored &lt;a href=&quot;https://stackoverflow.com/a/45592838/149138&quot;&gt;over here&lt;/a&gt;. &lt;a href=&quot;#fnref:acc&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:hiddenbo&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Avoiding these transitions are a hidden bonus of making the 1 and 2-core turbos the same, and more generally “grouping” the turbo ratios in a more coarse grained way across core counts: you don’t need any transition when the “from” and “to” core counts have the same max turbo ratio. &lt;a href=&quot;#fnref:hiddenbo&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:recovery&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Earlier we mentioned a low frequency duration of 650 μs, but that was the test that ran only a single payload instruction. The recovery period is measured from the &lt;em&gt;last&lt;/em&gt; wide instruction and in this test (that shows the &lt;abbr title=&quot;Instructions per cycle: calculated over an interval by measuring the number of instructions executed and the duration in cycles.&quot;&gt;IPC&lt;/abbr&gt;) we execute 100 μs of payload, so the recovery time will be 100 μs + 650 μs = ~750 μs. &lt;a href=&quot;#fnref:recovery&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:heavy&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Unlike the transitions discussed here, transitions related to heavy instructions are &lt;em&gt;soft&lt;/em&gt; transitions: they do not occur unconditionally after a single instruction of the relevant type is executed, but rather only after some &lt;em&gt;density&lt;/em&gt; threshold is reached for those instructions. Exploring this threshold would be interesting. There is another effect mentioned in the Intel optimization manual: heavy instructions may cause a license transition even in cases where it wouldn’t normally occur, when light instructions of one license level are mixed with &lt;em&gt;half-width&lt;/em&gt; heavy instructions. That is, 128-bit heavy instructions can use the fastest L0 license, as can 256-bit light instructions. However, apparently, mixing these can cause a request for the L1 license. Similarly for 256-bit heavy instructions and 512-bit light instructions, where a downgrade from L1 to L2 could occur. &lt;a href=&quot;#fnref:heavy&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:t1deets&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I give a range of 8 to 20 μs because that’s what I measured in my testing, but the highest frequency I measured for a voltage-only transition at was 3.5 GHz, with a 15 mV delta. It is entirely possible that at higher frequencies and voltages, times are much longer. It could also depend on the hardware, e.g., the presence or absence of a &lt;abbr title=&quot;Fully Integrated Voltage Regulator&quot;&gt;FIVR&lt;/abbr&gt;. &lt;a href=&quot;#fnref:t1deets&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:fdeets&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This transition time seems to be required by &lt;em&gt;any&lt;/em&gt; frequency transition, whether up or down in frequency and regardless of the cause. This includes transition causes not tested here: for example, when the max turbo ratio changes because the active core count changes, or when the ideal frequency changes for any other reason. &lt;a href=&quot;#fnref:fdeets&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:lldeets&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This same relaxation period appears to apply to both of the transitions types discussed in this post, e.g., both voltage and frequency. The relaxation timer is reset any type an instruction that needs the current license is executed. In this case, the 680 μs period is measured from the instruction that causes the transition (which is also the last relevant instruction since only a single payload instruction is used), until the time that the CPU resumes executing again at the higher frequency. This period includes one dispatch throttling period and two frequency transitions, so only about 650 μs of the 680 μs is spent executing instructions at full speed. &lt;a href=&quot;#fnref:lldeets&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:bonus&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Bonus question: are there &lt;em&gt;any&lt;/em&gt; single-&lt;abbr title=&quot;Micro-operation: instructions are translated into one or more uops, which are simple operations executed by the CPU's execution units.&quot;&gt;uop&lt;/abbr&gt; AVX/AVX-512 instructions which are &lt;abbr title=&quot;A SIMD operation whose lane-wise output depends on elements from lanes other than the same lane in the inputs (lanes are 128 bits in x86).&quot;&gt;cross-lane&lt;/abbr&gt; in at least two of their inputs? There are 3-input shuffles, like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VPERMI2B&lt;/code&gt;, which have 2 of their 3 inputs as &lt;abbr title=&quot;A SIMD operation whose lane-wise output depends on elements from lanes other than the same lane in the inputs (lanes are 128 bits in x86).&quot;&gt;cross-lane&lt;/abbr&gt; (the two input tables), but they need 2 uops. &lt;a href=&quot;#fnref:bonus&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Travis Downs</name><email>travis.downs@gmail.com</email></author><category term="blog" /><category term="performance" /><category term="c++" /><category term="Intel" /><category term="uarch" /><summary type="html">Investigating some details of SIMD related frequency transitions on Intel CPUs.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://travisdowns.github.io/assets/avxfreq1/twitter-card.png" /><media:content medium="image" url="https://travisdowns.github.io/assets/avxfreq1/twitter-card.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">A Note on Mask Registers</title><link href="https://travisdowns.github.io/blog/2019/12/05/kreg-facts.html" rel="alternate" type="text/html" title="A Note on Mask Registers" /><published>2019-12-05T16:30:00+00:00</published><updated>2019-12-05T16:30:00+00:00</updated><id>https://travisdowns.github.io/blog/2019/12/05/kreg-facts</id><content type="html" xml:base="https://travisdowns.github.io/blog/2019/12/05/kreg-facts.html">&lt;p class=&quot;warning&quot;&gt;If you are in a rush, you can &lt;a href=&quot;#summary&quot;&gt;skip to the summary&lt;/a&gt;, but you’ll miss out on the journey.&lt;/p&gt;

&lt;p&gt;AVX-512 introduced eight so-called &lt;em&gt;mask registers&lt;/em&gt;&lt;sup id=&quot;fnref:naming&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:naming&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k0&lt;/code&gt;&lt;sup id=&quot;fnref:k0note&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:k0note&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k7&lt;/code&gt;, which apply to most ALU operations and allow you to apply a zero-masking or merging&lt;sup id=&quot;fnref:maskmerge&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:maskmerge&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; operation on a per-element basis, speeding up code that would otherwise require extra blending operations in AVX2 and earlier.&lt;/p&gt;

&lt;p&gt;If that single sentence doesn’t immediately indoctrinate you into the mask register religion, here’s a copy and paste from &lt;a href=&quot;https://en.wikipedia.org/wiki/AVX-512#Opmask_registers&quot;&gt;Wikipedia&lt;/a&gt; that should fill in the gaps and close the deal:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Most AVX-512 instructions may indicate one of 8 opmask registers (k0–k7). For instructions which use a mask register as an opmask, register &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k0&lt;/code&gt; is special: a hardcoded constant used to indicate unmasked operations. For other operations, such as those that write to an opmask register or perform arithmetic or logical operations, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k0&lt;/code&gt; is a functioning, valid register. In most instructions, the opmask is used to control which values are written to the destination. A flag controls the opmask behavior, which can either be “zero”, which zeros everything not selected by the mask, or “merge”, which leaves everything not selected untouched. The merge behavior is identical to the blend instructions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So mask registers&lt;sup id=&quot;fnref:kreg&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:kreg&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; are important, but are not household names unlike say general purpose registers (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eax&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsi&lt;/code&gt; and friends) or &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; registers (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xmm0&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ymm5&lt;/code&gt;, etc). They certainly aren’t going to show up on Intel slides disclosing the size of &lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt; resources, like these:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg/min/intel-skx-slide.png&quot; alt=&quot;Intel Slide&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;In particular, I don’t think the size of the mask register physical register file (&lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt;) has ever been reported. Let’s fix that today.&lt;/p&gt;

&lt;p&gt;We use an updated version of the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; size &lt;a href=&quot;https://github.com/travisdowns/robsize&quot;&gt;probing tool&lt;/a&gt; originally authored and &lt;a href=&quot;http://blog.stuffedcow.net/2013/05/measuring-rob-capacity/&quot;&gt;described by Henry Wong&lt;/a&gt;&lt;sup id=&quot;fnref:hcite&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:hcite&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; (hereafter simply &lt;em&gt;Henry&lt;/em&gt;), who used it to probe the size of various documented and undocumented &lt;abbr title=&quot;Out-of-order execution allows CPUs to execute instructions out of order with respect to the source.&quot;&gt;out-of-order&lt;/abbr&gt; structures on earlier architecture. If you haven’t already read that post, stop now and do it. This post will be here when you get back.&lt;/p&gt;

&lt;p&gt;You’ve already read Henry’s blog for a full description (right?), but for the naughty among you here’s the fast food version:&lt;/p&gt;

&lt;h4 id=&quot;fast-food-method-of-operation&quot;&gt;Fast Food Method of Operation&lt;/h4&gt;

&lt;p&gt;We separate two cache miss load instructions&lt;sup id=&quot;fnref:misstime&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:misstime&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; by a variable number of &lt;em&gt;filler instructions&lt;/em&gt; which vary based on the CPU resource we are probing. When the number of filler instructions is small enough, the two cache misses execute in parallel and their latencies are overlapped so the total execution time is roughly&lt;sup id=&quot;fnref:roughly&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:roughly&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt; as long as a single miss.&lt;/p&gt;

&lt;p&gt;However, once the number of filler instructions reaches a critical threshold, all of the targeted resource are consumed and instruction allocation stalls before the second miss is issued and so the cache misses can no longer run in parallel. This causes the runtime to spike to about twice the baseline cache miss latency.&lt;/p&gt;

&lt;p&gt;Finally, we ensure that each filler instruction consumes exactly one of the resource we are interested in, so that the location of the spike indicates the size of the underlying resource. For example, regular &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; instructions usually consume one physical register from the &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; so are a good choice to measure the size of that resource.&lt;/p&gt;

&lt;h4 id=&quot;mask-register-prf-size&quot;&gt;Mask Register &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; Size&lt;/h4&gt;

&lt;p&gt;Here, we use instructions that write a mask register, so can measure the size of the mask register &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt;.&lt;/p&gt;

&lt;p&gt;To start, we use a series of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd k1, k2, k3&lt;/code&gt; instructions, as such (shown for 16 filler instructions):&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;QWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; first cache miss load&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;QWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; second cache miss load&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;lfence&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;; stop issue until the above block completes&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; this block is repeated 16 more times&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd&lt;/code&gt; instruction consumes one physical mask register. If number of filler instructions is equal to or less than the number of mask registers, we expect the misses to happen in parallel, otherwise the misses will be resolved serially. So we expect at that point to see a large spike in the running time.&lt;/p&gt;

&lt;p&gt;That’s exactly what we see:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg/min/skx-27.svg&quot; alt=&quot;Test 27 kaddd instructions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let’s zoom in on the critical region, where the spike occurs:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg/min/skx-27-zoomed.svg&quot; alt=&quot;Test 27 zoomed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here we clearly see that the transition isn’t &lt;em&gt;sharp&lt;/em&gt; – when the filler instruction count is between 130 and 134, we the runtime is intermediate: falling between the low and high levels. Henry calls this &lt;em&gt;non ideal&lt;/em&gt; behavior and I have seen it repeatedly across many but not all of these resource size tests. The idea is that the hardware implementation doesn’t always allow all of the resources to be used as you approach the limit&lt;sup id=&quot;fnref:nonideal&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:nonideal&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt; - sometimes you get to use every last resource, but in other cases you may hit the limit a few filler instructions before the theoretical limit.&lt;/p&gt;

&lt;p&gt;Under this assumption, we want to look at the last (rightmost) point which is still faster than the slow performance level, since it indicates that &lt;em&gt;sometimes&lt;/em&gt; that many resources are available, implying that at least that many are physically present. Here, we see that final point occurs at 134 filler instructions.&lt;/p&gt;

&lt;p&gt;So we conclude that &lt;em&gt;&lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt; has 134 physical registers available to hold speculative mask register values&lt;/em&gt;. As Henry indicates on the original post, it is likely that there are 8 physical registers dedicated to holding the non-speculative architectural state of the 8 mask registers, so our best guess at the total size of the mask register &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; is 142. That’s somewhat smaller than the &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; (180 entires) or the &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; (168 entries), but still quite large (see &lt;a href=&quot;/blog/2019/06/11/speed-limits.html#ooo-table&quot;&gt;this table of out of order resource sizes&lt;/a&gt; for sizes on other platforms).&lt;/p&gt;

&lt;p&gt;In particular, it is definitely large enough that you aren’t likely to run into this limit in practical code: it’s hard to imagine non-contrived code where almost 60%&lt;sup id=&quot;fnref:twothirds&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:twothirds&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt; of the instructions &lt;em&gt;write&lt;/em&gt;&lt;sup id=&quot;fnref:write&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:write&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt; to mask registers, because that’s what you’d need to hit this limit.&lt;/p&gt;

&lt;h4 id=&quot;are-they-distinct-prfs&quot;&gt;Are They Distinct PRFs?&lt;/h4&gt;

&lt;p&gt;You may have noticed that so far I’m simply &lt;em&gt;assuming&lt;/em&gt; that the mask register &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; is distinct from the others. I think this is highly likely, given the way mask registers are used and since they are part of a disjoint renaming domain&lt;sup id=&quot;fnref:rename&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:rename&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;. It is also supported by the fact that that apparent mask register PFR size doesn’t match either the &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; or &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; sizes, but we can go further and actually test it!&lt;/p&gt;

&lt;p&gt;To do that, we use a similar test to the above, but with the filler instructions alternating between the same &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd&lt;/code&gt; instruction as the original test and an instruction that uses either a &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; or &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; register. If the register file is shared, we expect to hit a limit at size of the &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt;. If the PRFs are not shared, we expect that neither &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; limit will be hit, and we will instead hit a different limit such as the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; size.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/travisdowns/robsize/blob/fb039f212f1364e2e65b8cb2a0c3f8023c85777f/asm-gold/asm-29.asm&quot;&gt;Test 29&lt;/a&gt; alternates &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd&lt;/code&gt; and scalar &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt; instructions, like this:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;QWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ebx&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ebx&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ebx&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ebx&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;QWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;lfence&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here’s the chart:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg/min/skx-29.svg&quot; alt=&quot;Test 29: alternating kaddd and scalar add&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We see that the spike is at a filler count larger than the &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; and &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; sizes. So we can conclude that the mask and &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; PRFs are not shared.&lt;/p&gt;

&lt;p&gt;Maybe the mask register is shared with the &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt;? After all, mask registers are more closely associated with &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instructions than general purpose ones, so maybe there is some synergy there.&lt;/p&gt;

&lt;p&gt;To check, here’s &lt;a href=&quot;https://github.com/travisdowns/robsize/blob/fb039f212f1364e2e65b8cb2a0c3f8023c85777f/asm-gold/asm-35.asm&quot;&gt;Test 35&lt;/a&gt;, which is similar to 29 except that it alternates between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vxorps&lt;/code&gt;, like so:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;QWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vxorps&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vxorps&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vxorps&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm5&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vxorps&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm7&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vxorps&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vxorps&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vxorps&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ymm5&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kaddd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;QWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;lfence&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here’s the corresponding chart:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg/min/skx-35.svg&quot; alt=&quot;Test 35: alternating kaddd and SIMD xor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The behavior is basically identical to the prior test, so we conclude that there is no direct sharing between the mask register and &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; PRFs either.&lt;/p&gt;

&lt;p class=&quot;warning&quot;&gt;This turned out not to be the end of the story. The mask registers &lt;em&gt;are&lt;/em&gt; shared, just not with the general purpose or SSE/AVX register file. For all the details, see this &lt;a href=&quot;/blog/2020/05/26/kreg2.html&quot;&gt;follow up post&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;an-unresolved-puzzle&quot;&gt;An Unresolved Puzzle&lt;/h4&gt;

&lt;p&gt;Something we notice in both of the above tests, however, is that the spike seems to finish around 212 filler instructions. However, the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; size for this microarchtiecture is 224. Is this just &lt;em&gt;non ideal behavior&lt;/em&gt; as we saw earlier? Well we can test this by comparing against Test 4, which just uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nop&lt;/code&gt; instructions as the filler: these shouldn’t consume almost any resources beyond &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; entries. Here’s Test 4 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nop&lt;/code&gt; filer) versus Test 29 (alternating &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd&lt;/code&gt; and scalar &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg/min/skx-4-29.svg&quot; alt=&quot;Test 4 vs 29&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nop&lt;/code&gt;-using &lt;a href=&quot;https://github.com/travisdowns/robsize/blob/fb039f212f1364e2e65b8cb2a0c3f8023c85777f/asm-gold/asm-4.asm&quot;&gt;Test 4&lt;/a&gt; &lt;em&gt;nails&lt;/em&gt; the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; size at exactly 224 (these charts are SVG so feel free to “View Image” and zoom in confirm). So it seems that we hit some other limit around 212 when we mix mask and &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; registers, or when we mix mask and &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; registers. In fact the same limit applies even between &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; and &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; registers, if we compare Test 4 and &lt;a href=&quot;https://github.com/travisdowns/robsize/blob/fb039f212f1364e2e65b8cb2a0c3f8023c85777f/asm-gold/asm-21.asm&quot;&gt;Test 21&lt;/a&gt; (which mixes &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; adds with &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vxorps&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg/min/skx-4-21.svg&quot; alt=&quot;Test 4 vs 21&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Henry mentions a more extreme version of the same thing in the original &lt;a href=&quot;http://blog.stuffedcow.net/2013/05/measuring-rob-capacity/&quot;&gt;blog entry&lt;/a&gt;, in the section also headed &lt;strong&gt;Unresolved Puzzle&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sandy Bridge AVX or SSE interleaved with integer instructions seems to be limited to looking ahead ~147 instructions by something other than the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt;. Having tried other combinations (e.g., varying the ordering and proportion of AVX vs. integer instructions, inserting some NOPs into the mix), it seems as though both SSE/AVX and integer instructions consume registers from some form of shared pool, as the instruction window is always limited to around 147 regardless of how many of each type of instruction are used, as long as neither type exhausts its own &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; supply on its own.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Read the full section for all the details. The effect is similar here but smaller: we at least get 95% of the way to the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; size, but still stop before it.  It is possible the shared resource is related to register reclamation, e.g., the PRRT&lt;sup id=&quot;fnref:prrt&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:prrt&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt; - a table which keeps track of which registers can be reclaimed when a given instruction retires.&lt;/p&gt;

&lt;p&gt;Finally, we finish this party off with a few miscellaneous notes on mask registers, checking for parity with some features available to &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; and &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; registers.&lt;/p&gt;

&lt;h3 id=&quot;move-elimination&quot;&gt;Move Elimination&lt;/h3&gt;

&lt;p&gt;Both &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; and &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; registers are eligible for so-called &lt;em&gt;move elimination&lt;/em&gt;. This means that a register to register move like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov eax, edx&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vmovdqu ymm1, ymm2&lt;/code&gt; can be eliminated at rename by “simply”&lt;sup id=&quot;fnref:simply&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:simply&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;13&lt;/a&gt;&lt;/sup&gt; pointing the destination register entry in the &lt;abbr title=&quot;Register alias table: a table which maps an architectural register identifier to a physical register.&quot;&gt;RAT&lt;/abbr&gt; to the same physical register as the source, without involving the ALU.&lt;/p&gt;

&lt;p&gt;Let’s check if something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmov k1, k2&lt;/code&gt; also qualifies for move elimination. First, we check the chart for &lt;a href=&quot;https://github.com/travisdowns/robsize/blob/fb039f212f1364e2e65b8cb2a0c3f8023c85777f/asm-gold/asm-28.asm&quot;&gt;Test 28&lt;/a&gt;, where the filler instruction is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmovd k1, k2&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/kreg/min/skx-28.svg&quot; alt=&quot;Test 28&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It looks exactly like Test 27 we saw earlier with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kaddd&lt;/code&gt;. So we would suspect that physical registers are being consumed, unless we have happened to hit a different move-elimination related limit with exactly the same size and limiting behavior&lt;sup id=&quot;fnref:moves&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:moves&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;14&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Additional confirmation comes from uops.info which &lt;a href=&quot;https://uops.info/table.html?search=kmov%20(K%2C%20K)&amp;amp;cb_lat=on&amp;amp;cb_tp=on&amp;amp;cb_uops=on&amp;amp;cb_ports=on&amp;amp;cb_SKX=on&amp;amp;cb_measurements=on&amp;amp;cb_avx512=on&quot;&gt;shows that&lt;/a&gt; all variants of mask to mask register &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmov&lt;/code&gt; take one &lt;abbr title=&quot;Micro-operation: instructions are translated into one or more uops, which are simple operations executed by the CPU's execution units.&quot;&gt;uop&lt;/abbr&gt; dispatched to &lt;abbr title=&quot;port 0 (GP and SIMD ALU, not-taken branches)&quot;&gt;p0&lt;/abbr&gt;. If the move is eliminated, we wouldn’t see any dispatched uops.&lt;/p&gt;

&lt;p&gt;Therefore I conclude that register to register&lt;sup id=&quot;fnref:regreg&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:regreg&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;15&lt;/a&gt;&lt;/sup&gt; moves involving mask registers are not eliminated.&lt;/p&gt;

&lt;h3 id=&quot;dependency-breaking-idioms&quot;&gt;Dependency Breaking Idioms&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&quot;https://stackoverflow.com/a/33668295/149138&quot;&gt;best way&lt;/a&gt; to set a &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; register to zero in x86 is via the xor zeroing idiom: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xor reg, reg&lt;/code&gt;. This works because any value xored with itself is zero. This is smaller (fewer instruction bytes) than the more obvious &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov eax, 0&lt;/code&gt;, and also faster since the processor recognizes it as a &lt;em&gt;zeroing idiom&lt;/em&gt; and performs the necessary work at rename&lt;sup id=&quot;fnref:zero&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:zero&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;16&lt;/a&gt;&lt;/sup&gt;, so no ALU is involved and no &lt;abbr title=&quot;Micro-operation: instructions are translated into one or more uops, which are simple operations executed by the CPU's execution units.&quot;&gt;uop&lt;/abbr&gt; is dispatched.&lt;/p&gt;

&lt;p&gt;Furthermore, the idiom is &lt;em&gt;dependency breaking:&lt;/em&gt; although &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xor reg1, reg2&lt;/code&gt; in general depends on the value of both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reg1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reg2&lt;/code&gt;, in the special case that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reg1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reg2&lt;/code&gt; are the same, there is no dependency as the result is zero regardless of the inputs. All modern x86 CPUs recognize this&lt;sup id=&quot;fnref:otherzero&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:otherzero&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;17&lt;/a&gt;&lt;/sup&gt; special case for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xor&lt;/code&gt;. The same applies to &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; versions of xor such as integer &lt;a href=&quot;https://www.felixcloutier.com/x86/pxor&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpxor&lt;/code&gt;&lt;/a&gt; and floating point &lt;a href=&quot;https://www.felixcloutier.com/x86/xorps&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vxorps&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://www.felixcloutier.com/x86/xorpd&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vxorpd&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That background out of the way, a curious person might wonder if the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxor&lt;/code&gt; &lt;a href=&quot;https://www.felixcloutier.com/x86/kxorw:kxorb:kxorq:kxord&quot;&gt;variants&lt;/a&gt; are treated the same way. Is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxorb k1, k1, k1&lt;/code&gt;&lt;sup id=&quot;fnref:notall&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:notall&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;18&lt;/a&gt;&lt;/sup&gt; treated as a zeroing idiom?&lt;/p&gt;

&lt;p&gt;This is actually two separate questions, since there are two aspects to zeroing idioms:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Zero latency execution with no execution unit (elimination)&lt;/li&gt;
  &lt;li&gt;Dependency breaking&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s look at each in turn.&lt;/p&gt;

&lt;h4 id=&quot;execution-elimination&quot;&gt;Execution Elimination&lt;/h4&gt;

&lt;p&gt;So are zeroing xors like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxorb k1, k1, k1&lt;/code&gt; executed at rename without latency and without needing an execution unit?&lt;/p&gt;

&lt;p&gt;No.&lt;/p&gt;

&lt;p&gt;Here, I don’t even have to do any work: uops.info has our back because they’ve performed &lt;a href=&quot;https://uops.info/html-tp/SKX/KXORD_K_K_K-Measurements.html#sameReg&quot;&gt;this exact test&lt;/a&gt; and report a latency of 1 cycle and one &lt;abbr title=&quot;port 0 (GP and SIMD ALU, not-taken branches)&quot;&gt;p0&lt;/abbr&gt; &lt;abbr title=&quot;Micro-operation: instructions are translated into one or more uops, which are simple operations executed by the CPU's execution units.&quot;&gt;uop&lt;/abbr&gt; used. So we can conclude that zeroing xors of mask registers are not eliminated.&lt;/p&gt;

&lt;h4 id=&quot;dependency-breaking&quot;&gt;Dependency Breaking&lt;/h4&gt;

&lt;p&gt;Well maybe zeroing kxors are dependency breaking, even though they require an execution unit?&lt;/p&gt;

&lt;p&gt;In this case, we can’t simply check uops.info. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxor&lt;/code&gt; is a one cycle latency instruction that runs only on a single execution port (&lt;abbr title=&quot;port 0 (GP and SIMD ALU, not-taken branches)&quot;&gt;p0&lt;/abbr&gt;), so we hit the interesting (?) case where a chain of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxor&lt;/code&gt; runs at the same speed regardless of whether the are dependent or independent: the throughput bottleneck of 1/cycle is the same as the latency bottleneck of 1/cycle!&lt;/p&gt;

&lt;p&gt;Don’t worry, we’ve got other tricks up our sleeve. We can test this by constructing a tests which involve a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxor&lt;/code&gt; in a carried dependency chain with enough total latency so that the chain latency is the bottleneck. If the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxor&lt;/code&gt; carries a dependency, the runtime will be equal to the sum of the latencies in the chain. If the instruction is dependency breaking, the chain is broken and the different disconnected chains can overlap and performance will likely be limited by some throughput restriction (e.g., &lt;a href=&quot;/blog/2019/06/11/speed-limits.html#portexecution-unit-limits&quot;&gt;port contention&lt;/a&gt;). This could use a good diagram, but I’m not good at diagrams.&lt;/p&gt;

&lt;p&gt;All the tests are in &lt;a href=&quot;https://github.com/travisdowns/uarch-bench/blob/ccbebbec39ab02d6460a1837857d052e120c0946/x86_avx512.asm#L20&quot;&gt;&lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt; bench&lt;/a&gt;, but I’ll show the key parts here.&lt;/p&gt;

&lt;p&gt;First we get a baseline measurement for the latency of moving from a mask register to a &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; register and back:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;kmovb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kmovb&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; repeated 127 more times&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This pair clocks in&lt;sup id=&quot;fnref:runit&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:runit&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;19&lt;/a&gt;&lt;/sup&gt; at 4 cycles. It’s hard to know how to partition the latency between the two instructions: are they both 2 cycles or is there a 3-1 split one way or the other&lt;sup id=&quot;fnref:fyiuops&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:fyiuops&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;20&lt;/a&gt;&lt;/sup&gt;, but for our purposes it doesn’t matter because we just care about the latency of the round-trip. Importantly, the post-based throughput limit of this sequence is 1/cycle, 4x faster than the latency limit, because each instruction goes to a different port (&lt;abbr title=&quot;port 5 (GP and SIMD ALU, vector shuffles)&quot;&gt;p5&lt;/abbr&gt; and &lt;abbr title=&quot;port 0 (GP and SIMD ALU, not-taken branches)&quot;&gt;p0&lt;/abbr&gt;, respectively). This means we will be able to tease out latency effects independent of throughput.&lt;/p&gt;

&lt;p&gt;Next, we throw a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxor&lt;/code&gt; into the chain that we know is &lt;em&gt;not&lt;/em&gt; zeroing:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;kmovb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kxorb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kmovb&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; repeated 127 more times&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since &lt;a href=&quot;https://uops.info/table.html?search=kxorb&amp;amp;cb_lat=on&amp;amp;cb_tp=on&amp;amp;cb_uops=on&amp;amp;cb_ports=on&amp;amp;cb_SKX=on&amp;amp;cb_measurements=on&amp;amp;cb_avx512=on&quot;&gt;we know&lt;/a&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxorb&lt;/code&gt; has 1 cycle of latency, we expect to increase the latency to 5 cycles and that’s exactly what we measure (the first two tests shown):&lt;/p&gt;

&lt;pre&gt;
** Running group avx512 : AVX512 stuff **
                               Benchmark    Cycles     Nanos
                kreg-GP rountrip latency      4.00      1.25
    kreg-GP roundtrip + nonzeroing kxorb      5.00      1.57
&lt;/pre&gt;

&lt;p&gt;Finally, the key test:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;kmovb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kxorb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kmovb&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; repeated 127 more times&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This has a zeroing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxorb k0, k0, k0&lt;/code&gt;. If it breaks the dependency on k0, it would mean that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmovb eax, k0&lt;/code&gt; no longer depends on the earlier &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmovb k0, eax&lt;/code&gt;, and the carried chain is broken and we’d see a lower cycle time.&lt;/p&gt;

&lt;p&gt;Drumroll…&lt;/p&gt;

&lt;p&gt;We measure this at the exact same 5.0 cycles as the prior example:&lt;/p&gt;

&lt;pre&gt;
** Running group avx512 : AVX512 stuff **
                               Benchmark    Cycles     Nanos
                kreg-GP rountrip latency      4.00      1.25
    kreg-GP roundtrip + nonzeroing kxorb      5.00      1.57
&lt;span style=&quot;background: green;&quot;&gt;       kreg-GP roundtrip + zeroing kxorb      5.00      1.57&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;So we tentatively conclude that zeroing idioms aren’t recognized at all when they involve mask registers.&lt;/p&gt;

&lt;p&gt;Finally, as a check on our logic, we use the following test which replaces the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxor&lt;/code&gt; with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmov&lt;/code&gt; which we know is &lt;em&gt;always&lt;/em&gt; dependency breaking:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;kmovb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kmovb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ecx&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;kmovb&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; repeated 127 more times&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is the final result shown in the output above, and it runs much more quickly at 2 cycles, bottlenecked on &lt;abbr title=&quot;port 5 (GP and SIMD ALU, vector shuffles)&quot;&gt;p5&lt;/abbr&gt; (the two &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmov k, r32&lt;/code&gt; instructions both go only to &lt;abbr title=&quot;port 5 (GP and SIMD ALU, vector shuffles)&quot;&gt;p5&lt;/abbr&gt;):&lt;/p&gt;

&lt;pre&gt;
** Running group avx512 : AVX512 stuff **
                               Benchmark    Cycles     Nanos
                kreg-GP rountrip latency      4.00      1.25
    kreg-GP roundtrip + nonzeroing kxorb      5.00      1.57
       kreg-GP roundtrip + zeroing kxorb      5.00      1.57
&lt;span style=&quot;background: green;&quot;&gt;         kreg-GP roundtrip + mov from GP      2.00      0.63&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;So our experiment seems to check out.&lt;/p&gt;

&lt;h3 id=&quot;reproduction&quot;&gt;Reproduction&lt;/h3&gt;

&lt;p&gt;You can reproduce these results yourself with the &lt;a href=&quot;https://github.com/travisdowns/robsize&quot;&gt;robsize&lt;/a&gt; binary on Linux or Windows (using WSL). The specific results for this article are &lt;a href=&quot;https://github.com/travisdowns/robsize/tree/master/scripts/kreg/results&quot;&gt;also available&lt;/a&gt; as are the &lt;a href=&quot;https://github.com/travisdowns/robsize/tree/master/scripts/kreg/&quot;&gt;scripts&lt;/a&gt; used to collect them and generate the plots.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt; has a separate &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; for mask registers with a speculative size of 134 and an estimated total size of 142&lt;/li&gt;
  &lt;li&gt;This is large enough compared to the other &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; size and the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; to make it unlikely to be a bottleneck&lt;/li&gt;
  &lt;li&gt;Mask registers are not eligible for move elimination&lt;/li&gt;
  &lt;li&gt;Zeroing idioms&lt;sup id=&quot;fnref:tech&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:tech&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;21&lt;/a&gt;&lt;/sup&gt; in mask registers are not recognized for execution elimination or dependency breaking&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;part-ii&quot;&gt;Part II&lt;/h3&gt;

&lt;p&gt;I didn’t expect it to happen, but it did: there is a &lt;a href=&quot;/blog/2020/05/26/kreg2.html&quot;&gt;follow up post&lt;/a&gt; about mask registers, where we (roughly) confirm the register file size by looking at an image of a &lt;abbr title=&quot;Intel's Skylake (server) architecture including Skylake-SP, Skylake-X and Skylake-W&quot;&gt;SKX&lt;/abbr&gt; CPU captured via microcope, and make an interesting discovery regarding sharing.&lt;/p&gt;

&lt;h3 id=&quot;comments&quot;&gt;Comments&lt;/h3&gt;

&lt;p&gt;Discussion on &lt;a href=&quot;https://news.ycombinator.com/item?id=21714390&quot;&gt;Hacker News&lt;/a&gt;, Reddit (&lt;a href=&quot;https://www.reddit.com/r/asm/comments/e6kokb/x86_avx512_a_note_on_mask_registers/&quot;&gt;r/asm&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/e6ko7i/a_note_on_mask_registers_avx512/&quot;&gt;r/programming&lt;/a&gt;) or &lt;a href=&quot;https://twitter.com/trav_downs/status/1202637229606264833&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Direct feedback also welcomed by &lt;a href=&quot;mailto:travis.downs@gmail.com&quot;&gt;email&lt;/a&gt; or as &lt;a href=&quot;https://github.com/travisdowns/travisdowns.github.io/issues&quot;&gt;a GitHub issue&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://lemire.me&quot;&gt;Daniel Lemire&lt;/a&gt; who provided access to the AVX-512 system I used for testing.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.stuffedcow.net/&quot;&gt;Henry Wong&lt;/a&gt; who wrote the &lt;a href=&quot;http://blog.stuffedcow.net/2013/05/measuring-rob-capacity/&quot;&gt;original article&lt;/a&gt; which introduced me to this technique and graciously shared the code for his tool, which I now &lt;a href=&quot;https://github.com/travisdowns/robsize&quot;&gt;host on github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/Jeffinatorator/status/1202642436406669314&quot;&gt;Jeff Baker&lt;/a&gt;, &lt;a href=&quot;http://0x80.pl&quot;&gt;Wojciech Muła&lt;/a&gt; for reporting typos.&lt;/p&gt;

&lt;p&gt;Image credit: &lt;a href=&quot;https://www.flickr.com/photos/like_the_grand_canyon/31064064387&quot;&gt;Kellogg’s Special K&lt;/a&gt; by &lt;a href=&quot;https://www.flickr.com/photos/like_the_grand_canyon/&quot;&gt;Like_the_Grand_Canyon&lt;/a&gt; is licensed under &lt;a href=&quot;https://creativecommons.org/licenses/by/2.0/&quot;&gt;CC BY 2.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;If you liked this post, check out the &lt;a href=&quot;/&quot;&gt;homepage&lt;/a&gt; for others you might enjoy.&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:naming&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;These &lt;em&gt;mask registers&lt;/em&gt; are often called &lt;em&gt;k&lt;/em&gt; registers or simply &lt;em&gt;kregs&lt;/em&gt; based on their naming scheme. &lt;a href=&quot;https://twitter.com/tom_forsyth/status/1202666300591337472&quot;&gt;Rumor has it&lt;/a&gt; that this letter was chosen randomly only after a long and bloody naming battle between  MFs. &lt;a href=&quot;#fnref:naming&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:k0note&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;There is sometimes a misconception (until recently even on the AVX-512 wikipedia article) that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k0&lt;/code&gt; is not a normal mask register, but just a hardcoded indicator that no masking should be used. That’s not true: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k0&lt;/code&gt; is a valid mask register and you can read and write to it with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt;-prefixed instructions and &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instructions that write mask registers (e.g., any AVX-512 &lt;a href=&quot;https://www.felixcloutier.com/x86/pcmpeqb:pcmpeqw:pcmpeqd&quot;&gt;comparison&lt;/a&gt;. However, the encoding that would normally be used for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k0&lt;/code&gt; as a writemask register in a &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; operation indicates instead “no masking”, so the contents of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k0&lt;/code&gt; cannot be used for that purpose. &lt;a href=&quot;#fnref:k0note&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:maskmerge&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The distinction being that a zero-masking operation results in zeroed destination elements at positions not selected by the mask, while merging leaves the existing elements in the destination register unchanged at those positions. As as side-effect this means that with merging, the destination register becomes a type of destructive source-destination register and there is an input dependency on this register. &lt;a href=&quot;#fnref:maskmerge&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:kreg&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I’ll try to use the full term &lt;em&gt;mask register&lt;/em&gt; here, but I may also use &lt;em&gt;kreg&lt;/em&gt; a common nickname based on the labels &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k0&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k1&lt;/code&gt;, etc. So just mentally swap &lt;em&gt;kreg&lt;/em&gt; for &lt;em&gt;mask register&lt;/em&gt; if and when you see it (or vice-versa). &lt;a href=&quot;#fnref:kreg&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:hcite&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;H. Wong, &lt;em&gt;Measuring Reorder Buffer Capacity&lt;/em&gt;, May, 2013. [Online]. Available: http://blog.stuffedcow.net/2013/05/measuring-rob-capacity/ &lt;a href=&quot;#fnref:hcite&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:misstime&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Generally taking 100 to 300 cycles each (latency-wise). The wide range is because the cache miss wall clock time varies by a factor of about 2x, generally between 50 and 100 naneseconds, depending on platform and &lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt; details, and the CPU frequency varies by a factor of about 2.5x (say from 2 GHz to 5 GHz). However, on a given host, with equivalent TLB miss/hit behavior, we expect the time to be roughly constant. &lt;a href=&quot;#fnref:misstime&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:roughly&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The reason I have to add &lt;em&gt;roughly&lt;/em&gt; as a weasel word here is itself interesting. A glance at the charts shows that they are certainly not totally flat in either the fast or slow regions surrounding the spike. Rather there are various noticeable regions with distinct behavior and other artifacts: e.g., in Test 29 a very flat region up to about 104 filler instructions, followed by a bump and then a linearly ramping region up to the spike somewhat after 200 instructions. Some of those features are explicable by mentally (or &lt;a href=&quot;https://godbolt.org/z/eAGxhH&quot;&gt;actually&lt;/a&gt;) simulating the pipeline, which reveals that at some point the filler instructions will contribute (although only a cycle or so) to the runtime, but some features are still unexplained (for now). &lt;a href=&quot;#fnref:roughly&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:nonideal&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;For example, a given rename slot may only be able to write a subset of all the &lt;abbr title=&quot;Register alias table: a table which maps an architectural register identifier to a physical register.&quot;&gt;RAT&lt;/abbr&gt; entries, and uses the first available. When the &lt;abbr title=&quot;Register alias table: a table which maps an architectural register identifier to a physical register.&quot;&gt;RAT&lt;/abbr&gt; is almost full, it is possible that none of the allowed entries are empty, so it is as if the structure is full even though some free entries remain, but accessible only to other uops. Since the allowed entries may be essentially random across iterations, this ends up with a more-or-less linear ramp between the low and high performance levels in the non-ideal region. &lt;a href=&quot;#fnref:nonideal&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:twothirds&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The “60 percent” comes from 134 / 224, i.e., the speculative mask register &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; size, divided by the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; size. The idea is that if you’ll hit the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; size limit no matter what once you have 224 instructions in flight, so you’d need to have 60% of those instructions be mask register writes&lt;sup id=&quot;fnref:write:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:write&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt; in order to hit the 134 limit first. Of course, you might also hit some &lt;em&gt;other&lt;/em&gt; limit first, so even 60% might not be enough, but the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; size puts a lower bound on this figure since it &lt;em&gt;always&lt;/em&gt; applies. &lt;a href=&quot;#fnref:twothirds&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:write&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Importantly, only instructions which write a mask register consume a physical register. Instructions that simply read a mask register (e.g,. &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; instructions using a writemask) do not consume a new physical mask register. &lt;a href=&quot;#fnref:write&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:write:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:rename&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;More renaming domains makes things easier on the renamer for a given number of input registers. That is, it is easier to rename 2 &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; and 2 &lt;abbr title=&quot;Single Instruction Multiple Data: an ISA type or ISA extension like Intel's AVX or ARM's NEON that can perform multiple identical operations on elements packed into a SIMD register.&quot;&gt;SIMD&lt;/abbr&gt; input registers (separate domains) than 4 &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; registers. &lt;a href=&quot;#fnref:rename&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:prrt&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This is either the &lt;em&gt;Physical Register Reclaim Table&lt;/em&gt; or &lt;em&gt;Post Retirement Reclaim Table&lt;/em&gt; depending on who you ask. &lt;a href=&quot;#fnref:prrt&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:simply&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Of course, it is not actually so simple. For one, you now need to track these “move elimination sets” (sets of registers all pointing to the same physical register) in order to know when the physical register can be released (once the set is empty), and these sets are themselves a limited resource which must be tracked. Flags introduce another complication since flags are apparently stored along with the destination register, so the presence and liveness of the flags must be tracked as well. &lt;a href=&quot;#fnref:simply&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:moves&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In particular, in the corresponding test for &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; registers (Test 7), the chart looks very different as move elimination reduce the &lt;abbr title=&quot;Physical register file: The hardware registers used for renaming architectural (source visible) registers, usually much larger in number than the architectural register count.&quot;&gt;PRF&lt;/abbr&gt; demand down to almost zero and we get to the &lt;abbr title=&quot;Re-order buffer: n ordered buffer which stores in-progress instructions on an out-of-order processor.&quot;&gt;ROB&lt;/abbr&gt; limit. &lt;a href=&quot;#fnref:moves&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:regreg&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Note that I am not restricting my statement to moves between two mask registers only, but any registers. That is, moves between a &lt;abbr title=&quot;General purpose: as opposed to SIMD or FP. On x86 often refers to instructions such as integer addition, or registers such as eax.&quot;&gt;GP&lt;/abbr&gt; registers and a mask registers are also not eliminated (the latter fact is obvious if consider than they use distinct register files, so move elimination seems impossible). &lt;a href=&quot;#fnref:regreg&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zero&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Probably by pointing the entry in the &lt;abbr title=&quot;Register alias table: a table which maps an architectural register identifier to a physical register.&quot;&gt;RAT&lt;/abbr&gt; to a fixed, shared zero register, or setting a flag in the &lt;abbr title=&quot;Register alias table: a table which maps an architectural register identifier to a physical register.&quot;&gt;RAT&lt;/abbr&gt; that indicates it is zero. &lt;a href=&quot;#fnref:zero&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:otherzero&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Although &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xor&lt;/code&gt; is the most reliable, other idioms may be recognized as zeroing or dependency breaking idioms by some CPUs as well, e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sub reg,reg&lt;/code&gt; and even &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sbb reg, reg&lt;/code&gt; which is not a zeroing idiom, but rather sets the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reg&lt;/code&gt; to zero or -1 (all bits set) depending on the value of the carry flag. This doesn’t depend on the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reg&lt;/code&gt; but only the carry flag, and some CPUs recognize that and break the dependency. Agner’s &lt;a href=&quot;https://www.agner.org/optimize/#manual_microarch&quot;&gt;microarchitecture guide&lt;/a&gt; covers the &lt;abbr title=&quot;Microarchitecture: a specific implementation of an ISA, e.g., &amp;quot;Haswell microarchitecture&amp;quot;.&quot;&gt;uarch&lt;/abbr&gt;-dependent support for these idioms very well. &lt;a href=&quot;#fnref:otherzero&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:notall&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Note that only the two source registers really need to be the same: if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxorb k1, k1, k1&lt;/code&gt; is treated as zeroing, I would expect the same for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kxorb k1, k2, k2&lt;/code&gt;. &lt;a href=&quot;#fnref:notall&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:runit&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Run all the tests in this section using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./uarch-bench.sh --test-name=avx512/*&lt;/code&gt;. &lt;a href=&quot;#fnref:runit&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:fyiuops&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This is why uops.info reports the latency for both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmov r32, k&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmov k, 32&lt;/code&gt; as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;= 3&lt;/code&gt;. They know the pair takes 4 cycles in total and under the assumption that each instruction must take &lt;em&gt;at least&lt;/em&gt; one cycle the only thing you can really say is that each instruction takes at most 3 cycles. &lt;a href=&quot;#fnref:fyiuops&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:tech&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Technically, I only tested the xor zeroing idiom, but since that’s the groud-zero, most basic idiom we can pretty sure nothing else will be recognized as zeroing. I’m open to being proven wrong: the code is public and easy to modify to test whatever idiom you want. &lt;a href=&quot;#fnref:tech&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Travis Downs</name><email>travis.downs@gmail.com</email></author><category term="blog" /><category term="performance" /><category term="c++" /><category term="Intel" /><category term="uarch" /><summary type="html">Some mostly too-low-level-to-care-about hardware details of the mask registers introduced in AVX-512.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://travisdowns.github.io/assets/kreg/specialk.jpg" /><media:content medium="image" url="https://travisdowns.github.io/assets/kreg/specialk.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>