_id: 5936acf0-31e5-11ec-b62a-5b9ea25a934c
_parent: 'https://travisdowns.github.io/blog/2019/05/22/sorting.html'
replying_to_uid: c02de000-8d30-11ea-9db0-e9d644cafe33
message: "@Travis Downs (there seems to be no way to reply to a reply)\r\n\r\n> Well I do plan to publish some usable radix sorts when this is done, but I don’t think is is very obvious how to write a C qsort that improves significantly on the existing qsort. In relation to the inlining aspect, you could do is a qsort implementation that is implemented in a header in C, just like C++ and rely on the optimizer to inline the comparator function. This isn’t totally straightforward, as described in a footnote but I’m sure it could be done.\r\n\r\nThere is a bit of work being down to optimize GLIBC's qsort in [this patchset](https://patchwork.sourceware.org/project/glibc/list/?series=2745). \r\n\r\nThe reality is most of the optimization is for faster swap and to make qsort safe against the `O(n^2)` worst case. In many ways [GLIBC's qsort is still living in the 1990s....](https://sourceware.org/git/?p=glibc.git;a=blob;f=stdlib/qsort.c;h=0f6d7ff787b87b3a432177d8bf662b3a47cdc64d;hb=HEAD#l42).\r\n\r\nWe explored writing an optimized version for specific types by providing type specific compare functions then checking on `qsort` entry if the compare function used was one of the known types i.e\r\n\r\n```\r\nqsort(...) {\r\n    if(cmpfunc == INT_CMP) {\r\n        optimized_int_qsort(...);\r\n    }\r\n...\r\n}\r\n```\r\n\r\nWe have implementation for `uint32_t` (was able to beat your radix7 up to size==8192 for random and to IIRC ~2^20 for semi-sorted data) but decided these pure typed qsort's are not particularly common in real code and mostly just used for benchmarking so it wasn't worth the code size."
name: Noah Goldstein
email: ''
hp: ''
date: 1634762165
