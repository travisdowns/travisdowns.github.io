_id: 693d2630-96df-11ea-8bfa-f9544424bd98
_parent: 'https://travisdowns.github.io/blog/2020/05/13/intel-zero-opt.html'
replying_to_uid: 59652190-96ad-11ea-aacc-b1346604130d
message: "I am not sure we are on the same page wrt the costs of a 512-bit wide compare-to-zero. I am not an ASIC designer (I feel like I'm pointing this out almost every day, now!), but I believe the cost of such a comparator is quite small in the overall scheme of things. Things like 128-bit (result size) integer multipliers are probably a couple of orders of magnitude larger, and they still seem to take up vanishingly small portions of the chip if you look at die shots. So I don't think having a 512-bit wide comparator somewhere in the cache hierarchy is a problem.\r\n\r\nKeep in mind, this is still very much _inside_ the processor! The whole cache hierarchy we are talking about is inside the processor, and the L2 is right inside the core. So the cache is implemented in very much the same logic process as the core itself, so there is particular problem putting a comparator in there.\r\n\r\n> My prediction, then, is that if you “trick” a register into being zero, rather than performing operations that may have it renamed to the zero register, you’ll see the effect go away.\r\n\r\nThe test already does this: if you look at the assembly, no zeroing idiom is being used, and the function is compiled separately and so is generic for all values. The function takes an integer register, and broadcasts it to a vector one, so the zeroness of the register is lost (unless you think there is a special case for broadcast from a zero integer register, which I think is very unlikely). Still, I did double check and changed the code to read from a `volatile int zero = 0` variable, and checked the assembly to confirm that the zero now comes from a memory read, not a zeroing idiom in an integer register and I get the results.\r\n\r\nApart from the actual results, I see at least a couple of problems with the suggested mechanism:\r\n\r\n1) I think it would massively reduce the applicability of the optimization, because a lot of zeroing is done with not-zero-idiom initialized registers. I think also the zeroed-by-idiom state is lost after e.g., a context switch.\r\n\r\n2) The thing you need to track is the zeroness of the entire 64-byte line. Constantly checking and updating this state on stores of smaller values seems both expensive and difficult. For example when you write a zero to a line, you need know if the rest of the line was zero to update the all zero state. Also, you might write the line millions of times before it is ever evicted from the L1, so you update the status millions of times when only the final state is useful.\r\n\r\nCalculating this property at the moment (or nearby) to when the line is actually being evicted, as Intel seems to do, strikes me as a better strategy."
name: Travis Downs
email: c6937532928911c0dae3c9c89b658c09
hp: ''
date: 1589569687
