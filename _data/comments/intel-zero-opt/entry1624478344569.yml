_id: 762deb60-d45d-11eb-a781-93a616abab19
_parent: 'https://travisdowns.github.io/blog/2020/05/13/intel-zero-opt.html'
replying_to_uid: ea575830-d45a-11eb-a781-93a616abab19
message: "I agree with your description of how the zero page allocation happens[1], but it's not inconsistent with anything in the footnote, is it?\r\n\r\nThe footnote talks about the _userspace_ side of things: _userspace_ gets \"effectively\" zeroed memory from the OS, regardless of how that happens. If `malloc` was used, the calling can't assume the returned region is zero, because the (userspace) allocator may have either recycled an existing free region (not zero) or returned fresh obtained from the OS (zero). So the caller must zero the memory, which may be redundant if the pages were known to be zero to the allocator.\r\n\r\nIn `calloc`, the zeroing happens inside the (userspace) allocator, which _knows_ where it got the pages from, and hence whether they are guaranteed zero. So in the case of fresh memory from the OS, it can skip the zeroing.\r\n\r\n\r\n---\r\n[1] Although it's configurable so not _everyone_ is using the zero page, especially outside of x86, and some have argued that this whole zero-page page thing is worse than the simple alternative: the benefit is that \"sparse\" mappings in which most pages are never written to, but are read, are efficient: they need only one physical page for every _written_ page, but the downside is you need an extra fault for every page. Since _most_ pages are written after allocation, is it even a win?"
name: Travis Downs
email: c6937532928911c0dae3c9c89b658c09
hp: ''
date: 1624478344
